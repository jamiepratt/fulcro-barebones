shadow$provide.module$node_modules$victory_box_plot$lib$helper_methods = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getDomain = exports.getData = exports.getBaseProps = void 0;
  var _groupBy2 = _interopRequireDefault(require("module$node_modules$lodash$groupBy")), _uniq2 = _interopRequireDefault(require("module$node_modules$lodash$uniq")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _orderBy2 = _interopRequireDefault(require("module$node_modules$lodash$orderBy")), _victoryCore = require("module$node_modules$victory_core$lib$index"), _d3Array = require("module$node_modules$victory_vendor$lib$d3_array");
  const TYPES = ["max", "min", "median", "q1", "q3"], checkProcessedData = data => {
    if (data.every(datum => TYPES.every(val => "undefined" !== typeof datum[`_${val}`]))) {
      data = data.map(d => d._x);
      if (!(0,_uniq2.default)(data).length === data.length) {
        throw Error("\n        data prop may only take an array of objects with a unique\n        independent variable. Make sure your x values are distinct.\n      ");
      }
      return !0;
    }
    return !1;
  }, nanToNull = val => Number.isNaN(val) ? null : val, getSummaryStatistics = data => {
    var dependentVars = data.map(datum => datum._y);
    dependentVars = {_q1:nanToNull((0,_d3Array.quantile)(dependentVars, 0.25)), _q3:nanToNull((0,_d3Array.quantile)(dependentVars, 0.75)), _min:nanToNull((0,_d3Array.min)(dependentVars)), _median:nanToNull((0,_d3Array.quantile)(dependentVars, 0.5)), _max:nanToNull((0,_d3Array.max)(dependentVars))};
    return Object.assign({}, data[0], dependentVars, {_y:data[0]._y});
  }, processData = data => {
    if (checkProcessedData(data)) {
      return data;
    }
    const arrayX = data.every(datum => Array.isArray(datum._x)), arrayY = data.every(datum => Array.isArray(datum._y));
    if (arrayX) {
      throw Error("\n        data should not be given as in array for x\n      ");
    }
    if (arrayY) {
      return data.map(datum => {
        var dataArray = datum._y.map(d => Object.assign({}, datum, {_y:d}));
        dataArray = (0,_orderBy2.default)(dataArray, "_y");
        return getSummaryStatistics(dataArray);
      });
    }
    const groupedData = (0,_groupBy2.default)(data, "_x");
    return Object.keys(groupedData).map(key => {
      key = (0,_orderBy2.default)(groupedData[key], "_y");
      return getSummaryStatistics(key);
    });
  }, getData = props => {
    const accessorTypes = TYPES.concat("x", "y");
    props = _victoryCore.Data.formatData(props.data, props, accessorTypes);
    return props.length ? processData(props) : [];
  };
  exports.getData = getData;
  const reduceDataset = (dataset, props, axis) => {
    var minDomain = _victoryCore.Domain.getMinFromProps(props, axis);
    props = _victoryCore.Domain.getMaxFromProps(props, axis);
    minDomain = void 0 !== minDomain ? minDomain : dataset.reduce((memo, datum) => memo < datum[`_${axis}`] ? memo : datum[`_${axis}`], Infinity);
    dataset = void 0 !== props ? props : dataset.reduce((memo, datum) => memo > datum[`_${axis}`] ? memo : datum[`_${axis}`], -Infinity);
    return _victoryCore.Domain.getDomainFromMinMax(minDomain, dataset);
  }, getDomainFromMinMaxValues = (dataset, props, axis) => {
    var minDomain = _victoryCore.Domain.getMinFromProps(props, axis);
    props = _victoryCore.Domain.getMaxFromProps(props, axis);
    minDomain = void 0 !== minDomain ? minDomain : dataset.reduce((memo, datum) => memo < datum._min ? memo : datum._min, Infinity);
    dataset = void 0 !== props ? props : dataset.reduce((memo, datum) => memo > datum._max ? memo : datum._max, -Infinity);
    return _victoryCore.Domain.getDomainFromMinMax(minDomain, dataset);
  }, getDomainFromData = (props, axis) => {
    const minDomain = _victoryCore.Domain.getMinFromProps(props, axis), maxDomain = _victoryCore.Domain.getMaxFromProps(props, axis), dataset = getData(props);
    return 1 > dataset.length ? void 0 !== minDomain && void 0 !== maxDomain ? _victoryCore.Domain.getDomainFromMinMax(minDomain, maxDomain) : void 0 : "y" === axis ? getDomainFromMinMaxValues(dataset, props, axis) : reduceDataset(dataset, props, axis);
  }, getDomain = (props, axis) => _victoryCore.Domain.createDomainFunction(getDomainFromData)(props, axis);
  exports.getDomain = getDomain;
  const getLabelStyle = (props, styleObject, namespace) => {
    styleObject = styleObject[`${namespace}Labels`] || styleObject.labels;
    return _victoryCore.Helpers.isTooltip(props[`${namespace}LabelComponent`] || props.labelComponent) ? (0,_defaults2.default)({}, (props.theme && props.theme.tooltip || {}).style, styleObject) : styleObject;
  }, getCalculatedValues = props => {
    const {theme, horizontal} = props, data = getData(props);
    var JSCompiler_object_inline_x_1097 = _victoryCore.Helpers.getRange(props, "x"), JSCompiler_object_inline_y_1098 = _victoryCore.Helpers.getRange(props, "y");
    const domain = {x:getDomain(props, "x"), y:getDomain(props, "y")};
    JSCompiler_object_inline_x_1097 = {x:_victoryCore.Scale.getBaseScale(props, "x").domain(domain.x).range(props.horizontal ? JSCompiler_object_inline_y_1098 : JSCompiler_object_inline_x_1097), y:_victoryCore.Scale.getBaseScale(props, "y").domain(domain.y).range(props.horizontal ? JSCompiler_object_inline_x_1097 : JSCompiler_object_inline_y_1098)};
    JSCompiler_object_inline_y_1098 = theme && theme.boxplot && theme.boxplot.style ? theme.boxplot.style : {};
    void 0 === JSCompiler_object_inline_y_1098 && (JSCompiler_object_inline_y_1098 = {});
    if (props.disableInlineStyles) {
      JSCompiler_object_inline_y_1098 = {};
    } else {
      var style = props.style || {}, labelStyles = (0,_defaults2.default)({}, style.labels, getLabelStyle(props, JSCompiler_object_inline_y_1098)), boxStyles = (0,_defaults2.default)({}, style.boxes, JSCompiler_object_inline_y_1098.boxes), whiskerStyles = (0,_defaults2.default)({}, style.whiskers, JSCompiler_object_inline_y_1098.whiskers);
      JSCompiler_object_inline_y_1098 = {boxes:boxStyles, labels:labelStyles, parent:(0,_defaults2.default)({}, style.parent, JSCompiler_object_inline_y_1098.parent, {height:"100%", width:"100%"}), max:(0,_defaults2.default)({}, style.max, JSCompiler_object_inline_y_1098.max, whiskerStyles), maxLabels:(0,_defaults2.default)({}, style.maxLabels, getLabelStyle(props, JSCompiler_object_inline_y_1098, "max"), labelStyles), median:(0,_defaults2.default)({}, style.median, JSCompiler_object_inline_y_1098.median, 
      whiskerStyles), medianLabels:(0,_defaults2.default)({}, style.medianLabels, getLabelStyle(props, JSCompiler_object_inline_y_1098, "median"), labelStyles), min:(0,_defaults2.default)({}, style.min, JSCompiler_object_inline_y_1098.min, whiskerStyles), minLabels:(0,_defaults2.default)({}, style.minLabels, getLabelStyle(props, JSCompiler_object_inline_y_1098, "min"), labelStyles), q1:(0,_defaults2.default)({}, style.q1, JSCompiler_object_inline_y_1098.q1, boxStyles), q1Labels:(0,_defaults2.default)({}, 
      style.q1Labels, getLabelStyle(props, JSCompiler_object_inline_y_1098, "q1"), labelStyles), q3:(0,_defaults2.default)({}, style.q3, JSCompiler_object_inline_y_1098.q3, boxStyles), q3Labels:(0,_defaults2.default)({}, style.q3Labels, getLabelStyle(props, JSCompiler_object_inline_y_1098, "q3"), labelStyles), whiskers:whiskerStyles};
    }
    style = props.horizontal ? "top" : "right";
    return {data, horizontal, domain, scale:JSCompiler_object_inline_x_1097, style:JSCompiler_object_inline_y_1098, labelOrientation:props.labelOrientation || style, boxWidth:props.boxWidth || 1};
  }, getLabelProps = (props, text, type) => {
    const {datum, positions, index, boxWidth, horizontal, labelOrientation, style, theme, disableInlineStyles} = props, orientation = "object" === typeof labelOrientation && labelOrientation[type] || labelOrientation, labelStyle = style[`${type}Labels`] || style.labels, defaultVerticalAnchors = {top:"end", bottom:"start", left:"middle", right:"middle"}, defaultTextAnchors = {left:"end", right:"start", top:"middle", bottom:"middle"};
    var whiskerWidth = "number" === typeof props.whiskerWidth ? props.whiskerWidth : boxWidth;
    const width = "min" === type || "max" === type ? whiskerWidth : boxWidth;
    whiskerWidth = coord => {
      const sign = {x:"left" === orientation ? -1 : 1, y:"top" === orientation ? -1 : 1};
      return sign[coord] * width / 2 + sign[coord] * (labelStyle.padding || 0);
    };
    text = {text, datum, index, orientation, style:disableInlineStyles ? {} : labelStyle, y:horizontal ? positions.y : positions[type], x:horizontal ? positions[type] : positions.x, dy:horizontal ? whiskerWidth("y") : 0, dx:horizontal ? 0 : whiskerWidth("x"), textAnchor:labelStyle.textAnchor || defaultTextAnchors[orientation], verticalAnchor:labelStyle.verticalAnchor || defaultVerticalAnchors[orientation], angle:labelStyle.angle, horizontal, disableInlineStyles};
    return _victoryCore.Helpers.isTooltip(props[`${type}LabelComponent`]) ? (0,_defaults2.default)({}, text, _victoryCore.Helpers.omit(theme && theme.tooltip || {}, ["style"])) : text;
  }, isDatumOutOfBounds = (datum, domain) => {
    const {_x, _min, _max} = datum;
    var minDomainX = _victoryCore.Collection.getMinValue(domain.x);
    datum = _victoryCore.Collection.getMaxValue(domain.x);
    var minDomainY = _victoryCore.Collection.getMinValue(domain.y);
    domain = _victoryCore.Collection.getMaxValue(domain.y);
    const underMin = min => val => void 0 !== val && val < min, overMax = max => val => void 0 !== val && val > max;
    minDomainX = underMin(minDomainX);
    minDomainY = underMin(minDomainY);
    datum = overMax(datum);
    domain = overMax(domain);
    let yOutOfBounds, xOutOfBounds;
    if (minDomainX(_x) || datum(_x)) {
      xOutOfBounds = !0;
    }
    if (minDomainY(_min) && minDomainY(_max) || domain(_min) && domain(_max)) {
      yOutOfBounds = !0;
    }
    return yOutOfBounds || xOutOfBounds;
  };
  exports.getBaseProps = (initialProps, fallbackProps) => {
    initialProps = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "boxplot");
    const props = Object.assign({}, initialProps, getCalculatedValues(initialProps)), {groupComponent, width, height, padding, standalone, theme, events, sharedEvents, scale, horizontal, data, style, domain, name} = props, boxScale = scale.y;
    return data.reduce((acc, datum, index) => {
      const eventKey = _victoryCore.Helpers.isNil(datum.eventKey) ? index : datum.eventKey;
      if (isDatumOutOfBounds(datum, domain)) {
        return acc;
      }
      const positions = {x:horizontal ? scale.y(datum._y) : scale.x(datum._x), y:horizontal ? scale.x(datum._x) : scale.y(datum._y), min:boxScale(datum._min), max:boxScale(datum._max), median:boxScale(datum._median), q1:boxScale(datum._q1), q3:boxScale(datum._q3)}, dataProps = Object.assign({index, datum, positions}, props);
      datum = TYPES.reduce((memo, type) => {
        if ("median" === type) {
          const {boxWidth, horizontal, style, datum, scale, index, disableInlineStyles} = dataProps, {median, x, y} = dataProps.positions;
          var JSCompiler_temp = {datum, scale, index, x1:horizontal ? median : x - boxWidth / 2, y1:horizontal ? y - boxWidth / 2 : median, x2:horizontal ? median : x + boxWidth / 2, y2:horizontal ? y + boxWidth / 2 : median, style:disableInlineStyles ? {} : style.median, disableInlineStyles};
        } else {
          if ("min" === type || "max" === type) {
            const {horizontal, style, boxWidth, whiskerWidth, datum, scale, index, disableInlineStyles} = dataProps, {min, max, q1, q3, x, y} = dataProps.positions;
            JSCompiler_temp = "min" === type ? q1 : q3;
            const whiskerValue = "min" === type ? min : max, width = "number" === typeof whiskerWidth ? whiskerWidth : boxWidth;
            JSCompiler_temp = {datum, index, scale, majorWhisker:{x1:horizontal ? JSCompiler_temp : x, y1:horizontal ? y : JSCompiler_temp, x2:horizontal ? whiskerValue : x, y2:horizontal ? y : whiskerValue}, minorWhisker:{x1:horizontal ? whiskerValue : x - width / 2, y1:horizontal ? y - width / 2 : whiskerValue, x2:horizontal ? whiskerValue : x + width / 2, y2:horizontal ? y + width / 2 : whiskerValue}, style:disableInlineStyles ? {} : style[type] || style.whisker, disableInlineStyles};
          } else {
            const {horizontal, boxWidth, style, scale, datum, index, disableInlineStyles} = dataProps, {median, q1, q3, x, y} = dataProps.positions;
            JSCompiler_temp = {datum, scale, index, x:horizontal ? "q1" === type ? q1 : median : x - boxWidth / 2, y:horizontal ? y - boxWidth / 2 : "q1" === type ? median : q3, width:horizontal ? "q1" === type ? median - q1 : q3 - median : boxWidth, height:horizontal ? boxWidth : "q1" === type ? q1 - median : median - q3, style:disableInlineStyles ? {} : style[type] || style.boxes, disableInlineStyles};
          }
        }
        memo[type] = JSCompiler_temp;
        return memo;
      }, {});
      acc[eventKey] = datum;
      TYPES.forEach(type => {
        {
          const {datum, index, labels} = dataProps;
          var JSCompiler_inline_result = (JSCompiler_inline_result = dataProps[`${type}Labels`]) || labels ? !0 === JSCompiler_inline_result || !0 === labels ? `${datum[`_${type}`]}` : Array.isArray(JSCompiler_inline_result) ? JSCompiler_inline_result[index] : JSCompiler_inline_result : null;
        }
        const labelProp = props.labels || props[`${type}Labels`];
        if (null !== JSCompiler_inline_result && void 0 !== JSCompiler_inline_result || labelProp && (events || sharedEvents)) {
          acc[eventKey][`${type}Labels`] = getLabelProps(Object.assign({}, props, dataProps), JSCompiler_inline_result, type);
        }
      });
      return acc;
    }, {parent:{domain, scale, width, height, data, standalone, name, theme, style:style.parent || {}, padding, groupComponent, horizontal}});
  };
};

//# sourceMappingURL=module$node_modules$victory_box_plot$lib$helper_methods.js.map
