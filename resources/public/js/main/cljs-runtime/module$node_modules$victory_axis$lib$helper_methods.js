shadow$provide.module$node_modules$victory_axis$lib$helper_methods = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getStyles = exports.getBaseProps = void 0;
  var _defaults2 = function(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }(require("module$node_modules$lodash$defaults")), _victoryCore = require("module$node_modules$victory_core$lib$index");
  const orientationSign = {top:-1, left:-1, right:1, bottom:1}, exists = val => null !== val && void 0 !== val, getStyleObject = props => {
    const {theme, dependentAxis} = props, generalAxisStyle = theme && theme.axis && theme.axis.style;
    props = dependentAxis ? "dependentAxis" : "independentAxis";
    const specificAxisStyle = theme && theme[props] && theme[props].style;
    props = () => "axis axisLabel grid parent tickLabels ticks".split(" ").reduce((memo, curr) => {
      memo[curr] = (0,_defaults2.default)({}, specificAxisStyle[curr], generalAxisStyle[curr]);
      return memo;
    }, {});
    return generalAxisStyle && specificAxisStyle ? props() : specificAxisStyle || generalAxisStyle;
  }, getStyles = function(props, styleObject) {
    void 0 === styleObject && (styleObject = {});
    props = props.style || {};
    return {parent:(0,_defaults2.default)(props.parent, styleObject.parent, {height:"100%", width:"100%"}), axis:(0,_defaults2.default)({}, props.axis, styleObject.axis), axisLabel:(0,_defaults2.default)({}, props.axisLabel, styleObject.axisLabel), grid:(0,_defaults2.default)({}, props.grid, styleObject.grid), ticks:(0,_defaults2.default)({}, props.ticks, styleObject.ticks), tickLabels:(0,_defaults2.default)({}, props.tickLabels, styleObject.tickLabels)};
  };
  exports.getStyles = getStyles;
  const getAxisProps = (modifiedProps, calculatedValues, globalTransform) => {
    const {style, padding, isVertical} = calculatedValues, {width, height} = modifiedProps;
    return {style:style.axis, x1:isVertical ? globalTransform.x : padding.left + globalTransform.x, x2:isVertical ? globalTransform.x : width - padding.right + globalTransform.x, y1:isVertical ? padding.top + globalTransform.y : globalTransform.y, y2:isVertical ? height - padding.bottom + globalTransform.y : globalTransform.y};
  }, getAxisLabelProps = (props, calculatedValues, globalTransform) => {
    const {style, orientation, padding, labelPadding, isVertical} = calculatedValues;
    calculatedValues = orientationSign[orientation];
    const hPadding = padding.left + padding.right, vPadding = padding.top + padding.bottom, labelStyle = style.axisLabel;
    return {x:isVertical ? globalTransform.x + calculatedValues * labelPadding : (props.width - hPadding) / 2 + padding.left + globalTransform.x, y:isVertical ? (props.height - vPadding) / 2 + padding.top + globalTransform.y : calculatedValues * labelPadding + globalTransform.y, verticalAnchor:labelStyle.verticalAnchor || (0 > calculatedValues ? "end" : "start"), textAnchor:labelStyle.textAnchor || "middle", angle:void 0 === labelStyle.angle ? isVertical ? -90 : 0 : labelStyle.angle, style:labelStyle, 
    text:props.label};
  }, getDefaultOrientations = (axis, originSign, horizontal) => {
    originSign = originSign || "positive";
    const orientations = {positive:{x:"bottom", y:"left"}, negative:{x:"top", y:"right"}}, horizontalOrientations = {positive:{x:"left", y:"bottom"}, negative:{x:"right", y:"top"}};
    return horizontal ? horizontalOrientations[originSign][axis] : orientations[originSign][axis];
  }, getStandaloneOffset = (props, calculatedValues) => {
    const {style, scale, orientation, padding, axis, ticks, stringTicks, isVertical, labelPadding} = calculatedValues, {polar, horizontal} = props, sharedProps = {scale:{[axis]:scale}, polar, horizontal, ticks, stringTicks};
    calculatedValues = "right" === orientation ? padding.right : padding.left;
    var yPadding = "top" === orientation ? padding.top : padding.bottom;
    calculatedValues = null !== props.offsetX && void 0 !== props.offsetX ? props.offsetX : calculatedValues;
    yPadding = null !== props.offsetY && void 0 !== props.offsetY ? props.offsetY : yPadding;
    var fontSize = style.axisLabel.fontSize || 14, tickSizes = ticks.map((data, index) => _victoryCore.Helpers.evaluateStyle(style.ticks, Object.assign({}, sharedProps, {tick:stringTicks ? props.tickValues[data - 1] : data, index})).size || 0);
    tickSizes = fontSize + 2 * Math.max(...tickSizes) + labelPadding;
    fontSize *= 1.2;
    return {x:null !== calculatedValues && void 0 !== calculatedValues ? calculatedValues : isVertical ? tickSizes : fontSize, y:null !== yPadding && void 0 !== yPadding ? yPadding : isVertical ? fontSize : tickSizes};
  }, isEqual = (a, b) => a instanceof Date && b instanceof Date ? a.getTime() === b.getTime() : a === b, getLayoutProps = (modifiedProps, calculatedValues) => {
    if (calculatedValues.domain.x && calculatedValues.domain.y) {
      if (modifiedProps.horizontal) {
        const {scale, origin, orientation, orientations, domain, padding} = calculatedValues, {top, bottom, left, right} = padding;
        var JSCompiler_object_inline_y_1077 = "bottom" === orientation || "top" === orientation ? orientation : orientations.x, JSCompiler_object_inline_x_1078 = "left" === orientation || "right" === orientation ? orientation : orientations.y, JSCompiler_object_inline_x_1079 = "bottom" === JSCompiler_object_inline_y_1077 ? bottom : top;
        var offset = "left" === JSCompiler_object_inline_x_1078 ? left : right;
        JSCompiler_object_inline_x_1078 = "left" === JSCompiler_object_inline_x_1078 ? 0 : modifiedProps.width;
        var JSCompiler_object_inline_x_1082 = "bottom" === JSCompiler_object_inline_y_1077 ? modifiedProps.height : 0, JSCompiler_object_inline_x_1083 = isEqual(origin.x, domain.x[0]) || isEqual(origin.x, domain.x[1]) ? 0 : scale.x(origin.x);
        JSCompiler_object_inline_y_1077 = isEqual(origin.y, domain.y[0]) || isEqual(origin.y, domain.y[1]) ? 0 : scale.y(origin.y);
        JSCompiler_object_inline_x_1079 = JSCompiler_object_inline_x_1083 ? Math.abs(JSCompiler_object_inline_x_1082 - JSCompiler_object_inline_x_1083) : JSCompiler_object_inline_x_1079;
        offset = JSCompiler_object_inline_y_1077 ? Math.abs(JSCompiler_object_inline_x_1078 - JSCompiler_object_inline_y_1077) : offset;
        offset = exists(modifiedProps.offsetX) ? modifiedProps.offsetX : offset;
        JSCompiler_object_inline_x_1079 = exists(modifiedProps.offsetY) ? modifiedProps.offsetY : JSCompiler_object_inline_x_1079;
        offset = {x:offset, y:JSCompiler_object_inline_x_1079};
      } else {
        const {scale, origin, orientation, orientations, domain, padding} = calculatedValues, {top, bottom, left, right} = padding;
        JSCompiler_object_inline_y_1077 = "bottom" === orientation || "top" === orientation ? orientation : orientations.x;
        JSCompiler_object_inline_x_1078 = "left" === orientation || "right" === orientation ? orientation : orientations.y;
        JSCompiler_object_inline_x_1079 = "left" === JSCompiler_object_inline_x_1078 ? left : right;
        offset = "bottom" === JSCompiler_object_inline_y_1077 ? bottom : top;
        JSCompiler_object_inline_x_1078 = "left" === JSCompiler_object_inline_x_1078 ? 0 : modifiedProps.width;
        JSCompiler_object_inline_y_1077 = "bottom" === JSCompiler_object_inline_y_1077 ? modifiedProps.height : 0;
        JSCompiler_object_inline_x_1083 = isEqual(origin.x, domain.x[0]) || isEqual(origin.x, domain.x[1]) ? 0 : scale.x(origin.x);
        JSCompiler_object_inline_x_1082 = isEqual(origin.y, domain.y[0]) || isEqual(origin.y, domain.y[1]) ? 0 : scale.y(origin.y);
        JSCompiler_object_inline_x_1079 = JSCompiler_object_inline_x_1083 ? Math.abs(JSCompiler_object_inline_x_1078 - JSCompiler_object_inline_x_1083) : JSCompiler_object_inline_x_1079;
        offset = JSCompiler_object_inline_x_1082 ? Math.abs(JSCompiler_object_inline_y_1077 - JSCompiler_object_inline_x_1082) : offset;
        JSCompiler_object_inline_x_1079 = exists(modifiedProps.offsetX) ? modifiedProps.offsetX : JSCompiler_object_inline_x_1079;
        offset = exists(modifiedProps.offsetY) ? modifiedProps.offsetY : offset;
        offset = {x:JSCompiler_object_inline_x_1079, y:offset};
      }
    } else {
      offset = getStandaloneOffset(modifiedProps, calculatedValues);
    }
    JSCompiler_object_inline_x_1079 = offset;
    const {orientation, axis} = calculatedValues;
    JSCompiler_object_inline_x_1078 = _victoryCore.Axis.getAxisValue(modifiedProps, axis);
    JSCompiler_object_inline_x_1079 = {top:{x:0, y:void 0 !== JSCompiler_object_inline_x_1078 ? JSCompiler_object_inline_x_1078 : JSCompiler_object_inline_x_1079.y}, bottom:{x:0, y:void 0 !== JSCompiler_object_inline_x_1078 ? JSCompiler_object_inline_x_1078 : modifiedProps.height - JSCompiler_object_inline_x_1079.y}, left:{x:void 0 !== JSCompiler_object_inline_x_1078 ? JSCompiler_object_inline_x_1078 : JSCompiler_object_inline_x_1079.x, y:0}, right:{x:void 0 !== JSCompiler_object_inline_x_1078 ? 
    JSCompiler_object_inline_x_1078 : modifiedProps.width - JSCompiler_object_inline_x_1079.x, y:0}}[orientation];
    const {padding, orientation:orientation$jscomp$0, crossAxis} = calculatedValues;
    JSCompiler_object_inline_x_1078 = "right" === orientation$jscomp$0 ? padding.right : padding.left;
    JSCompiler_object_inline_y_1077 = "top" === orientation$jscomp$0 ? padding.top : padding.bottom;
    offset = {x:crossAxis ? offset.x - JSCompiler_object_inline_x_1078 : 0, y:crossAxis ? offset.y - JSCompiler_object_inline_y_1077 : 0};
    const {orientation:orientation$jscomp$1, padding:padding$jscomp$0, isVertical} = calculatedValues;
    calculatedValues = -orientationSign[orientation$jscomp$1];
    return {globalTransform:JSCompiler_object_inline_x_1079, gridOffset:offset, gridEdge:{x:isVertical ? calculatedValues * (modifiedProps.width - (padding$jscomp$0.left + padding$jscomp$0.right)) : 0, y:isVertical ? 0 : calculatedValues * (modifiedProps.height - (padding$jscomp$0.top + padding$jscomp$0.bottom))}};
  }, getCalculatedValues = props => {
    var defaultStyles = getStyleObject(props);
    defaultStyles = getStyles(props, defaultStyles);
    const padding = _victoryCore.Helpers.getPadding(props);
    var labelStyle = defaultStyles.axisLabel || {};
    if (void 0 !== labelStyle.padding && null !== labelStyle.padding) {
      var JSCompiler_inline_result = labelStyle.padding;
    } else {
      JSCompiler_inline_result = _victoryCore.Axis.isVertical(props), labelStyle = labelStyle.fontSize || 14, JSCompiler_inline_result = props.label ? labelStyle * (JSCompiler_inline_result ? 2.3 : 1.6) : 0;
    }
    labelStyle = _victoryCore.Axis.stringTicks(props) ? props.tickValues : void 0;
    const axis = _victoryCore.Axis.getAxis(props);
    var axisDomain = _victoryCore.Axis.getDomain(props), axis$jscomp$0 = _victoryCore.Axis.getAxis(props);
    const {orientation, horizontal} = props;
    var JSCompiler_inline_result$jscomp$0 = orientation ? {top:"x", bottom:"x", left:"y", right:"y"}[orientation] : horizontal ? "x" === axis$jscomp$0 ? "y" : "x" : axis$jscomp$0;
    var scale = _victoryCore.Scale.getBaseScale(props, axis$jscomp$0);
    axis$jscomp$0 = props.domain && props.domain[axis$jscomp$0] || _victoryCore.Axis.getDomain(props) || scale.domain();
    scale.range(_victoryCore.Helpers.getRange(props, JSCompiler_inline_result$jscomp$0));
    scale.domain(axis$jscomp$0);
    axis$jscomp$0 = "x" === axis ? axisDomain : void 0;
    var yAxisDomain = "y" === axis ? axisDomain : void 0, xAxisScale = "x" === axis ? scale : void 0, yAxisScale = "y" === axis ? scale : void 0;
    axisDomain = !(!1 === props.crossAxis || !0 === props.standalone);
    JSCompiler_inline_result$jscomp$0 = _victoryCore.Axis.getTicks(props, scale, axisDomain);
    scale = _victoryCore.Axis.getTickFormat(props, scale);
    var JSCompiler_object_inline_x_1095 = _victoryCore.Helpers.getRange(props, "x"), JSCompiler_object_inline_y_1096 = _victoryCore.Helpers.getRange(props, "y");
    axis$jscomp$0 = {x:props.domain && props.domain.x ? props.domain.x : axis$jscomp$0, y:props.domain && props.domain.y ? props.domain.y : yAxisDomain};
    xAxisScale = {x:props.domain && props.domain.x ? _victoryCore.Scale.getBaseScale(props, "x").domain(props.domain.x).range(props.horizontal ? JSCompiler_object_inline_y_1096 : JSCompiler_object_inline_x_1095) : xAxisScale, y:props.domain && props.domain.y ? _victoryCore.Scale.getBaseScale(props, "y").domain(props.domain.y).range(props.horizontal ? JSCompiler_object_inline_x_1095 : JSCompiler_object_inline_y_1096) : yAxisScale};
    (yAxisDomain = (yAxisDomain = (yAxisScale = axis$jscomp$0.x && axis$jscomp$0.y ? _victoryCore.Axis.getOrigin(axis$jscomp$0) : void 0) ? {x:_victoryCore.Axis.getOriginSign(yAxisScale.x, axis$jscomp$0.x), y:_victoryCore.Axis.getOriginSign(yAxisScale.y, axis$jscomp$0.y)} : void 0) ? {x:getDefaultOrientations("x", yAxisDomain.y, props.horizontal), y:getDefaultOrientations("y", yAxisDomain.x, props.horizontal)} : void 0) ? JSCompiler_object_inline_x_1095 = props.orientation || yAxisDomain[axis] : 
    props.orientation ? JSCompiler_object_inline_x_1095 = props.orientation : (JSCompiler_object_inline_x_1095 = props.horizontal ? "bottom" : "left", JSCompiler_object_inline_y_1096 = props.horizontal ? "left" : "bottom", JSCompiler_object_inline_x_1095 = props.dependentAxis ? JSCompiler_object_inline_x_1095 : JSCompiler_object_inline_y_1096);
    props = _victoryCore.Axis.isVertical(Object.assign({}, props, {orientation:JSCompiler_object_inline_x_1095}));
    JSCompiler_object_inline_y_1096 = {top:"end", left:"end", right:"start", bottom:"start"}[JSCompiler_object_inline_x_1095];
    return {anchors:{textAnchor:props ? JSCompiler_object_inline_y_1096 : "middle", verticalAnchor:props ? "middle" : JSCompiler_object_inline_y_1096}, axis, crossAxis:axisDomain, domain:axis$jscomp$0, isVertical:props, labelPadding:JSCompiler_inline_result, orientation:JSCompiler_object_inline_x_1095, orientations:yAxisDomain, origin:yAxisScale, padding, scale:xAxisScale, stringTicks:labelStyle, style:defaultStyles, tickFormat:scale, ticks:JSCompiler_inline_result$jscomp$0};
  };
  exports.getBaseProps = (initialProps, fallbackProps) => {
    initialProps = _victoryCore.Axis.modifyProps(initialProps, fallbackProps);
    var calculatedValues = getCalculatedValues(initialProps);
    const {axis, style:style$jscomp$0, orientation, isVertical, scale, ticks, tickFormat, anchors, domain, stringTicks} = calculatedValues;
    fallbackProps = "x" === axis ? "y" : "x";
    const {width, height, standalone, theme, polar, padding, horizontal} = initialProps, {globalTransform, gridOffset, gridEdge} = getLayoutProps(initialProps, calculatedValues), sharedProps = {scale:{[axis]:scale[axis]}, polar, horizontal, ticks, stringTicks}, axisProps = getAxisProps(initialProps, calculatedValues, globalTransform), axisLabelProps = getAxisLabelProps(initialProps, calculatedValues, globalTransform);
    calculatedValues = {parent:Object.assign({style:style$jscomp$0.parent, ticks, standalone, theme, width, height, padding, domain}, sharedProps)};
    const gridProps = {dimension:fallbackProps, range:{[fallbackProps]:_victoryCore.Helpers.getRange(initialProps, fallbackProps)}, scale:initialProps.scale && initialProps.scale[fallbackProps] ? {[fallbackProps]:initialProps.scale[fallbackProps]} : void 0};
    return ticks.reduce((childProps, tickValue, index) => {
      var tick = stringTicks ? stringTicks[index] : tickValue, text = tickFormat(tickValue, index, ticks);
      tick = Object.assign({}, sharedProps, {tick, tickValue, index, text});
      tick = {tickStyle:_victoryCore.Helpers.evaluateStyle(style$jscomp$0.ticks, tick), labelStyle:_victoryCore.Helpers.evaluateStyle(style$jscomp$0.tickLabels, tick), gridStyle:_victoryCore.Helpers.evaluateStyle(style$jscomp$0.grid, tick)};
      const {tickStyle, labelStyle} = tick;
      var JSCompiler_inline_result = tickStyle.size || 0;
      var tickSpacing = JSCompiler_inline_result + (tickStyle.padding || 0) + (labelStyle.padding || 0), sign = orientationSign[orientation];
      JSCompiler_inline_result = {x:isVertical ? sign * tickSpacing : 0, x2:isVertical ? sign * JSCompiler_inline_result : 0, y:isVertical ? 0 : sign * tickSpacing, y2:isVertical ? 0 : sign * JSCompiler_inline_result};
      tickSpacing = scale[axis]?.(tickValue);
      var tickLayout = {position:JSCompiler_inline_result, transform:{x:isVertical ? globalTransform.x : tickSpacing + globalTransform.x, y:isVertical ? tickSpacing + globalTransform.y : globalTransform.y}};
      JSCompiler_inline_result = {edge:gridEdge, transform:{x:isVertical ? -gridOffset.x + globalTransform.x : scale[axis]?.(tickValue) + globalTransform.x, y:isVertical ? scale[axis]?.(tickValue) + globalTransform.y : gridOffset.y + globalTransform.y}};
      tickSpacing = Object.assign({dimension:axis}, sharedProps, axisProps);
      sign = Object.assign({}, sharedProps, axisLabelProps);
      var JSCompiler_temp_const = Object, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.assign;
      const {position, transform} = tickLayout;
      JSCompiler_temp_const = JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, {}, sharedProps, {x1:transform.x, y1:transform.y, x2:transform.x + position.x2, y2:transform.y + position.y2, style:tick.tickStyle, datum:tickValue});
      JSCompiler_temp_const$jscomp$0 = Object;
      var JSCompiler_temp_const$jscomp$1 = JSCompiler_temp_const$jscomp$0.assign, style = tick.labelStyle;
      const {position:position$jscomp$0, transform:transform$jscomp$0} = tickLayout;
      text = JSCompiler_temp_const$jscomp$1.call(JSCompiler_temp_const$jscomp$0, {}, sharedProps, {style, x:transform$jscomp$0.x + position$jscomp$0.x, y:transform$jscomp$0.y + position$jscomp$0.y, verticalAnchor:anchors.verticalAnchor, textAnchor:anchors.textAnchor, angle:style.angle, text, datum:tickValue});
      tickLayout = Object;
      JSCompiler_temp_const$jscomp$0 = tickLayout.assign;
      const {edge, transform:transform$jscomp$1} = JSCompiler_inline_result;
      childProps[index] = {axis:tickSpacing, axisLabel:sign, ticks:JSCompiler_temp_const, tickLabels:text, grid:JSCompiler_temp_const$jscomp$0.call(tickLayout, {}, sharedProps, gridProps, {x1:transform$jscomp$1.x, y1:transform$jscomp$1.y, x2:edge.x + transform$jscomp$1.x, y2:edge.y + transform$jscomp$1.y, style:tick.gridStyle, datum:tickValue})};
      return childProps;
    }, calculatedValues);
  };
};

//# sourceMappingURL=module$node_modules$victory_axis$lib$helper_methods.js.map
