shadow$provide.module$node_modules$victory_core$lib$victory_util$domain = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function getDomainPadding(props, axis) {
    const formatPadding = padding => Array.isArray(padding) ? {left:padding[0], right:padding[1]} : {left:padding, right:padding};
    return (0,_isPlainObject2.default)(props.domainPadding) ? formatPadding(props.domainPadding[axis]) : formatPadding(props.domainPadding);
  }
  function getFlatData(dataset, axis) {
    const axisKey = `_${axis}`;
    return dataset.flat().map(datum => datum[axisKey] && void 0 !== datum[axisKey][1] ? datum[axisKey][1] : datum[axisKey]);
  }
  function getExtremeFromData(dataset, axis, type) {
    void 0 === type && (type = "min");
    const getExtreme = arr => "max" === type ? Math.max(...arr) : Math.min(...arr), initialValue = "max" === type ? -Infinity : Infinity;
    let containsDate = !1;
    dataset = dataset.flat().reduce((memo, datum) => {
      const current0 = void 0 !== datum[`_${axis}0`] ? datum[`_${axis}0`] : datum[`_${axis}`];
      datum = void 0 !== datum[`_${axis}1`] ? datum[`_${axis}1`] : datum[`_${axis}`];
      const current = getExtreme([current0, datum]);
      containsDate = containsDate || current0 instanceof Date || datum instanceof Date;
      return getExtreme([memo, current]);
    }, initialValue);
    return containsDate ? new Date(dataset) : dataset;
  }
  function padDomain(domain, props, axis) {
    if (!props.domainPadding) {
      return domain;
    }
    var minDomain = getMinFromProps(props, axis), maxDomain = getMaxFromProps(props, axis);
    const padding = getDomainPadding(props, axis);
    if (!padding.left && !padding.right) {
      return domain;
    }
    const min = Collection.getMinValue(domain), max = Collection.getMaxValue(domain);
    domain = Helpers.getCurrentAxis(axis, props.horizontal);
    domain = Helpers.getRange(props, domain);
    domain = Math.abs(domain[0] - domain[1]);
    var paddedDomainExtent = Math.abs(max.valueOf() - min.valueOf()) / Math.max(domain - padding.left - padding.right, 1) * domain, JSCompiler_object_inline_min_1071 = min.valueOf() - paddedDomainExtent * padding.left / domain;
    paddedDomainExtent = max.valueOf() + paddedDomainExtent * padding.right / domain;
    axis = (0,_isPlainObject2.default)(props.singleQuadrantDomainPadding) ? props.singleQuadrantDomainPadding[axis] : props.singleQuadrantDomainPadding;
    props = (val, type) => "min" === type && 0 <= min && 0 >= val || "max" === type && 0 >= max && 0 <= val ? 0 : val;
    (0 <= min && 0 >= JSCompiler_object_inline_min_1071 || 0 >= max && 0 <= paddedDomainExtent) && !1 !== axis && (JSCompiler_object_inline_min_1071 = Math.abs(max - min) * padding.right / domain, axis = props(min.valueOf() - Math.abs(max - min) * padding.left / domain, "min"), JSCompiler_object_inline_min_1071 = props(max.valueOf() + JSCompiler_object_inline_min_1071, "max"), paddedDomainExtent = Math.abs(JSCompiler_object_inline_min_1071 - axis) * padding.right / domain, JSCompiler_object_inline_min_1071 = 
    props(min.valueOf() - Math.abs(JSCompiler_object_inline_min_1071 - axis) * padding.left / domain, "min"), paddedDomainExtent = props(max.valueOf() + paddedDomainExtent, "max"));
    minDomain = void 0 !== minDomain ? minDomain : JSCompiler_object_inline_min_1071;
    maxDomain = void 0 !== maxDomain ? maxDomain : paddedDomainExtent;
    return min instanceof Date || max instanceof Date ? getDomainFromMinMax(new Date(minDomain), new Date(maxDomain)) : getDomainFromMinMax(minDomain, maxDomain);
  }
  function createDomainFunction(getDomainFromDataFunction, formatDomainFunction) {
    const getDomainFromDataFn = Helpers.isFunction(getDomainFromDataFunction) ? getDomainFromDataFunction : getDomainFromData, formatDomainFn = Helpers.isFunction(formatDomainFunction) ? formatDomainFunction : formatDomain;
    return (props, axis) => {
      var propsDomain = getDomainFromProps(props, axis);
      return propsDomain ? formatDomainFn(propsDomain, props, axis) : (propsDomain = (propsDomain = Data.getCategories(props, axis)) ? getDomainFromCategories(props, axis, propsDomain) : getDomainFromDataFn(props, axis)) ? formatDomainFn(propsDomain, props, axis) : void 0;
    };
  }
  function formatDomain(domain, props, axis) {
    domain = padDomain(domain, props, axis);
    "log" !== Scale.getScaleType(props, axis) ? props = domain : (props = 0 > domain[0] || 0 > domain[1] ? -1 / Number.MAX_SAFE_INTEGER : 1 / Number.MAX_SAFE_INTEGER, props = [0 === domain[0] ? props : domain[0], 0 === domain[1] ? props : domain[1]]);
    return props;
  }
  function getDomainFromCategories(props, axis, categories) {
    const categoriesArray = categories || Data.getCategories(props, axis), {polar, startAngle = 0, endAngle = 360} = props;
    if (categoriesArray) {
      var minDomain = getMinFromProps(props, axis);
      categories = getMaxFromProps(props, axis);
      props = Collection.containsStrings(categoriesArray) ? Data.getStringsFromCategories(props, axis) : [];
      var stringMap = 0 === props.length ? null : props.reduce((memo, string, index) => {
        memo[string] = index + 1;
        return memo;
      }, {});
      props = stringMap ? categoriesArray.map(value => stringMap[value]) : categoriesArray;
      minDomain = void 0 !== minDomain ? minDomain : Collection.getMinValue(props);
      categories = void 0 !== categories ? categories : Collection.getMaxValue(props);
      categories = getDomainFromMinMax(minDomain, categories);
      return polar && "x" === axis && 360 === Math.abs(startAngle - endAngle) ? getSymmetricDomain(categories, props) : categories;
    }
  }
  function getDomainFromData(props, axis, dataset) {
    dataset = dataset || Data.getData(props);
    const {polar, startAngle = 0, endAngle = 360} = props;
    var minDomain = getMinFromProps(props, axis);
    props = getMaxFromProps(props, axis);
    if (1 > dataset.length) {
      return void 0 !== minDomain && void 0 !== props ? getDomainFromMinMax(minDomain, props) : void 0;
    }
    minDomain = void 0 !== minDomain ? minDomain : getExtremeFromData(dataset, axis, "min");
    props = void 0 !== props ? props : getExtremeFromData(dataset, axis, "max");
    props = getDomainFromMinMax(minDomain, props);
    return polar && "x" === axis && 360 === Math.abs(startAngle - endAngle) ? getSymmetricDomain(props, getFlatData(dataset, axis)) : props;
  }
  function getDomainFromMinMax(min, max) {
    if (Number(min) === Number(max)) {
      var verySmallNumber = 0 === max ? 2 * Math.pow(10, -10) : Math.pow(10, -10);
      min = max instanceof Date ? new Date(Number(max) - 1) : Number(max) - verySmallNumber;
      verySmallNumber = max instanceof Date ? new Date(Number(max) + 1) : Number(max) + verySmallNumber;
      max = 0 === max ? [0, verySmallNumber] : [min, verySmallNumber];
    } else {
      max = [min, max];
    }
    return max;
  }
  function getDomainFromProps(props, axis) {
    const minDomain = getMinFromProps(props, axis), maxDomain = getMaxFromProps(props, axis);
    if ((0,_isPlainObject2.default)(props.domain) && props.domain[axis]) {
      return props.domain[axis];
    }
    if (Array.isArray(props.domain)) {
      return props.domain;
    }
    if (void 0 !== minDomain && void 0 !== maxDomain) {
      return getDomainFromMinMax(minDomain, maxDomain);
    }
  }
  function getMaxFromProps(props, axis) {
    return (0,_isPlainObject2.default)(props.maxDomain) && void 0 !== props.maxDomain[axis] ? props.maxDomain[axis] : "number" === typeof props.maxDomain || (0,_isDate2.default)(props.maxDomain) ? props.maxDomain : void 0;
  }
  function getMinFromProps(props, axis) {
    return (0,_isPlainObject2.default)(props.minDomain) && void 0 !== props.minDomain[axis] ? props.minDomain[axis] : "number" === typeof props.minDomain || (0,_isDate2.default)(props.minDomain) ? props.minDomain : void 0;
  }
  function getSymmetricDomain(domain, values) {
    values = (0,_sortedUniq2.default)(values.sort((a, b) => a - b));
    return [domain[0], domain[1] + (values[1] - values[0])];
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.createDomainFunction = createDomainFunction;
  exports.formatDomain = formatDomain;
  exports.getDomain = function(props, axis) {
    return createDomainFunction()(props, axis);
  };
  exports.getDomainFromCategories = getDomainFromCategories;
  exports.getDomainFromData = getDomainFromData;
  exports.getDomainFromMinMax = getDomainFromMinMax;
  exports.getDomainFromProps = getDomainFromProps;
  exports.getDomainWithZero = function(props, axis) {
    const propsDomain = getDomainFromProps(props, axis);
    if (propsDomain) {
      return propsDomain;
    }
    const dataset = Data.getData(props), y0Min = dataset.reduce((min, datum) => datum._y0 < min ? datum._y0 : min, Infinity);
    return createDomainFunction(() => getDomainFromData(props, axis, dataset), domain => {
      if ("x" !== axis) {
        var defaultMin = Infinity !== y0Min ? y0Min : 0, maxDomainProp = getMaxFromProps(props, axis), minDomainProp = getMinFromProps(props, axis);
        maxDomainProp = void 0 !== maxDomainProp ? maxDomainProp : Collection.getMaxValue(domain, defaultMin);
        domain = void 0 !== minDomainProp ? minDomainProp : Collection.getMinValue(domain, defaultMin);
        domain = getDomainFromMinMax(domain, maxDomainProp);
      }
      return formatDomain(domain, props, axis);
    })(props, axis);
  };
  exports.getMaxFromProps = getMaxFromProps;
  exports.getMinFromProps = getMinFromProps;
  exports.getSymmetricDomain = getSymmetricDomain;
  exports.isDomainComponent = function(component) {
    let role = component && component.type ? component.type.role : "";
    "portal" === role && (component = _react.default.Children.toArray(component.props.children), component = component.length ? (component = component[0]) && component.type ? component.type.role : "" : "", role = component);
    return "area axis bar boxplot candlestick errorbar group histogram line pie scatter stack voronoi".split(" ").includes(role);
  };
  var _isDate2 = _interopRequireDefault(require("module$node_modules$lodash$isDate")), _sortedUniq2 = _interopRequireDefault(require("module$node_modules$lodash$sortedUniq")), _isPlainObject2 = _interopRequireDefault(require("module$node_modules$lodash$isPlainObject")), _react = _interopRequireDefault(require("module$node_modules$react$index")), Data = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$data")), Scale = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$scale")), 
  Helpers = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$helpers")), Collection = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$collection"));
};

//# sourceMappingURL=module$node_modules$victory_core$lib$victory_util$domain.js.map
