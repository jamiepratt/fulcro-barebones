shadow$provide.module$node_modules$victory_core$lib$victory_util$helpers = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function omit(originalObject, ks) {
    void 0 === ks && (ks = []);
    const newObject = {};
    for (const key in originalObject) {
      0 <= ks.indexOf(key) || Object.prototype.hasOwnProperty.call(originalObject, key) && (newObject[key] = originalObject[key]);
    }
    return newObject;
  }
  function getPoint(datum) {
    const {_x, _x1, _x0, _voronoiX, _y, _y1, _y0, _voronoiY} = datum;
    return (0,_defaults2.default)({}, {x:void 0 !== _voronoiX ? _voronoiX : void 0 !== _x1 ? _x1 : _x, x0:void 0 !== _x0 ? _x0 : _x, y:void 0 !== _voronoiY ? _voronoiY : void 0 !== _y1 ? _y1 : _y, y0:void 0 !== _y0 ? _y0 : _y}, datum);
  }
  function getPadding(props, name) {
    void 0 === name && (name = "padding");
    name = props[name];
    props = "number" === typeof name ? name : 0;
    name = "object" === typeof name ? name : {};
    return {top:name.top || props, bottom:name.bottom || props, left:name.left || props, right:name.right || props};
  }
  function isTooltip(component) {
    return "tooltip" === (component && component.type && component.type.role);
  }
  function evaluateProp(prop, props) {
    return isFunction(prop) ? prop(props) : prop;
  }
  function degreesToRadians(degrees) {
    return "number" === typeof degrees ? Math.PI / 180 * degrees : degrees;
  }
  function getRadius(props) {
    const {left, right, top, bottom} = getPadding(props), {width, height} = props;
    return Math.min(width - left - right, height - top - bottom) / 2;
  }
  function isFunction(value) {
    return "function" === typeof value;
  }
  function isHorizontal(props) {
    if (void 0 !== props.horizontal || !props.children) {
      return props.horizontal;
    }
    const traverseChildren = childArray => childArray.reduce((memo, child) => {
      child = child.props || {};
      return memo || child.horizontal || !child.children ? memo || child.horizontal : traverseChildren(_react.default.Children.toArray(child.children));
    }, !1);
    return traverseChildren(_react.default.Children.toArray(props.children));
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.createAccessor = function(key) {
    return isFunction(key) ? key : null === key || void 0 === key ? x => x : (0,_property2.default)(key);
  };
  exports.degreesToRadians = degreesToRadians;
  exports.evaluateProp = evaluateProp;
  exports.evaluateStyle = function(style, props) {
    return props.disableInlineStyles ? {} : style && Object.keys(style).some(value => isFunction(style[value])) ? Object.keys(style).reduce((prev, curr) => {
      prev[curr] = evaluateProp(style[curr], props);
      return prev;
    }, {}) : style;
  };
  exports.getCurrentAxis = function(axis, horizontal) {
    return horizontal ? "x" === axis ? "y" : "x" : axis;
  };
  exports.getDefaultStyles = function(props, role) {
    const {theme = {}, labelComponent} = props;
    props = theme[role] && theme[role].style || {};
    if (!isTooltip(labelComponent)) {
      return props;
    }
    role = (0,_defaults2.default)({}, theme.tooltip && theme.tooltip.style || {}, props.labels);
    return (0,_defaults2.default)({}, {labels:role}, props);
  };
  exports.getPadding = getPadding;
  exports.getPoint = getPoint;
  exports.getPolarOrigin = function(props) {
    const {width, height} = props, {top, bottom, left, right} = getPadding(props);
    props = Math.min(width - left - right, height - top - bottom) / 2;
    const offsetWidth = width / 2 + left - right, offsetHeight = height / 2 + top - bottom;
    return {x:offsetWidth + props > width ? props + left - right : offsetWidth, y:offsetHeight + props > height ? props + top - bottom : offsetHeight};
  };
  exports.getRadius = getRadius;
  exports.getRange = function(props, axis) {
    if (props.range && props.range[axis]) {
      return props.range[axis];
    }
    if (props.range && Array.isArray(props.range)) {
      return props.range;
    }
    if (props.polar) {
      "x" === axis ? (axis = degreesToRadians(props.startAngle || 0), props = degreesToRadians(props.endAngle || 360), props = [axis, props]) : props = [props.innerRadius || 0, getRadius(props)];
    } else {
      {
        axis = "x" !== axis;
        const padding = getPadding(props);
        props = axis ? [props.height - padding.bottom, padding.top] : [padding.left, props.width - padding.right];
      }
    }
    return props;
  };
  exports.getStyles = function(style, defaultStyles) {
    if (!style) {
      return (0,_defaults2.default)({parent:{height:"100%", width:"100%"}}, defaultStyles);
    }
    const {data, labels, parent} = style;
    style = defaultStyles && defaultStyles.labels || {};
    const defaultData = defaultStyles && defaultStyles.data || {};
    return {parent:(0,_defaults2.default)({}, parent, defaultStyles && defaultStyles.parent || {}, {width:"100%", height:"100%"}), labels:(0,_defaults2.default)({}, labels, style), data:(0,_defaults2.default)({}, data, defaultData)};
  };
  exports.invert = function(original) {
    return Object.entries(original).reduce((acc, current) => {
      acc[current[1]] = current[0];
      return acc;
    }, {});
  };
  exports.isFunction = isFunction;
  exports.isHorizontal = isHorizontal;
  exports.isNil = function(value) {
    return null == value;
  };
  exports.isTooltip = isTooltip;
  exports.mapValues = function(values, fn) {
    if (values) {
      return Object.keys(values).reduce((acc, key) => {
        acc[key] = fn(values[key]);
        return acc;
      }, {});
    }
  };
  exports.modifyProps = function(props, fallbackProps, role) {
    role = omit(props.theme && props.theme[role] ? props.theme[role] : {}, ["style"]);
    const horizontal = isHorizontal(props);
    return (0,_defaults2.default)(void 0 === horizontal ? {} : {horizontal}, props, role, fallbackProps);
  };
  exports.omit = omit;
  exports.radiansToDegrees = function(radians) {
    return "number" === typeof radians ? radians / (Math.PI / 180) : radians;
  };
  exports.range = function(start, end, increment) {
    const startIndex = end ? start : 0;
    (start = end ? end : start) || (start = 0);
    start -= startIndex;
    end = Math.abs(start);
    const sign = start / end || 1, inc = increment || 1;
    return Array.from(Array(Math.max(Math.ceil(end / inc), 0)), (_, i) => startIndex + i * sign * inc);
  };
  exports.reduceChildren = function(children, iteratee, parentProps, initialMemo, combine) {
    void 0 === parentProps && (parentProps = {});
    void 0 === initialMemo && (initialMemo = []);
    void 0 === combine && (combine = (memo, item) => memo.concat(item));
    const sharedProps = "data domain categories polar startAngle endAngle minDomain maxDomain horizontal".split(" "), traverseChildren = (childArray, names, parent) => childArray.reduce((memo, child, index) => {
      var childRole = child.type && child.type.role;
      const childName = child.props.name || `${childRole}-${names[index]}`;
      if (child.props && child.props.children) {
        const childProps = Object.assign({}, child.props, (0,_pick2.default)(parentProps, sharedProps));
        index = child.type && "stack" === child.type.role && isFunction(child.type.getChildren) ? child.type.getChildren(childProps) : _react.default.Children.toArray(child.props.children).map(c => {
          const nestedChildProps = Object.assign({}, c.props, (0,_pick2.default)(childProps, sharedProps));
          return _react.default.cloneElement(c, nestedChildProps);
        });
        childRole = index.map((c, i) => `${childName}-${i}`);
        child = traverseChildren(index, childRole, child);
        memo = combine(memo, child);
      } else {
        (child = iteratee(child, childName, parent)) && (memo = combine(memo, child));
      }
      return memo;
    }, initialMemo);
    children = children.filter(_react.isValidElement);
    const childNames = children.map((c, i) => i);
    return traverseChildren(children, childNames);
  };
  exports.scalePoint = function(props, datum) {
    const {scale, polar, horizontal} = props;
    datum = getPoint(datum);
    props = props.origin || {x:0, y:0};
    const x = horizontal ? scale.y(datum.y) : scale.x(datum.x), x0 = horizontal ? scale.y(datum.y0) : scale.x(datum.x0), y = horizontal ? scale.x(datum.x) : scale.y(datum.y);
    datum = horizontal ? scale.x(datum.x0) : scale.y(datum.y0);
    return {x:polar ? y * Math.cos(x) + props.x : x, x0:polar ? datum * Math.cos(x0) + props.x : x0, y:polar ? -y * Math.sin(x) + props.y : y, y0:polar ? -datum * Math.sin(x0) + props.x : datum};
  };
  var _pick2 = _interopRequireDefault(require("module$node_modules$lodash$pick")), _property2 = _interopRequireDefault(require("module$node_modules$lodash$property")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _react = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$react$index"));
};

//# sourceMappingURL=module$node_modules$victory_core$lib$victory_util$helpers.js.map
