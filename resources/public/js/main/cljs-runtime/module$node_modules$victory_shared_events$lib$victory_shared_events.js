shadow$provide.module$node_modules$victory_shared_events$lib$victory_shared_events = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.VictorySharedEvents = void 0;
  var _fromPairs2 = _interopRequireDefault(require("module$node_modules$lodash$fromPairs")), _isEmpty2 = _interopRequireDefault(require("module$node_modules$lodash$isEmpty")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _react = _interopRequireDefault(require("module$node_modules$react$index")), _victoryCore = require("module$node_modules$victory_core$lib$index"), _reactFastCompare = _interopRequireDefault(require("module$node_modules$react_fast_compare$index")), 
  _jsonStringifySafe = _interopRequireDefault(require("module$node_modules$json_stringify_safe$stringify"));
  class VictorySharedEvents extends _react.default.Component {
    static $jscomp$static$init$1127287753$0$displayName() {
      return "VictorySharedEvents";
    }
    static $jscomp$static$init$1127287753$1$role() {
      return "shared-event-wrapper";
    }
    static $jscomp$static$init$1127287753$2$contextType() {
      return _victoryCore.TimerContext;
    }
    static $jscomp$static$init$1127287753$3$defaultProps() {
      return {groupComponent:_react.default.createElement("g", null)};
    }
    constructor(props) {
      super(props);
      this.getScopedEvents = _victoryCore.Events.getScopedEvents.bind(this);
      this.getEventState = _victoryCore.Events.getEventState.bind(this);
      this.state = this.state || {};
      this.sharedEventsCache = {};
      this.globalEvents = {};
      this.prevGlobalEventKeys = [];
      this.boundGlobalEvents = {};
      this.baseProps = this.getBaseProps(props);
    }
    shouldComponentUpdate(nextProps) {
      if (!(0,_reactFastCompare.default)(this.props, nextProps)) {
        this.baseProps = this.getBaseProps(nextProps);
        const externalMutations = this.getExternalMutations(nextProps, this.baseProps);
        this.applyExternalMutations(nextProps, externalMutations);
      }
      return !0;
    }
    componentDidMount() {
      const globalEventKeys = Object.keys(this.globalEvents);
      globalEventKeys.forEach(key => this.addGlobalListener(key));
      this.prevGlobalEventKeys = globalEventKeys;
    }
    componentDidUpdate() {
      const globalEventKeys = Object.keys(this.globalEvents);
      _victoryCore.Collection.difference(this.prevGlobalEventKeys, globalEventKeys).forEach(key => this.removeGlobalListener(key));
      _victoryCore.Collection.difference(globalEventKeys, this.prevGlobalEventKeys).forEach(key => this.addGlobalListener(key));
      this.prevGlobalEventKeys = globalEventKeys;
    }
    componentWillUnmount() {
      this.prevGlobalEventKeys.forEach(key => this.removeGlobalListener(key));
    }
    addGlobalListener(key) {
      const boundListener = event => {
        const listener = this.globalEvents[key];
        return listener && listener(_victoryCore.Events.emulateReactEvent(event));
      };
      this.boundGlobalEvents[key] = boundListener;
      window.addEventListener(_victoryCore.Events.getGlobalEventNameFromKey(key), boundListener);
    }
    removeGlobalListener(key) {
      window.removeEventListener(_victoryCore.Events.getGlobalEventNameFromKey(key), this.boundGlobalEvents[key]);
    }
    getAllEvents(props) {
      const componentEvents = _victoryCore.Events.getComponentEvents(props, ["container", "groupComponent"]);
      return Array.isArray(componentEvents) ? Array.isArray(props.events) ? componentEvents.concat(...props.events) : componentEvents : props.events;
    }
    applyExternalMutations(props, externalMutations) {
      if (!(0,_isEmpty2.default)(externalMutations)) {
        const callbacks = props.externalEventMutations.reduce((memo, mutation) => _victoryCore.Helpers.isFunction(mutation.callback) ? memo.concat(mutation.callback) : memo, []);
        this.setState(externalMutations, callbacks.length ? () => {
          callbacks.forEach(c => c());
        } : void 0);
      }
    }
    getExternalMutations(props, baseProps) {
      return (0,_isEmpty2.default)(props.externalEventMutations) ? void 0 : _victoryCore.Events.getExternalMutationsWithChildren(props.externalEventMutations, baseProps, this.state, Object.keys(baseProps));
    }
    cacheSharedEvents(name, sharedEvents, cacheValues) {
      this.sharedEventsCache[name] = [sharedEvents, cacheValues];
    }
    getCachedSharedEvents(name, cacheValues) {
      const [sharedEvents, prevCacheValues] = this.sharedEventsCache[name] || [];
      if (sharedEvents && (0,_reactFastCompare.default)(cacheValues, prevCacheValues)) {
        return sharedEvents;
      }
    }
    getBaseProps(props) {
      ({container:props} = props);
      var children = _react.default.Children.toArray(this.props.children);
      children = this.getBasePropsFromChildren(children);
      return Object.assign({}, children, {parent:props ? props.props : {}});
    }
    getBasePropsFromChildren(childComponents) {
      childComponents = _victoryCore.Helpers.reduceChildren(childComponents, (child, childName) => child.type && _victoryCore.Helpers.isFunction(child.type.getBaseProps) ? (child = child.props && child.type.getBaseProps(child.props)) ? [[childName, child]] : null : null);
      return (0,_fromPairs2.default)(childComponents);
    }
    getNewChildren(props, baseProps) {
      const {events, eventKey} = props, alterChildren = (children, childNames) => children.reduce((memo, child, index) => {
        if (child.props.children) {
          var newChildren = _react.default.Children.toArray(child.props.children);
          index = childNames.slice(index, index + newChildren.length);
          child = _react.default.cloneElement(child, child.props, alterChildren(newChildren, index));
          return memo.concat(child);
        }
        if ("parent" !== childNames[index] && child.type && _victoryCore.Helpers.isFunction(child.type.getBaseProps)) {
          const name = child.props.name || childNames[index];
          index = Array.isArray(events) && events.filter(event => "parent" === event.target ? !1 : Array.isArray(event.childName) ? -1 < event.childName.indexOf(name) : event.childName === name || "all" === event.childName);
          newChildren = [name, baseProps, index, (0,_jsonStringifySafe.default)(this.state[name])];
          index = this.getCachedSharedEvents(name, newChildren) || {events:index, getEvents:(evts, target) => this.getScopedEvents(evts, target, name, baseProps), getEventState:(key, target) => this.getEventState(key, target, name)};
          this.cacheSharedEvents(name, index, newChildren);
          return memo.concat(_react.default.cloneElement(child, Object.assign({key:`events-${name}`, sharedEvents:index, eventKey, name}, child.props)));
        }
        return memo.concat(child);
      }, []), childNames = Object.keys(baseProps);
      props = _react.default.Children.toArray(props.children);
      return alterChildren(props, childNames);
    }
    getContainer(props, baseProps, events) {
      const children = this.getNewChildren(props, baseProps);
      events = Array.isArray(events) ? events.filter(event => "parent" === event.target) : [];
      var sharedEvents = 0 < events.length ? {events, getEvents:(evts, target) => this.getScopedEvents(evts, target, null, baseProps), getEventState:this.getEventState} : null;
      props = props.container || props.groupComponent;
      events = props.type && props.type.role;
      var containerProps = props.props || {}, boundGetEvents = _victoryCore.Events.getEvents.bind(this);
      boundGetEvents = sharedEvents && boundGetEvents({sharedEvents}, "parent");
      sharedEvents = (0,_defaults2.default)({}, this.getEventState("parent", "parent"), containerProps, baseProps.parent, {children});
      containerProps = (0,_defaults2.default)({}, _victoryCore.Events.getPartialEvents(boundGetEvents, "parent", sharedEvents), containerProps.events);
      this.globalEvents = _victoryCore.Events.getGlobalEvents(containerProps);
      containerProps = _victoryCore.Events.omitGlobalEvents(containerProps);
      return "container" === events ? _react.default.cloneElement(props, Object.assign({}, sharedEvents, {events:containerProps})) : _react.default.cloneElement(props, containerProps, children);
    }
    render() {
      const events = this.getAllEvents(this.props);
      return events ? this.getContainer(this.props, this.baseProps, events) : _react.default.cloneElement(this.props.container, {children:this.props.children});
    }
  }
  VictorySharedEvents.displayName = VictorySharedEvents.$jscomp$static$init$1127287753$0$displayName();
  VictorySharedEvents.role = VictorySharedEvents.$jscomp$static$init$1127287753$1$role();
  VictorySharedEvents.contextType = VictorySharedEvents.$jscomp$static$init$1127287753$2$contextType();
  VictorySharedEvents.defaultProps = VictorySharedEvents.$jscomp$static$init$1127287753$3$defaultProps();
  exports.VictorySharedEvents = VictorySharedEvents;
};

//# sourceMappingURL=module$node_modules$victory_shared_events$lib$victory_shared_events.js.map
