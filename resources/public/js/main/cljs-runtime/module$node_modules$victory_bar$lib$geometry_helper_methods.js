shadow$provide.module$node_modules$victory_bar$lib$geometry_helper_methods = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.point = exports.circle = void 0;
  const point = (x, y) => ({x, y, distance(p1) {
    return Math.sqrt(Math.pow(this.x - p1.x, 2) + Math.pow(this.y - p1.y, 2));
  }, add(p1) {
    return point(this.x + p1.x, this.y + p1.y);
  }, subtract(p1) {
    return point(this.x - p1.x, this.y - p1.y);
  }, scalarMult(n) {
    return point(this.x * n, this.y * n);
  }, scalarDivide(n) {
    if (0 === n) {
      throw Error("Division by 0 error");
    }
    return point(this.x / n, this.y / n);
  }, equals(p1) {
    return this.x === p1.x && this.y === p1.y;
  }});
  exports.point = point;
  exports.circle = (center, radius) => ({center, radius, hasIntersection(circle1) {
    const r0 = this.radius, r1 = circle1.radius;
    circle1 = this.center.distance(circle1.center);
    return circle1 > r0 + r1 || circle1 < Math.abs(r0 - r1) ? !1 : !0;
  }, equals(circle1) {
    const P0 = this.center, P1 = circle1.center;
    return this.radius === circle1.radius && P0.equals(P1);
  }, intersection(circle1) {
    var P0 = this.center;
    const P1 = circle1.center;
    var r0 = this.radius;
    const r1 = circle1.radius, d = P0.distance(P1);
    if (!this.hasIntersection(circle1) || this.equals(circle1)) {
      return [];
    }
    circle1 = (Math.pow(r0, 2) - Math.pow(r1, 2) + Math.pow(d, 2)) / (2 * d);
    r0 = Math.sqrt(Math.pow(r0, 2) - Math.pow(circle1, 2));
    circle1 = P0.add(P1.subtract(P0).scalarMult(circle1).scalarDivide(d));
    const {x:x0, y:y0} = P0, {x:x1, y:y1} = P1, {x:x2, y:y2} = circle1;
    P0 = [point(x2 - r0 * (y1 - y0) / d, y2 + r0 * (x1 - x0) / d), point(x2 + r0 * (y1 - y0) / d, y2 - r0 * (x1 - x0) / d)];
    P0.sort((Point1, Point2) => Point1.x - Point2.x);
    return P0;
  }, solveX(y) {
    y = Math.sqrt(Math.pow(this.radius, 2) - Math.pow(y - this.center.y, 2));
    return [this.center.x - y, this.center.x + y];
  }, solveY(x) {
    x = Math.sqrt(Math.pow(this.radius, 2) - Math.pow(x - this.center.x, 2));
    return [this.center.y - x, this.center.y + x];
  }});
};

//# sourceMappingURL=module$node_modules$victory_bar$lib$geometry_helper_methods.js.map
