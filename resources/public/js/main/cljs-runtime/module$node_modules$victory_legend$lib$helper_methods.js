shadow$provide.module$node_modules$victory_legend$lib$helper_methods = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function sum(array) {
    if (array && array.length) {
      let value = 0;
      for (let i = 0; i < array.length; i++) {
        value += array[i];
      }
      return value;
    }
    return 0;
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getDimensions = exports.getBaseProps = void 0;
  var _range2 = _interopRequireDefault(require("module$node_modules$lodash$range")), _groupBy2 = _interopRequireDefault(require("module$node_modules$lodash$groupBy")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _victoryCore = require("module$node_modules$victory_core$lib$index");
  const getLabelStyles = props => {
    const {data, style} = props;
    return data.map((datum, index) => {
      const baseLabelStyles = (0,_defaults2.default)({}, datum.labels, style.labels);
      return _victoryCore.Helpers.evaluateStyle(baseLabelStyles, {datum, index, data});
    });
  }, getCalculatedValues = props => {
    const {orientation, theme} = props;
    var JSCompiler_inline_result = theme && theme.legend && theme.legend.style ? theme.legend.style : {};
    void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = {});
    var style = props.style || {};
    JSCompiler_inline_result = {parent:(0,_defaults2.default)(style.parent, JSCompiler_inline_result.parent, {height:"100%", width:"100%"}), data:(0,_defaults2.default)({}, style.data, JSCompiler_inline_result.data), labels:(0,_defaults2.default)({}, style.labels, JSCompiler_inline_result.labels), border:(0,_defaults2.default)({}, style.border, JSCompiler_inline_result.border), title:(0,_defaults2.default)({}, style.title, JSCompiler_inline_result.title)};
    ({colorScale:style} = props);
    style = "string" === typeof style ? _victoryCore.Style.getColorScale(style) : style || [];
    const isHorizontal = "horizontal" === orientation, borderPadding = _victoryCore.Helpers.getPadding({padding:props.borderPadding});
    return Object.assign({}, props, {style:JSCompiler_inline_result, isHorizontal, colorScale:style, borderPadding});
  }, groupData = props => {
    const {data} = props, style = props.style && props.style.data || {}, labelStyles = getLabelStyles(props);
    return data.map((datum, index) => {
      var symbol = datum.symbol || {};
      const {fontSize} = labelStyles[index];
      symbol = symbol.size || style.size || fontSize / 2.5;
      const symbolSpacer = props.symbolSpacer || Math.max(symbol, fontSize);
      var JSCompiler_temp_const = _victoryCore.TextSize.approximateTextSize(datum.name, labelStyles[index]);
      {
        const {itemsPerRow, isHorizontal} = props;
        var JSCompiler_inline_result = itemsPerRow ? isHorizontal ? index % itemsPerRow : Math.floor(index / itemsPerRow) : isHorizontal ? index : 0;
      }
      {
        const {itemsPerRow, isHorizontal} = props;
        index = itemsPerRow ? isHorizontal ? Math.floor(index / itemsPerRow) : index % itemsPerRow : isHorizontal ? 0 : index;
      }
      return {...datum, size:symbol, symbolSpacer, fontSize, textSize:JSCompiler_temp_const, column:JSCompiler_inline_result, row:index};
    });
  }, getColumnWidths = (props, data) => {
    props = props.gutter || {};
    const gutterWidth = "object" === typeof props ? (props.left || 0) + (props.right || 0) : props || 0, dataByColumn = (0,_groupBy2.default)(data, "column");
    return Object.keys(dataByColumn).reduce((memo, curr, index) => {
      curr = dataByColumn[curr].map(d => d.textSize.width + d.size + d.symbolSpacer + gutterWidth);
      memo[index] = Math.max(...curr);
      return memo;
    }, []);
  }, getRowHeights = (props, data) => {
    props = props.rowGutter || {};
    const gutterHeight = "object" === typeof props ? (props.top || 0) + (props.bottom || 0) : props || 0, dataByRow = (0,_groupBy2.default)(data, "row");
    return Object.keys(dataByRow).reduce((memo, curr, index) => {
      curr = dataByRow[curr].map(d => d.textSize.height + d.symbolSpacer + gutterHeight);
      memo[index] = Math.max(...curr);
      return memo;
    }, []);
  }, getTitleDimensions = props => {
    var style = props.style && props.style.title || {};
    props = _victoryCore.TextSize.approximateTextSize(props.title, style);
    style = style.padding || 0;
    return {height:props.height + 2 * style || 0, width:props.width + 2 * style || 0};
  }, getOffset = (datum, rowHeights, columnWidths) => {
    const {column, row} = datum;
    return {x:(0,_range2.default)(column).reduce((memo, curr) => memo + columnWidths[curr], 0), y:(0,_range2.default)(row).reduce((memo, curr) => memo + rowHeights[curr], 0)};
  }, getAnchors = (titleOrientation, centerTitle) => {
    const standardAnchors = {textAnchor:"right" === titleOrientation ? "end" : "start", verticalAnchor:"bottom" === titleOrientation ? "end" : "start"};
    return centerTitle ? (titleOrientation = "top" === titleOrientation || "bottom" === titleOrientation, {textAnchor:titleOrientation ? "middle" : standardAnchors.textAnchor, verticalAnchor:titleOrientation ? standardAnchors.verticalAnchor : "middle"}) : standardAnchors;
  }, getTitleStyle = props => {
    const {titleOrientation, centerTitle, titleComponent} = props, baseStyle = props.style && props.style.title || {};
    props = titleComponent.props && titleComponent.props.style || {};
    const anchors = getAnchors(titleOrientation, centerTitle);
    return Array.isArray(props) ? props.map(obj => (0,_defaults2.default)({}, obj, baseStyle, anchors)) : (0,_defaults2.default)({}, props, baseStyle, anchors);
  }, getTitleProps = (props, borderProps) => {
    const {title, titleOrientation, centerTitle, borderPadding} = props, {height, width} = borderProps;
    borderProps = getTitleStyle(props);
    var padding = Array.isArray(borderProps) ? borderProps[0].padding : borderProps.padding;
    const horizontal = "top" === titleOrientation || "bottom" === titleOrientation;
    var JSCompiler_object_inline_x_1140 = centerTitle ? width / 2 : borderPadding["bottom" === titleOrientation ? "bottom" : "top"] + (padding || 0), JSCompiler_object_inline_y_1141 = centerTitle ? height / 2 : borderPadding["right" === titleOrientation ? "right" : "left"] + (padding || 0);
    JSCompiler_object_inline_x_1140 = horizontal ? JSCompiler_object_inline_x_1140 : borderPadding[titleOrientation] + (padding || 0);
    padding = horizontal ? borderPadding[titleOrientation] + (padding || 0) : JSCompiler_object_inline_y_1141;
    return {x:"right" === titleOrientation ? props.x + width - JSCompiler_object_inline_x_1140 : props.x + JSCompiler_object_inline_x_1140, y:"bottom" === titleOrientation ? props.y + height - padding : props.y + padding, style:borderProps, text:title};
  }, getBorderProps = (props, contentHeight, contentWidth) => {
    const {x, y, borderPadding, style} = props;
    return {x, y, height:(contentHeight || 0) + borderPadding.top + borderPadding.bottom, width:(contentWidth || 0) + borderPadding.left + borderPadding.right, style:Object.assign({fill:"none"}, style.border)};
  }, getDimensions = (initialProps, fallbackProps) => {
    initialProps = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "legend");
    fallbackProps = Object.assign({}, initialProps, getCalculatedValues(initialProps));
    const {title, titleOrientation} = fallbackProps;
    var groupedData = groupData(fallbackProps);
    initialProps = getColumnWidths(fallbackProps, groupedData);
    groupedData = getRowHeights(fallbackProps, groupedData);
    fallbackProps = title ? getTitleDimensions(fallbackProps) : {height:0, width:0};
    return {height:"left" === titleOrientation || "right" === titleOrientation ? Math.max(sum(groupedData), fallbackProps.height) : sum(groupedData) + fallbackProps.height, width:"left" === titleOrientation || "right" === titleOrientation ? sum(initialProps) + fallbackProps.width : Math.max(sum(initialProps), fallbackProps.width)};
  };
  exports.getDimensions = getDimensions;
  exports.getBaseProps = (initialProps, fallbackProps) => {
    initialProps = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "legend");
    initialProps = Object.assign({}, initialProps, getCalculatedValues(initialProps));
    const {data, standalone, theme, padding, style, colorScale, gutter, rowGutter, borderPadding, title, titleOrientation, name, x = 0, y = 0} = initialProps, groupedData = groupData(initialProps), columnWidths = getColumnWidths(initialProps, groupedData), rowHeights = getRowHeights(initialProps, groupedData), labelStyles = getLabelStyles(initialProps);
    var titleDimensions = title ? getTitleDimensions(initialProps) : {height:0, width:0}, JSCompiler_object_inline_x_1142 = "left" === titleOrientation ? titleDimensions.width : 0, JSCompiler_object_inline_y_1143 = "top" === titleOrientation ? titleDimensions.height : 0, JSCompiler_object_inline_x_1144 = gutter && "object" === typeof gutter ? gutter.left || 0 : 0, JSCompiler_object_inline_y_1145 = rowGutter && "object" === typeof rowGutter ? rowGutter.top || 0 : 0;
    const {height, width} = getDimensions(initialProps, fallbackProps);
    fallbackProps = getBorderProps(initialProps, height, width);
    titleDimensions = getTitleProps(initialProps, fallbackProps);
    return groupedData.reduce((childProps, datum, i) => {
      var dataStyle = (0,_defaults2.default)({}, datum.symbol, style.data, {fill:colorScale[i % colorScale.length]});
      const eventKey = _victoryCore.Helpers.isNil(datum.eventKey) ? i : datum.eventKey, offset = getOffset(datum, rowHeights, columnWidths);
      dataStyle = {index:i, data, datum, symbol:dataStyle.type || dataStyle.symbol || "circle", size:datum.size, style:dataStyle, y:y + borderPadding.top + datum.symbolSpacer + offset.y + JSCompiler_object_inline_y_1143 + JSCompiler_object_inline_y_1145, x:x + borderPadding.left + datum.symbolSpacer + offset.x + JSCompiler_object_inline_x_1142 + JSCompiler_object_inline_x_1144};
      childProps[eventKey] = {data:dataStyle, labels:{datum, data, text:datum.name, style:labelStyles[i], y:dataStyle.y, x:dataStyle.x + datum.symbolSpacer + datum.size / 2}};
      return childProps;
    }, {parent:{data, standalone, theme, padding, name, height:initialProps.height, width:initialProps.width, style:style.parent}, all:{border:fallbackProps, title:titleDimensions}});
  };
};

//# sourceMappingURL=module$node_modules$victory_legend$lib$helper_methods.js.map
