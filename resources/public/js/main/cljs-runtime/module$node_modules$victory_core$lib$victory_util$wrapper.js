shadow$provide.module$node_modules$victory_core$lib$victory_util$wrapper = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function addBinsToParentPropsIfHistogram(_ref) {
    let {children, props, childComponents, parentProps} = _ref;
    var allChildrenAreHistograms = (_ref = children.some(child => child.type && "histogram" === child.type.role)) && children.length && children.every(child => child.type && "histogram" === child.type.role);
    _ref && !allChildrenAreHistograms && Log.warn("VictoryHistogram only supports being stacked with other VictoryHistogram components. Check to make sure that you are only passing VictoryHistogram components to VictoryStack");
    if (!allChildrenAreHistograms) {
      return parentProps;
    }
    _ref = props.bins || childComponents[0].props.bins;
    if (!Array.isArray(_ref)) {
      allChildrenAreHistograms = children.reduce((memo, child) => {
        const xAccessor = Helpers.createAccessor(child.props.x || "x");
        return memo.concat(child.props.data.map(datum => ({x:xAccessor(datum)})));
      }, []);
      const getFormattedHistogramData = children[0].type.getFormattedData;
      _ref = getFormattedHistogramData({data:allChildrenAreHistograms, bins:_ref}).reduce((memo, _ref2, index) => {
        let {x0, x1} = _ref2;
        return 0 === index ? memo.concat([x0, x1]) : memo.concat(x1);
      }, []);
    }
    return {...parentProps, bins:_ref};
  }
  function getDataFromChildren(props, childComponents) {
    const {polar, startAngle, endAngle, categories, minDomain, maxDomain} = props;
    let parentProps = {polar, startAngle, endAngle, categories, minDomain, maxDomain}, stack = 0;
    const children = childComponents ? childComponents.slice(0) : _react.default.Children.toArray(props.children);
    parentProps = addBinsToParentPropsIfHistogram({children, props, childComponents, parentProps});
    childComponents = children.filter(c => c.type && "stack" === c.type.role).length;
    props = Helpers.reduceChildren(children, (child, childName, parent) => {
      childName = Object.assign({}, child.props, parentProps);
      let childElement = child;
      if (Data.isDataComponent(child)) {
        child.type && Helpers.isFunction(child.type.getData) ? (childElement = parent ? _react.default.cloneElement(child, parent.props) : child, child = childElement.type.getData(childName)) : child = Data.getData(childName);
      } else {
        return null;
      }
      stack += 1;
      return child.map((datum, index) => Object.assign({_stack:stack, _group:index}, datum));
    }, props, [], (memo, val) => memo.concat((0,_uniqBy2.default)(val, "_group")));
    return Object.values((0,_groupBy2.default)(props, childComponents ? "_group" : "_stack"));
  }
  function getWidth(props, groupLength, seriesLength) {
    const {datasets, horizontal} = props;
    props = horizontal ? Helpers.getRange(props, "y") : Helpers.getRange(props, "x");
    props = Math.abs(props[1] - props[0]);
    seriesLength = void 0 !== seriesLength ? seriesLength : Array.isArray(datasets[0]) && datasets[0].length || 1;
    return Math.round(0.5 * props / ((groupLength || datasets.length) * seriesLength));
  }
  function getDefaultDomainPadding(props, axis, childComponents) {
    if (!(props.polar || "x" !== axis || (axis = childComponents.filter(child => child.type && child.type.role && "group" === child.type.role), 1 > axis.length))) {
      var {offset, children} = axis[0].props;
      if (offset && (axis = Array.isArray(children) && children[0])) {
        childComponents = axis.props.barWidth;
        var dataLength = axis.props.data && axis.props.data.length || 1;
        if (axis && "stack" === axis.type.role) {
          childComponents = axis.props.children && axis.props.children[0];
          if (!childComponents) {
            return;
          }
          childComponents = childComponents.props.barWidth;
          dataLength = axis.props.children.length;
        }
        props = childComponents || getWidth(props, children.length, dataLength);
        return {x:props * children.length / 2 + (offset - (children.length - 1) / 2 * props)};
      }
    }
  }
  function getDomainFromChildren(props, axis, childComponents) {
    childComponents = childComponents ? childComponents.slice(0) : _react.default.Children.toArray(props.children);
    const parentData = props.data ? Data.getData(props) : void 0, {polar, startAngle, endAngle, categories, minDomain, maxDomain, horizontal} = props, baseParentProps = {horizontal, polar, startAngle, endAngle, minDomain, maxDomain, categories}, parentProps = parentData ? Object.assign(baseParentProps, {data:parentData}) : baseParentProps;
    childComponents = Helpers.reduceChildren(childComponents, child => {
      const sharedProps = Object.assign({}, child.props, parentProps);
      return Domain.isDomainComponent(child) ? child.type && Helpers.isFunction(child.type.getDomain) ? child.props && child.type.getDomain(sharedProps, axis) : Domain.getDomain(sharedProps, axis) : null;
    }, props);
    props = 0 === childComponents.length ? 0 : Collection.getMinValue(childComponents);
    childComponents = 0 === childComponents.length ? 1 : Collection.getMaxValue(childComponents);
    return [props, childComponents];
  }
  function getColor(calculatedProps, child, index) {
    const {style} = calculatedProps;
    let {colorScale, color} = calculatedProps;
    if (style && style.data && style.data.fill) {
      return style.data.fill;
    }
    colorScale = child.props && child.props.colorScale ? child.props.colorScale : colorScale;
    color = child.props && child.props.color ? child.props.color : color;
    if (colorScale || color) {
      return calculatedProps = Array.isArray(colorScale) ? colorScale : Style.getColorScale(colorScale), color || calculatedProps[index % calculatedProps.length];
    }
  }
  function getStringsFromCategories(childComponents, axis) {
    return Helpers.reduceChildren(childComponents.slice(0), child => {
      const childProps = child.props || {};
      return Domain.isDomainComponent(child) && childProps.categories ? (child = (child = childProps.categories && !Array.isArray(childProps.categories) ? childProps.categories[axis] : childProps.props.categories) && child.filter(val => "string" === typeof val)) ? Collection.removeUndefined(child) : [] : null;
    });
  }
  function getStringsFromData(childComponents) {
    return Helpers.reduceChildren(childComponents.slice(0), child => {
      const childProps = child.props || {};
      if (Data.isDataComponent(child)) {
        child = child.type && Helpers.isFunction(child.type.getData) ? child.type.getData(childProps) : Data.getData(childProps);
      } else {
        return null;
      }
      return child.map(d => ({x:d.xName, y:d.yName}));
    }, {}, {x:[], y:[]}, (memo, datum) => {
      const x = Array.isArray(datum) ? datum.map(d => d.x).filter(Boolean) : datum.x;
      datum = Array.isArray(datum) ? datum.map(d => d.y).filter(Boolean) : datum.y;
      return {x:void 0 !== x ? memo.x.concat(x) : memo.x, y:void 0 !== datum ? memo.y.concat(datum) : memo.y};
    });
  }
  function getCategoryAndAxisStringsFromChildren(props, axis, childComponents) {
    props = (0,_isPlainObject2.default)(props.categories) ? props.categories[axis] : props.categories;
    var axisComponent = Axis.getAxisComponent(childComponents, axis);
    axisComponent = axisComponent ? Data.getStringsFromAxes(axisComponent.props, axis) : [];
    axis = props || getStringsFromCategories(childComponents, axis);
    return (0,_uniq2.default)([...axis, ...axisComponent].flat());
  }
  function getStringsFromChildren(props, childComponents) {
    var children = childComponents || _react.default.Children.toArray(props.children);
    childComponents = getCategoryAndAxisStringsFromChildren(props, "x", children);
    props = getCategoryAndAxisStringsFromChildren(props, "y", children);
    children = getStringsFromData(children);
    return {x:(0,_uniq2.default)([...childComponents, ...children.x].flat()), y:(0,_uniq2.default)([...props, ...children.y].flat())};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.addBinsToParentPropsIfHistogram = addBinsToParentPropsIfHistogram;
  exports.getAllEvents = function(props) {
    const componentEvents = Events.getComponentEvents(props, ["groupComponent", "containerComponent", "labelComponent"]);
    let events = props.events;
    Array.isArray(componentEvents) && (events = Array.isArray(props.events) ? componentEvents.concat(...props.events) : componentEvents);
    return events || [];
  };
  exports.getCategories = function(props, childComponents, allStrings) {
    var xPropCategories = props.categories && !Array.isArray(props.categories) ? props.categories.x : props.categories, yPropCategories = props.categories && !Array.isArray(props.categories) ? props.categories.y : props.categories;
    props = xPropCategories && yPropCategories ? {} : allStrings || getStringsFromChildren(props, childComponents);
    xPropCategories = xPropCategories || props.x;
    yPropCategories = yPropCategories || props.y;
    return {x:0 < xPropCategories.length ? xPropCategories : void 0, y:0 < yPropCategories.length ? yPropCategories : void 0};
  };
  exports.getCategoryAndAxisStringsFromChildren = getCategoryAndAxisStringsFromChildren;
  exports.getChildStyle = function(child, index, calculatedProps) {
    const {style, role} = calculatedProps, childStyle = child.props.style || {};
    if (Array.isArray(childStyle)) {
      return childStyle;
    }
    var childRole = child.type && child.type.role;
    child = "stack" === childRole ? void 0 : getColor(calculatedProps, child, index);
    childRole = "line" === childRole ? {fill:"none", stroke:child} : {fill:child};
    calculatedProps = "stack" === role ? {} : {width:getWidth(calculatedProps)};
    calculatedProps = (0,_defaults2.default)({}, childStyle.data, Object.assign({}, calculatedProps, style.data, childRole));
    childRole = (0,_defaults2.default)({}, childStyle.labels, style.labels);
    return {...childStyle, parent:style.parent, data:calculatedProps, labels:childRole};
  };
  exports.getColor = getColor;
  exports.getData = function(props, childComponents) {
    return props.data ? Data.getData(props) : getDataFromChildren(props, childComponents || _react.default.Children.toArray(props.children));
  };
  exports.getDataFromChildren = getDataFromChildren;
  exports.getDefaultDomainPadding = getDefaultDomainPadding;
  exports.getDomain = function(props, axis, childComponents) {
    var children = childComponents || _react.default.Children.toArray(props.children), propsDomain = Domain.getDomainFromProps(props, axis);
    childComponents = getDefaultDomainPadding(props, axis, children);
    if (!propsDomain) {
      var minDomain = Domain.getMinFromProps(props, axis);
      propsDomain = Domain.getMaxFromProps(props, axis);
      var dataset = (props.data || props.y) && Data.getData(props);
      dataset = dataset ? Domain.getDomainFromData(props, axis, dataset) : [];
      children = getDomainFromChildren(props, axis, children);
      minDomain = minDomain || Collection.getMinValue([...dataset, ...children]);
      propsDomain = propsDomain || Collection.getMaxValue([...dataset, ...children]);
      propsDomain = Domain.getDomainFromMinMax(minDomain, propsDomain);
    }
    return Domain.formatDomain(propsDomain, Object.assign({domainPadding:childComponents}, props), axis);
  };
  exports.getDomainFromChildren = getDomainFromChildren;
  exports.getScale = function(props, axis, childComponents) {
    if (props.data) {
      return Scale.getBaseScale(props, axis);
    }
    childComponents = childComponents ? childComponents.slice(0) : _react.default.Children.toArray(props.children);
    childComponents = (0,_uniq2.default)(Helpers.reduceChildren(childComponents, child => {
      child = Object.assign({}, child.props, {horizontal:props.horizontal});
      return Scale.getScaleType(child, axis);
    }, props));
    return 1 < childComponents.length ? Scale.getScaleFromName("linear") : Scale.getScaleFromName(childComponents[0]);
  };
  exports.getStringsFromCategories = getStringsFromCategories;
  exports.getStringsFromChildren = getStringsFromChildren;
  exports.getStringsFromData = getStringsFromData;
  exports.getStyle = function(theme, style, role) {
    return Helpers.getStyles(style, theme && theme[role] && theme[role].style ? theme[role].style : {});
  };
  exports.getWidth = getWidth;
  var _isPlainObject2 = _interopRequireDefault(require("module$node_modules$lodash$isPlainObject")), _uniqBy2 = _interopRequireDefault(require("module$node_modules$lodash$uniqBy")), _groupBy2 = _interopRequireDefault(require("module$node_modules$lodash$groupBy")), _uniq2 = _interopRequireDefault(require("module$node_modules$lodash$uniq")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _react = _interopRequireDefault(require("module$node_modules$react$index")), 
  Axis = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$axis")), Style = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$style")), Data = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$data")), Domain = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$domain")), Events = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$events")), 
  Collection = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$collection")), Helpers = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$helpers")), Scale = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$scale")), Log = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$log"));
};

//# sourceMappingURL=module$node_modules$victory_core$lib$victory_util$wrapper.js.map
