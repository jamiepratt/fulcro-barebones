shadow$provide.module$node_modules$wavesurfer_DOT_js$dist$wavesurfer_cjs = function(global, require, module, exports) {
  function t(t, e, i, s) {
    return new (i || (i = Promise))(function(n, r) {
      function o(t) {
        try {
          h(s.next(t));
        } catch (t) {
          r(t);
        }
      }
      function a(t) {
        try {
          h(s.throw(t));
        } catch (t) {
          r(t);
        }
      }
      function h(t) {
        var e;
        t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function(t) {
          t(e);
        })).then(o, a);
      }
      h((s = s.apply(t, e || [])).next());
    });
  }
  function s(t$jscomp$0, e) {
    t$jscomp$0 = e.xmlns ? document.createElementNS(e.xmlns, t$jscomp$0) : document.createElement(t$jscomp$0);
    for (const [t, n] of Object.entries(e)) {
      if ("children" === t) {
        for (const [t, n] of Object.entries(e)) {
          "string" == typeof n ? t$jscomp$0.appendChild(document.createTextNode(n)) : t$jscomp$0.appendChild(s(t, n));
        }
      } else {
        "style" === t ? Object.assign(t$jscomp$0.style, n) : "textContent" === t ? t$jscomp$0.textContent = n : t$jscomp$0.setAttribute(t, n.toString());
      }
    }
    return t$jscomp$0;
  }
  function n(t, e, i) {
    t = s(t, e || {});
    return null == i || i.appendChild(t), t;
  }
  class e {
    constructor() {
      this.listeners = {};
    }
    on(t, e, i) {
      if (this.listeners[t] || (this.listeners[t] = new Set()), this.listeners[t].add(e), null == i ? void 0 : i.once) {
        const i = () => {
          this.un(t, i);
          this.un(t, e);
        };
        return this.on(t, i), i;
      }
      return () => this.un(t, e);
    }
    un(t, e) {
      var i;
      null === (i = this.listeners[t]) || void 0 === i || i.delete(e);
    }
    once(t, e) {
      return this.on(t, e, {once:!0});
    }
    unAll() {
      this.listeners = {};
    }
    emit(t, ...e) {
      this.listeners[t] && this.listeners[t].forEach(t => t(...e));
    }
  }
  const i$jscomp$0 = {decode:function(e, i) {
    return t(this, void 0, void 0, function*() {
      const t = new AudioContext({sampleRate:i});
      return t.decodeAudioData(e).finally(() => t.close());
    });
  }, createBuffer:function(t, e) {
    return "number" == typeof t[0] && (t = [t]), function(t) {
      const e = t[0];
      if (e.some(t => 1 < t || -1 > t)) {
        const i = e.length;
        let s = 0;
        for (let t = 0; t < i; t++) {
          const i = Math.abs(e[t]);
          i > s && (s = i);
        }
        for (const e of t) {
          for (t = 0; t < i; t++) {
            e[t] /= s;
          }
        }
      }
    }(t), {duration:e, length:t[0].length, sampleRate:t[0].length / e, numberOfChannels:t.length, getChannelData:e => null == t ? void 0 : t[e], copyFromChannel:AudioBuffer.prototype.copyFromChannel, copyToChannel:AudioBuffer.prototype.copyToChannel};
  }};
  global = Object.freeze({__proto__:null, createElement:n, default:n});
  const o = {fetchBlob:function(e, i, s) {
    return t(this, void 0, void 0, function*() {
      const n = yield fetch(e, s);
      if (400 <= n.status) {
        throw Error(`Failed to fetch ${e}: ${n.status} (${n.statusText})`);
      }
      return function(e, i) {
        t(this, void 0, void 0, function*() {
          if (e.body && e.headers) {
            var s = e.body.getReader(), n = Number(e.headers.get("Content-Length")) || 0, r = 0, o = e => t(this, void 0, void 0, function*() {
              r += (null == e ? void 0 : e.length) || 0;
              i(Math.round(r / n * 100));
            }), a = () => t(this, void 0, void 0, function*() {
              let t;
              try {
                t = yield s.read();
              } catch (t) {
                return;
              }
              t.done || (o(t.value), yield a());
            });
            a();
          }
        });
      }(n.clone(), i), n.blob();
    });
  }};
  class a extends e {
    constructor(t) {
      super();
      this.isExternalMedia = !1;
      t.media ? (this.media = t.media, this.isExternalMedia = !0) : this.media = document.createElement("audio");
      t.mediaControls && (this.media.controls = !0);
      t.autoplay && (this.media.autoplay = !0);
      null != t.playbackRate && this.onMediaEvent("canplay", () => {
        null != t.playbackRate && (this.media.playbackRate = t.playbackRate);
      }, {once:!0});
    }
    onMediaEvent(t, e, i) {
      return this.media.addEventListener(t, e, i), () => this.media.removeEventListener(t, e, i);
    }
    getSrc() {
      return this.media.currentSrc || this.media.src || "";
    }
    revokeSrc() {
      const t = this.getSrc();
      t.startsWith("blob:") && URL.revokeObjectURL(t);
    }
    canPlayType(t) {
      return "" !== this.media.canPlayType(t);
    }
    setSrc(t, e) {
      this.getSrc() !== t && (this.revokeSrc(), t = e instanceof Blob && this.canPlayType(e.type) ? URL.createObjectURL(e) : t, this.media.src = t);
    }
    destroy() {
      this.media.pause();
      this.isExternalMedia || (this.media.remove(), this.revokeSrc(), this.media.src = "", this.media.load());
    }
    setMediaElement(t) {
      this.media = t;
    }
    play() {
      return t(this, void 0, void 0, function*() {
        return this.media.play();
      });
    }
    pause() {
      this.media.pause();
    }
    isPlaying() {
      return !this.media.paused && !this.media.ended;
    }
    setTime(t) {
      this.media.currentTime = t;
    }
    getDuration() {
      return this.media.duration;
    }
    getCurrentTime() {
      return this.media.currentTime;
    }
    getVolume() {
      return this.media.volume;
    }
    setVolume(t) {
      this.media.volume = t;
    }
    getMuted() {
      return this.media.muted;
    }
    setMuted(t) {
      this.media.muted = t;
    }
    getPlaybackRate() {
      return this.media.playbackRate;
    }
    isSeeking() {
      return this.media.seeking;
    }
    setPlaybackRate(t, e) {
      null != e && (this.media.preservesPitch = e);
      this.media.playbackRate = t;
    }
    getMediaElement() {
      return this.media;
    }
    setSinkId(t) {
      return this.media.setSinkId(t);
    }
  }
  class h extends e {
    constructor(t, e) {
      super();
      this.timeouts = [];
      this.isScrollable = !1;
      this.resizeObserver = this.audioData = null;
      this.lastContainerWidth = 0;
      this.isDragging = !1;
      this.options = t;
      this.parent = t = this.parentFromOptionsContainer(t.container);
      const [s, n] = this.initHtml();
      t.appendChild(s);
      this.container = s;
      this.scrollContainer = n.querySelector(".scroll");
      this.wrapper = n.querySelector(".wrapper");
      this.canvasWrapper = n.querySelector(".canvases");
      this.progressWrapper = n.querySelector(".progress");
      this.cursor = n.querySelector(".cursor");
      e && n.appendChild(e);
      this.initEvents();
    }
    parentFromOptionsContainer(t) {
      let e;
      if ("string" == typeof t ? e = document.querySelector(t) : t instanceof HTMLElement && (e = t), !e) {
        throw Error("Container not found");
      }
      return e;
    }
    initEvents() {
      const t = t => {
        const e = this.wrapper.getBoundingClientRect();
        return [(t.clientX - e.left) / e.width, (t.clientX - e.left) / e.height];
      };
      this.wrapper.addEventListener("click", e => {
        const [i, s] = t(e);
        this.emit("click", i, s);
      });
      this.wrapper.addEventListener("dblclick", e => {
        const [i, s] = t(e);
        this.emit("dblclick", i, s);
      });
      !0 !== this.options.dragToSeek && "object" != typeof this.options.dragToSeek || this.initDrag();
      this.scrollContainer.addEventListener("scroll", () => {
        const {scrollLeft:t, scrollWidth:e, clientWidth:i} = this.scrollContainer;
        this.emit("scroll", t / e, (t + i) / e);
      });
      const e = this.createDelay(100);
      this.resizeObserver = new ResizeObserver(() => {
        e().then(() => this.onContainerResize()).catch(() => {
        });
      });
      this.resizeObserver.observe(this.scrollContainer);
    }
    onContainerResize() {
      const t = this.parent.clientWidth;
      t === this.lastContainerWidth && "auto" !== this.options.height || (this.lastContainerWidth = t, this.reRender());
    }
    initDrag() {
      !function(t, e, i, s, n = 3, r = 0) {
        if (!t) {
          return () => {
          };
        }
        let o = () => {
        };
        t.addEventListener("pointerdown", a => {
          if (a.button === r) {
            a.preventDefault();
            a.stopPropagation();
            var h = a.clientX, l = a.clientY, d = !1, c = s$jscomp$0 => {
              s$jscomp$0.preventDefault();
              s$jscomp$0.stopPropagation();
              const r = s$jscomp$0.clientX;
              s$jscomp$0 = s$jscomp$0.clientY;
              const a = r - h, c = s$jscomp$0 - l;
              if (d || Math.abs(a) > n || Math.abs(c) > n) {
                const s = t.getBoundingClientRect(), {left:n, top:u} = s;
                d || (null == i || i(h - n, l - u), d = !0);
                e(a, c, r - n, s$jscomp$0 - u);
                h = r;
                l = s$jscomp$0;
              }
            }, u = e => {
              if (d) {
                const i = e.clientX;
                e = e.clientY;
                const r = t.getBoundingClientRect(), {left:o, top:a} = r;
                null == s || s(i - o, e - a);
              }
              o();
            }, p = t => {
              t.relatedTarget && t.relatedTarget !== document.documentElement || u(t);
            }, m = t => {
              d && (t.stopPropagation(), t.preventDefault());
            }, g = t => {
              d && t.preventDefault();
            };
            document.addEventListener("pointermove", c);
            document.addEventListener("pointerup", u);
            document.addEventListener("pointerout", p);
            document.addEventListener("pointercancel", p);
            document.addEventListener("touchmove", g, {passive:!1});
            document.addEventListener("click", m, {capture:!0});
            o = () => {
              document.removeEventListener("pointermove", c);
              document.removeEventListener("pointerup", u);
              document.removeEventListener("pointerout", p);
              document.removeEventListener("pointercancel", p);
              document.removeEventListener("touchmove", g);
              setTimeout(() => {
                document.removeEventListener("click", m, {capture:!0});
              }, 10);
            };
          }
        });
      }(this.wrapper, (t, e, i) => {
        this.emit("drag", Math.max(0, Math.min(1, i / this.wrapper.getBoundingClientRect().width)));
      }, t => {
        this.isDragging = !0;
        this.emit("dragstart", Math.max(0, Math.min(1, t / this.wrapper.getBoundingClientRect().width)));
      }, t => {
        this.isDragging = !1;
        this.emit("dragend", Math.max(0, Math.min(1, t / this.wrapper.getBoundingClientRect().width)));
      });
    }
    getHeight(t) {
      return null == t ? 128 : isNaN(Number(t)) ? "auto" === t && this.parent.clientHeight || 128 : Number(t);
    }
    initHtml() {
      const t = document.createElement("div"), e = t.attachShadow({mode:"open"});
      return e.innerHTML = `\n      <style>\n        :host {\n          user-select: none;\n          min-width: 1px;\n        }\n        :host audio {\n          display: block;\n          width: 100%;\n        }\n        :host .scroll {\n          overflow-x: auto;\n          overflow-y: hidden;\n          width: 100%;\n          position: relative;\n        }\n        :host .noScrollbar {\n          scrollbar-color: transparent;\n          scrollbar-width: none;\n        }\n        :host .noScrollbar::-webkit-scrollbar {\n          display: none;\n          -webkit-appearance: none;\n        }\n        :host .wrapper {\n          position: relative;\n          overflow: visible;\n          z-index: 2;\n        }\n        :host .canvases {\n          min-height: ${this.getHeight(this.options.height)}px;\n        }\n        :host .canvases > div {\n          position: relative;\n        }\n        :host canvas {\n          display: block;\n          position: absolute;\n          top: 0;\n          image-rendering: pixelated;\n        }\n        :host .progress {\n          pointer-events: none;\n          position: absolute;\n          z-index: 2;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          overflow: hidden;\n        }\n        :host .progress > div {\n          position: relative;\n        }\n        :host .cursor {\n          pointer-events: none;\n          position: absolute;\n          z-index: 5;\n          top: 0;\n          left: 0;\n          height: 100%;\n          border-radius: 2px;\n        }\n      </style>\n\n      <div class="scroll" part="scroll">\n        <div class="wrapper" part="wrapper">\n          <div class="canvases" part="canvases"></div>\n          <div class="progress" part="progress"></div>\n          <div class="cursor" part="cursor"></div>\n        </div>\n      </div>\n    `, 
      [t, e];
    }
    setOptions(t) {
      if (this.options.container !== t.container) {
        const e = this.parentFromOptionsContainer(t.container);
        e.appendChild(this.container);
        this.parent = e;
      }
      !0 !== t.dragToSeek && "object" != typeof this.options.dragToSeek || this.initDrag();
      this.options = t;
      this.reRender();
    }
    getWrapper() {
      return this.wrapper;
    }
    getScroll() {
      return this.scrollContainer.scrollLeft;
    }
    setScroll(t) {
      this.scrollContainer.scrollLeft = t;
    }
    setScrollPercentage(t) {
      const {scrollWidth:e} = this.scrollContainer;
      this.setScroll(e * t);
    }
    destroy() {
      var t;
      this.container.remove();
      null === (t = this.resizeObserver) || void 0 === t || t.disconnect();
    }
    createDelay(t = 10) {
      let e, i;
      const s = () => {
        e && clearTimeout(e);
        i && i();
      };
      return this.timeouts.push(s), () => new Promise((n, r) => {
        s();
        i = r;
        e = setTimeout(() => {
          i = e = void 0;
          n();
        }, t);
      });
    }
    convertColorValues(t) {
      if (!Array.isArray(t)) {
        return t || "";
      }
      if (2 > t.length) {
        return t[0] || "";
      }
      const e = document.createElement("canvas"), n = e.getContext("2d").createLinearGradient(0, 0, 0, e.height * (window.devicePixelRatio || 1)), r = 1 / (t.length - 1);
      return t.forEach((t, e) => {
        n.addColorStop(e * r, t);
      }), n;
    }
    renderBarWaveform(t$jscomp$0, e, i, s) {
      const n = t$jscomp$0[0];
      t$jscomp$0 = t$jscomp$0[1] || t$jscomp$0[0];
      const o = n.length, {width:a, height:h} = i.canvas, l = h / 2;
      var d$jscomp$0 = window.devicePixelRatio || 1;
      const c = e.barWidth ? e.barWidth * d$jscomp$0 : 1;
      d$jscomp$0 = e.barGap ? e.barGap * d$jscomp$0 : e.barWidth ? c / 2 : 0;
      const p = e.barRadius || 0, m = a / (c + d$jscomp$0) / o, g = p && "roundRect" in i ? "roundRect" : "rect";
      i.beginPath();
      let f = 0;
      var v = 0, b = 0;
      for (let t = 0; t <= o; t++) {
        var o$jscomp$0 = Math.round(t * m);
        o$jscomp$0 > f && (v = Math.round(v * l * s), b = v + Math.round(b * l * s) || 1, v = l - v, "top" === e.barAlign ? v = 0 : "bottom" === e.barAlign && (v = h - b), i[g](f * (c + d$jscomp$0), v, c, b, p), f = o$jscomp$0, b = v = 0);
        o$jscomp$0 = Math.abs(n[t] || 0);
        const d = Math.abs(t$jscomp$0[t] || 0);
        o$jscomp$0 > v && (v = o$jscomp$0);
        d > b && (b = d);
      }
      i.fill();
      i.closePath();
    }
    renderLineWaveform(t, e, i, s) {
      e = e => {
        const n = t[e] || t[0], r = n.length;
        var {height:o} = i.canvas;
        o /= 2;
        const h = i.canvas.width / r;
        i.moveTo(0, o);
        let l = 0, d = 0;
        for (let t = 0; t <= r; t++) {
          var r$jscomp$0 = Math.round(t * h);
          r$jscomp$0 > l && (i.lineTo(l, o + (Math.round(d * o * s) || 1) * (0 === e ? -1 : 1)), l = r$jscomp$0, d = 0);
          r$jscomp$0 = Math.abs(n[t] || 0);
          r$jscomp$0 > d && (d = r$jscomp$0);
        }
        i.lineTo(l, o);
      };
      i.beginPath();
      e(0);
      e(1);
      i.fill();
      i.closePath();
    }
    renderWaveform(t, e, i) {
      if (i.fillStyle = this.convertColorValues(e.waveColor), e.renderFunction) {
        return void e.renderFunction(t, i);
      }
      var s = e.barHeight || 1;
      e.normalize && (s = (s = Array.from(t[0]).reduce((t, e) => Math.max(t, Math.abs(e)), 0)) ? 1 / s : 1);
      e.barWidth || e.barGap || e.barAlign ? this.renderBarWaveform(t, e, i, s) : this.renderLineWaveform(t, e, i, s);
    }
    renderSingleCanvas(t, e, i, s, n, r, o, a) {
      const h = window.devicePixelRatio || 1, l = document.createElement("canvas"), d = t[0].length;
      l.width = Math.round(i * (r - n) / d);
      l.height = s * h;
      l.style.width = `${Math.floor(l.width / h)}px`;
      l.style.height = `${s}px`;
      l.style.left = `${Math.floor(n * i / h / d)}px`;
      o.appendChild(l);
      i = l.getContext("2d");
      if (this.renderWaveform(t.map(t => t.slice(n, r)), e, i), 0 < l.width && 0 < l.height) {
        t = l.cloneNode(), i = t.getContext("2d"), i.drawImage(l, 0, 0), i.globalCompositeOperation = "source-in", i.fillStyle = this.convertColorValues(e.progressColor), i.fillRect(0, 0, l.width, l.height), a.appendChild(t);
      }
    }
    renderChannel(e, i, s) {
      return t(this, void 0, void 0, function*() {
        const n = document.createElement("div"), r = this.getHeight(i.height);
        n.style.height = `${r}px`;
        this.canvasWrapper.style.minHeight = `${r}px`;
        this.canvasWrapper.appendChild(n);
        const o = n.cloneNode();
        this.progressWrapper.appendChild(o);
        const a = e[0].length, l = (t, h) => {
          this.renderSingleCanvas(e, i, s, r, Math.max(0, t), Math.min(h, a), n, o);
        };
        if (!this.isScrollable) {
          return void l(0, a);
        }
        const {scrollLeft:d, scrollWidth:c, clientWidth:u} = this.scrollContainer, p = a / c;
        let m = Math.min(h.MAX_CANVAS_WIDTH, u);
        if (i.barWidth || i.barGap) {
          var t$jscomp$0 = i.barWidth || .5;
          t$jscomp$0 += i.barGap || t$jscomp$0 / 2;
          0 != m % t$jscomp$0 && (m = Math.floor(m / t$jscomp$0) * t$jscomp$0);
        }
        const g = Math.floor(Math.abs(d) * p), f = Math.floor(g + m * p), v = f - g;
        0 >= v || (l(g, f), yield Promise.all([(() => t(this, void 0, void 0, function*() {
          if (0 !== g) {
            var t = this.createDelay();
            for (let e = g; 0 <= e; e -= v) {
              yield t(), l(Math.max(0, e - v), e);
            }
          }
        }))(), (() => t(this, void 0, void 0, function*() {
          if (f !== a) {
            var t = this.createDelay();
            for (let e = f; e < a; e += v) {
              yield t(), l(e, Math.min(a, e + v));
            }
          }
        }))()]));
      });
    }
    render(e) {
      return t(this, void 0, void 0, function*() {
        this.timeouts.forEach(t => t());
        this.timeouts = [];
        this.canvasWrapper.innerHTML = "";
        this.progressWrapper.innerHTML = "";
        null != this.options.width && (this.scrollContainer.style.width = "number" == typeof this.options.width ? `${this.options.width}px` : this.options.width);
        const t = window.devicePixelRatio || 1, i = this.scrollContainer.clientWidth, s = Math.ceil(e.duration * (this.options.minPxPerSec || 0));
        this.isScrollable = s > i;
        const n = this.options.fillParent && !this.isScrollable, r = (n ? i : s) * t;
        this.wrapper.style.width = n ? "100%" : `${s}px`;
        this.scrollContainer.style.overflowX = this.isScrollable ? "auto" : "hidden";
        this.scrollContainer.classList.toggle("noScrollbar", !!this.options.hideScrollbar);
        this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`;
        this.cursor.style.width = `${this.options.cursorWidth}px`;
        this.audioData = e;
        this.emit("render");
        try {
          if (this.options.splitChannels) {
            yield Promise.all(Array.from({length:e.numberOfChannels}).map((t, i) => {
              var s;
              t = Object.assign(Object.assign({}, this.options), null === (s = this.options.splitChannels) || void 0 === s ? void 0 : s[i]);
              return this.renderChannel([e.getChannelData(i)], t, r);
            }));
          } else {
            const t = [e.getChannelData(0)];
            1 < e.numberOfChannels && t.push(e.getChannelData(1));
            yield this.renderChannel(t, this.options, r);
          }
        } catch (t) {
          return;
        }
        this.emit("rendered");
      });
    }
    reRender() {
      if (this.audioData) {
        var {scrollWidth:t} = this.scrollContainer, {right:e} = this.progressWrapper.getBoundingClientRect();
        if (this.render(this.audioData), this.isScrollable && t !== this.scrollContainer.scrollWidth) {
          ({right:t} = this.progressWrapper.getBoundingClientRect()), e = 2 * (t - e), e = 0 > e ? Math.floor(e) : Math.ceil(e), this.scrollContainer.scrollLeft += e / 2;
        }
      }
    }
    zoom(t) {
      this.options.minPxPerSec = t;
      this.reRender();
    }
    scrollIntoView(t, e = !1) {
      const {scrollLeft:i, scrollWidth:s, clientWidth:n} = this.scrollContainer;
      t *= s;
      const a = i + n, h = n / 2;
      this.isDragging ? t + 30 > a ? this.scrollContainer.scrollLeft += 30 : t - 30 < i && (this.scrollContainer.scrollLeft -= 30) : ((t < i || t > a) && (this.scrollContainer.scrollLeft = t - (this.options.autoCenter ? h : 0)), t = t - i - h, e && this.options.autoCenter && 0 < t && (this.scrollContainer.scrollLeft += Math.min(t, 10)));
      e = this.scrollContainer.scrollLeft;
      this.emit("scroll", e / s, (e + n) / s);
    }
    renderProgress(t, e) {
      if (!isNaN(t)) {
        var i = 100 * t;
        this.progressWrapper.style.width = `${i}%`;
        this.cursor.style.left = `${i}%`;
        this.cursor.style.transform = `translateX(-${100 === Math.round(i) ? this.options.cursorWidth : 0}px)`;
        this.isScrollable && this.options.autoScroll && this.scrollIntoView(t, e);
      }
    }
    exportImage(e, i, s) {
      return t(this, void 0, void 0, function*() {
        var t = this.canvasWrapper.querySelectorAll("canvas");
        if (!t.length) {
          throw Error("No waveform data");
        }
        return "dataURL" === s ? (t = Array.from(t).map(t => t.toDataURL(e, i)), Promise.resolve(t)) : Promise.all(Array.from(t).map(t => new Promise((s, n) => {
          t.toBlob(t => {
            t ? s(t) : n(Error("Could not export image"));
          }, e, i);
        })));
      });
    }
  }
  h.MAX_CANVAS_WIDTH = 4E3;
  class l extends e {
    constructor() {
      super(...arguments);
      this.unsubscribe = () => {
      };
    }
    start() {
      this.unsubscribe = this.on("tick", () => {
        requestAnimationFrame(() => {
          this.emit("tick");
        });
      });
      this.emit("tick");
    }
    stop() {
      this.unsubscribe();
    }
    destroy() {
      this.unsubscribe();
    }
  }
  class d extends e {
    constructor(t = new AudioContext()) {
      super();
      this.bufferNode = null;
      this.playedDuration = this.playStartTime = 0;
      this._muted = !1;
      this._playbackRate = 1;
      this._duration = void 0;
      this.buffer = null;
      this.currentSrc = "";
      this.paused = !0;
      this.crossOrigin = null;
      this.autoplay = this.seeking = !1;
      this.addEventListener = this.on;
      this.removeEventListener = this.un;
      this.audioContext = t;
      this.gainNode = this.audioContext.createGain();
      this.gainNode.connect(this.audioContext.destination);
    }
    load() {
      return t(this, void 0, void 0, function*() {
      });
    }
    get src() {
      return this.currentSrc;
    }
    set src(t) {
      if (this.currentSrc = t, this._duration = void 0, !t) {
        return this.buffer = null, void this.emit("emptied");
      }
      fetch(t).then(e => {
        if (400 <= e.status) {
          throw Error(`Failed to fetch ${t}: ${e.status} (${e.statusText})`);
        }
        return e.arrayBuffer();
      }).then(e => this.currentSrc !== t ? null : this.audioContext.decodeAudioData(e)).then(e => {
        this.currentSrc === t && (this.buffer = e, this.emit("loadedmetadata"), this.emit("canplay"), this.autoplay && this.play());
      });
    }
    _play() {
      var t;
      this.paused && (this.paused = !1, null === (t = this.bufferNode) || void 0 === t || t.disconnect(), this.bufferNode = this.audioContext.createBufferSource(), this.buffer && (this.bufferNode.buffer = this.buffer), this.bufferNode.playbackRate.value = this._playbackRate, this.bufferNode.connect(this.gainNode), t = this.playedDuration * this._playbackRate, t >= this.duration && (t = 0, this.playedDuration = 0), this.bufferNode.start(this.audioContext.currentTime, t), this.playStartTime = this.audioContext.currentTime, 
      this.bufferNode.onended = () => {
        this.currentTime >= this.duration && (this.pause(), this.emit("ended"));
      });
    }
    _pause() {
      var t;
      this.paused = !0;
      null === (t = this.bufferNode) || void 0 === t || t.stop();
      this.playedDuration += this.audioContext.currentTime - this.playStartTime;
    }
    play() {
      return t(this, void 0, void 0, function*() {
        this.paused && (this._play(), this.emit("play"));
      });
    }
    pause() {
      this.paused || (this._pause(), this.emit("pause"));
    }
    stopAt(t) {
      var e, i;
      t -= this.currentTime;
      null === (e = this.bufferNode) || void 0 === e || e.stop(this.audioContext.currentTime + t);
      null === (i = this.bufferNode) || void 0 === i || i.addEventListener("ended", () => {
        this.bufferNode = null;
        this.pause();
      }, {once:!0});
    }
    setSinkId(e) {
      return t(this, void 0, void 0, function*() {
        return this.audioContext.setSinkId(e);
      });
    }
    get playbackRate() {
      return this._playbackRate;
    }
    set playbackRate(t) {
      this._playbackRate = t;
      this.bufferNode && (this.bufferNode.playbackRate.value = t);
    }
    get currentTime() {
      return (this.paused ? this.playedDuration : this.playedDuration + (this.audioContext.currentTime - this.playStartTime)) * this._playbackRate;
    }
    set currentTime(t) {
      const e = !this.paused;
      e && this._pause();
      this.playedDuration = t / this._playbackRate;
      e && this._play();
      this.emit("seeking");
      this.emit("timeupdate");
    }
    get duration() {
      var t, e;
      return null !== (t = this._duration) && void 0 !== t ? t : (null === (e = this.buffer) || void 0 === e ? void 0 : e.duration) || 0;
    }
    set duration(t) {
      this._duration = t;
    }
    get volume() {
      return this.gainNode.gain.value;
    }
    set volume(t) {
      this.gainNode.gain.value = t;
      this.emit("volumechange");
    }
    get muted() {
      return this._muted;
    }
    set muted(t) {
      this._muted !== t && (this._muted = t, this._muted ? this.gainNode.disconnect() : this.gainNode.connect(this.audioContext.destination));
    }
    canPlayType(t) {
      return /^(audio|video)\//.test(t);
    }
    getGainNode() {
      return this.gainNode;
    }
    getChannelData() {
      const t = [];
      if (!this.buffer) {
        return t;
      }
      const e = this.buffer.numberOfChannels;
      for (let i = 0; i < e; i++) {
        t.push(this.buffer.getChannelData(i));
      }
      return t;
    }
  }
  const c = {waveColor:"#999", progressColor:"#555", cursorWidth:1, minPxPerSec:0, fillParent:!0, interact:!0, dragToSeek:!1, autoScroll:!0, autoCenter:!0, sampleRate:8E3};
  class u extends a {
    static create(t) {
      return new u(t);
    }
    constructor(t) {
      const e = t.media || ("WebAudio" === t.backend ? new d() : void 0);
      super({media:e, mediaControls:t.mediaControls, autoplay:t.autoplay, playbackRate:t.audioRate});
      this.plugins = [];
      this.decodedData = null;
      this.subscriptions = [];
      this.mediaSubscriptions = [];
      this.abortController = null;
      this.abortController = new AbortController();
      this.options = Object.assign({}, c, t);
      this.timer = new l();
      t = e ? void 0 : this.getMediaElement();
      this.renderer = new h(this.options, t);
      this.initPlayerEvents();
      this.initRendererEvents();
      this.initTimerEvents();
      this.initPlugins();
      Promise.resolve().then(() => {
        this.emit("init");
        const t = this.options.url || this.getSrc() || "";
        (t || this.options.peaks && this.options.duration) && this.load(t, this.options.peaks, this.options.duration).catch(() => null);
      });
    }
    updateProgress(t = this.getCurrentTime()) {
      return this.renderer.renderProgress(t / this.getDuration(), this.isPlaying()), t;
    }
    initTimerEvents() {
      this.subscriptions.push(this.timer.on("tick", () => {
        if (!this.isSeeking()) {
          const t = this.updateProgress();
          this.emit("timeupdate", t);
          this.emit("audioprocess", t);
        }
      }));
    }
    initPlayerEvents() {
      this.isPlaying() && (this.emit("play"), this.timer.start());
      this.mediaSubscriptions.push(this.onMediaEvent("timeupdate", () => {
        const t = this.updateProgress();
        this.emit("timeupdate", t);
      }), this.onMediaEvent("play", () => {
        this.emit("play");
        this.timer.start();
      }), this.onMediaEvent("pause", () => {
        this.emit("pause");
        this.timer.stop();
      }), this.onMediaEvent("emptied", () => {
        this.timer.stop();
      }), this.onMediaEvent("ended", () => {
        this.emit("finish");
      }), this.onMediaEvent("seeking", () => {
        this.emit("seeking", this.getCurrentTime());
      }), this.onMediaEvent("error", t => {
        this.emit("error", t.error);
      }));
    }
    initRendererEvents() {
      this.subscriptions.push(this.renderer.on("click", (t, e) => {
        this.options.interact && (this.seekTo(t), this.emit("interaction", t * this.getDuration()), this.emit("click", t, e));
      }), this.renderer.on("dblclick", (t, e) => {
        this.emit("dblclick", t, e);
      }), this.renderer.on("scroll", (t, e) => {
        const i = this.getDuration();
        this.emit("scroll", t * i, e * i);
      }), this.renderer.on("render", () => {
        this.emit("redraw");
      }), this.renderer.on("rendered", () => {
        this.emit("redrawcomplete");
      }), this.renderer.on("dragstart", t => {
        this.emit("dragstart", t);
      }), this.renderer.on("dragend", t => {
        this.emit("dragend", t);
      }));
      let t;
      this.subscriptions.push(this.renderer.on("drag", e => {
        if (this.options.interact) {
          var i;
          this.renderer.renderProgress(e);
          clearTimeout(t);
          this.isPlaying() ? i = 0 : !0 === this.options.dragToSeek ? i = 200 : "object" == typeof this.options.dragToSeek && void 0 !== this.options.dragToSeek && (i = this.options.dragToSeek.debounceTime);
          t = setTimeout(() => {
            this.seekTo(e);
          }, i);
          this.emit("interaction", e * this.getDuration());
          this.emit("drag", e);
        }
      }));
    }
    initPlugins() {
      var t;
      (null === (t = this.options.plugins) || void 0 === t ? 0 : t.length) && this.options.plugins.forEach(t => {
        this.registerPlugin(t);
      });
    }
    unsubscribePlayerEvents() {
      this.mediaSubscriptions.forEach(t => t());
      this.mediaSubscriptions = [];
    }
    setOptions(t) {
      this.options = Object.assign({}, this.options, t);
      this.renderer.setOptions(this.options);
      t.audioRate && this.setPlaybackRate(t.audioRate);
      null != t.mediaControls && (this.getMediaElement().controls = t.mediaControls);
    }
    registerPlugin(t) {
      return t._init(this), this.plugins.push(t), this.subscriptions.push(t.once("destroy", () => {
        this.plugins = this.plugins.filter(e => e !== t);
      })), t;
    }
    getWrapper() {
      return this.renderer.getWrapper();
    }
    getScroll() {
      return this.renderer.getScroll();
    }
    setScrollTime(t) {
      t /= this.getDuration();
      this.renderer.setScrollPercentage(t);
    }
    getActivePlugins() {
      return this.plugins;
    }
    loadAudio(e, s, n, r) {
      var a;
      return t(this, void 0, void 0, function*() {
        if (this.emit("load", e), !this.options.media && this.isPlaying() && this.pause(), this.decodedData = null, !s && !n) {
          var i = Object.assign({signal:null === (a = this.abortController) || void 0 === a ? void 0 : a.signal}, this.options.fetchParams || {});
          s = yield o.fetchBlob(e, t => this.emit("loading", t), i);
        }
        this.setSrc(e, s);
        i = r || this.getDuration() || (yield new Promise(t => {
          this.onMediaEvent("loadedmetadata", () => t(this.getDuration()), {once:!0});
        }));
        if (!e && !s) {
          const e = this.getMediaElement();
          e instanceof d && (e.duration = i);
        }
        n ? this.decodedData = i$jscomp$0.createBuffer(n, i || 0) : s && (i = yield s.arrayBuffer(), this.decodedData = yield i$jscomp$0.decode(i, this.options.sampleRate));
        this.decodedData && (this.emit("decode", this.getDuration()), this.renderer.render(this.decodedData));
        this.emit("ready", this.getDuration());
      });
    }
    load(e, i, s) {
      return t(this, void 0, void 0, function*() {
        try {
          return yield this.loadAudio(e, void 0, i, s);
        } catch (t) {
          throw this.emit("error", t), t;
        }
      });
    }
    loadBlob(e, i, s) {
      return t(this, void 0, void 0, function*() {
        try {
          return yield this.loadAudio("blob", e, i, s);
        } catch (t) {
          throw this.emit("error", t), t;
        }
      });
    }
    zoom(t) {
      if (!this.decodedData) {
        throw Error("No audio loaded");
      }
      this.renderer.zoom(t);
      this.emit("zoom", t);
    }
    getDecodedData() {
      return this.decodedData;
    }
    exportPeaks({channels:t$jscomp$0 = 2, maxLength:e = 8E3, precision:i = 1E4} = {}) {
      if (!this.decodedData) {
        throw Error("The audio has not been decoded yet");
      }
      t$jscomp$0 = Math.min(t$jscomp$0, this.decodedData.numberOfChannels);
      const n = [];
      for (let t = 0; t < t$jscomp$0; t++) {
        const s = this.decodedData.getChannelData(t), r = [], o = Math.round(s.length / e);
        for (let t = 0; t < e; t++) {
          const e = s.slice(t * o, (t + 1) * o);
          let n = 0;
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            Math.abs(i) > Math.abs(n) && (n = i);
          }
          r.push(Math.round(n * i) / i);
        }
        n.push(r);
      }
      return n;
    }
    getDuration() {
      let t = super.getDuration() || 0;
      return 0 !== t && t !== 1 / 0 || !this.decodedData || (t = this.decodedData.duration), t;
    }
    toggleInteraction(t) {
      this.options.interact = t;
    }
    setTime(t) {
      super.setTime(t);
      this.updateProgress(t);
      this.emit("timeupdate", t);
    }
    seekTo(t) {
      t *= this.getDuration();
      this.setTime(t);
    }
    playPause() {
      return t(this, void 0, void 0, function*() {
        return this.isPlaying() ? this.pause() : this.play();
      });
    }
    stop() {
      this.pause();
      this.setTime(0);
    }
    skip(t) {
      this.setTime(this.getCurrentTime() + t);
    }
    empty() {
      this.load("", [[0]], .001);
    }
    setMediaElement(t) {
      this.unsubscribePlayerEvents();
      super.setMediaElement(t);
      this.initPlayerEvents();
    }
    exportImage(e = "image/png", i = 1, s = "dataURL") {
      return t(this, void 0, void 0, function*() {
        return this.renderer.exportImage(e, i, s);
      });
    }
    destroy() {
      var t;
      this.emit("destroy");
      null === (t = this.abortController) || void 0 === t || t.abort();
      this.plugins.forEach(t => t.destroy());
      this.subscriptions.forEach(t => t());
      this.unsubscribePlayerEvents();
      this.timer.destroy();
      this.renderer.destroy();
      super.destroy();
    }
  }
  u.BasePlugin = class extends e {
    constructor(t) {
      super();
      this.subscriptions = [];
      this.options = t;
    }
    onInit() {
    }
    _init(t) {
      this.wavesurfer = t;
      this.onInit();
    }
    destroy() {
      this.emit("destroy");
      this.subscriptions.forEach(t => t());
    }
  };
  u.dom = global;
  module.exports = u;
};

//# sourceMappingURL=module$node_modules$wavesurfer_DOT_js$dist$wavesurfer_cjs.js.map
