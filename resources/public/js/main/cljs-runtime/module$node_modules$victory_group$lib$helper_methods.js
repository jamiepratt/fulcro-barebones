shadow$provide.module$node_modules$victory_group$lib$helper_methods = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function getCalculatedProps(initialProps, childComponents) {
    var props = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "group");
    initialProps = _victoryCore.Wrapper.getStyle(props.theme, props.style, "group");
    const {offset, colorScale, color, polar, horizontal} = props, categories = props.categories || _victoryCore.Wrapper.getCategories(props, childComponents, null), datasets = props.datasets || _victoryCore.Wrapper.getDataFromChildren(props, null);
    childComponents = {x:_victoryCore.Wrapper.getDomain(Object.assign({}, props, {categories}), "x", childComponents), y:_victoryCore.Wrapper.getDomain(Object.assign({}, props, {categories}), "y", childComponents)};
    const range = props.range || {x:_victoryCore.Helpers.getRange(props, "x"), y:_victoryCore.Helpers.getRange(props, "y")};
    var JSCompiler_object_inline_x_1138 = _victoryCore.Scale.getScaleFromProps(props, "x") || _victoryCore.Wrapper.getScale(props, "x"), JSCompiler_object_inline_y_1139 = _victoryCore.Scale.getScaleFromProps(props, "y") || _victoryCore.Wrapper.getScale(props, "y");
    JSCompiler_object_inline_x_1138 = {x:JSCompiler_object_inline_x_1138.domain(childComponents.x).range(props.horizontal ? range.y : range.x), y:JSCompiler_object_inline_y_1139.domain(childComponents.y).range(props.horizontal ? range.x : range.y)};
    JSCompiler_object_inline_y_1139 = polar ? props.origin : _victoryCore.Helpers.getPolarOrigin(props);
    props = _victoryCore.Helpers.getPadding(props);
    return {datasets, categories, range, domain:childComponents, horizontal, scale:JSCompiler_object_inline_x_1138, style:initialProps, colorScale, color, offset, origin:JSCompiler_object_inline_y_1139, padding:props};
  }
  function getChildProps(props, calculatedProps) {
    const {categories, domain, range, scale, horizontal, origin, padding} = calculatedProps, {width, height, theme, polar} = props;
    return {height, width, theme, polar, origin, categories, domain, range, scale, horizontal, padding, standalone:!1};
  }
  function getDataWithOffset(props, defaultDataset, offset) {
    void 0 === defaultDataset && (defaultDataset = []);
    props = props.data || props.y ? _victoryCore.Data.getData(props) : defaultDataset;
    const xOffset = offset || 0;
    return props.map(datum => {
      const _x1 = datum._x instanceof Date ? new Date(datum._x.getTime() + xOffset) : datum._x + xOffset;
      return Object.assign({}, datum, {_x1});
    });
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getCalculatedProps = getCalculatedProps;
  exports.getChildren = function(initialProps, childComponents, calculatedProps) {
    const props = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "stack");
    initialProps = childComponents || _react.default.Children.toArray(props.children);
    const newCalculatedProps = calculatedProps || getCalculatedProps(props, initialProps), {datasets} = newCalculatedProps, {labelComponent, polar} = props, childProps = getChildProps(props, newCalculatedProps), parentName = props.name || "group";
    return initialProps.map((child, index) => {
      var role = child.type && child.type.role;
      if (polar) {
        var JSCompiler_temp = (("stack" === role ? newCalculatedProps.datasets[0].length : newCalculatedProps.datasets.length) - 1) / 2;
        var {range} = newCalculatedProps, angularRange = Math.abs(range.x[1] - range.x[0]);
        range = Math.max(...range.y);
        JSCompiler_temp = props.offset / (2 * Math.PI * range) * (index - JSCompiler_temp) * angularRange;
      } else {
        JSCompiler_temp = (("stack" === role ? newCalculatedProps.datasets[0].length : newCalculatedProps.datasets.length) - 1) / 2, props.offset ? (range = _victoryCore.Helpers.getCurrentAxis("x", props.horizontal), angularRange = newCalculatedProps.domain.x, range = newCalculatedProps.range[range], angularRange = Math.max(...angularRange) - Math.min(...angularRange), range = Math.max(...range) - Math.min(...range), angularRange = angularRange / range * props.offset) : angularRange = 0, JSCompiler_temp = 
        (index - JSCompiler_temp) * angularRange;
      }
      angularRange = "voronoi" === role || "tooltip" === role || "label" === role ? child.props.style : _victoryCore.Wrapper.getChildStyle(child, index, newCalculatedProps);
      range = props.labels ? props.labels ? Math.floor(datasets.length / 2) === index ? props.labels : void 0 : void 0 : child.props.labels;
      role = child.props.name || `${parentName}-${role}-${index}`;
      var JSCompiler_temp_const = _react.default, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.cloneElement, JSCompiler_temp_const$jscomp$1 = Object, JSCompiler_temp_const$jscomp$2 = JSCompiler_temp_const$jscomp$1.assign, JSCompiler_temp_const$jscomp$3 = getDataWithOffset(props, datasets[index], JSCompiler_temp);
      {
        var JSCompiler_inline_result = child.type && child.type.role;
        const colorScaleOptions = child.props.colorScale || props.colorScale;
        JSCompiler_inline_result = "group" !== JSCompiler_inline_result && "stack" !== JSCompiler_inline_result ? void 0 : props.theme && props.theme.group ? colorScaleOptions || props.theme.group.colorScale : colorScaleOptions;
      }
      return JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, child, JSCompiler_temp_const$jscomp$2.call(JSCompiler_temp_const$jscomp$1, {labels:range, style:angularRange, key:`${role}-key-${index}`, name:role, data:JSCompiler_temp_const$jscomp$3, colorScale:JSCompiler_inline_result, labelComponent:labelComponent || child.props.labelComponent, xOffset:JSCompiler_temp}, childProps));
    });
  };
  exports.useMemoizedProps = function(initialProps) {
    const modifiedProps = withoutSharedEvents(initialProps), [props, setProps] = _react.default.useState(modifiedProps);
    _react.default.useEffect(() => {
      (0,_reactFastCompare.default)(modifiedProps, props) || setProps(modifiedProps);
    }, [props, setProps, modifiedProps]);
    return _react.default.useMemo(() => getCalculatedProps(props, props.children), [props]);
  };
  var _react = _interopRequireDefault(require("module$node_modules$react$index")), _victoryCore = require("module$node_modules$victory_core$lib$index"), _reactFastCompare = _interopRequireDefault(require("module$node_modules$react_fast_compare$index"));
  const fallbackProps = {width:450, height:300, padding:50, offset:0}, withoutSharedEvents = props => {
    var {children} = props;
    children = _react.default.Children.toArray(children).map(child => ({...child, props:_victoryCore.Helpers.omit(child.props, ["sharedEvents"])}));
    props.children = children;
    return props;
  };
};

//# sourceMappingURL=module$node_modules$victory_group$lib$helper_methods.js.map
