shadow$provide.module$node_modules$victory_core$lib$victory_util$transitions = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function getKeyedData(data) {
    return data.reduce((keyedData, datum, idx) => {
      keyedData[(datum.key || idx).toString()] = datum;
      return keyedData;
    }, {});
  }
  function getKeyedDataDifference(a, b) {
    let hasDifference = !1;
    a = Object.keys(a).reduce((_difference, key) => {
      key in b || (hasDifference = !0, _difference[key] = !0);
      return _difference;
    }, {});
    return hasDifference && a;
  }
  function getChildData(child) {
    return child.type && child.type.getData ? child.type.getData(child.props) : child.props && child.props.data || !1;
  }
  function getInitialChildProps(animate, data) {
    const after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity2.default;
    return {data:data.map((datum, idx) => Object.assign({}, datum, after(datum, idx, data)))};
  }
  function getChildBeforeLoad(animate, child, data, cb) {
    if ((animate = Object.assign({}, animate, {onEnd:cb})) && animate.onLoad && !animate.onLoad.duration) {
      return {animate, data};
    }
    const before = animate.onLoad && animate.onLoad.before ? animate.onLoad.before : _identity2.default;
    child = data.map((datum, idx) => Object.assign({}, datum, before(datum, idx, data)));
    return {animate, data:child, clipWidth:0};
  }
  function getChildOnLoad(animate, data, cb) {
    cb = Object.assign({}, animate, {onEnd:cb});
    let newData = data;
    if (cb && cb.onLoad && !cb.onLoad.duration) {
      return {animate, data};
    }
    const after = animate.onLoad && animate.onLoad.after ? animate.onLoad.after : _identity2.default;
    newData = data.map((datum, idx) => Object.assign({}, datum, after(datum, idx, data)));
    return {animate:cb, data:newData};
  }
  function getChildPropsOnExit(animate, child, data, exitingNodes, cb) {
    child = Object.assign({}, animate, animate && animate.onExit);
    let newData = data;
    if (exitingNodes) {
      animate.onEnd = cb;
      const before = animate.onExit && animate.onExit.before ? animate.onExit.before : _identity2.default;
      newData = data.map((datum, idx) => exitingNodes[(datum.key || idx).toString()] ? Object.assign({}, datum, before(datum, idx, data)) : datum);
    }
    return {animate:child, data:newData};
  }
  function getChildPropsBeforeEnter(animate, child, data, enteringNodes, cb) {
    child = animate;
    let newData = data;
    if (enteringNodes) {
      child = Object.assign({}, animate, {onEnd:cb});
      const before = animate.onEnter && animate.onEnter.before ? animate.onEnter.before : _identity2.default;
      newData = data.map((datum, idx) => enteringNodes[(datum.key || idx).toString()] ? Object.assign({}, datum, before(datum, idx, data)) : datum);
    }
    return {animate:child, data:newData};
  }
  function getChildPropsOnEnter(animate, data, enteringNodes, cb) {
    animate = Object.assign({}, animate, animate && animate.onEnter);
    let newData = data;
    if (enteringNodes) {
      animate.onEnd = cb;
      const after = animate.onEnter && animate.onEnter.after ? animate.onEnter.after : _identity2.default;
      newData = data.map((datum, idx) => enteringNodes[(datum.key || idx).toString()] ? Object.assign({}, datum, after(datum, idx, data)) : datum);
    }
    return {animate, data:newData};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getInitialTransitionState = function(oldChildren, nextChildren) {
    let nodesWillExit = !1, nodesWillEnter = !1;
    const getTransitionsFromChildren = (old, next) => old.map((child, idx) => {
      if (child && child.props && child.props.children && next[idx]) {
        return getTransitionsFromChildren(_react.default.Children.toArray(old[idx].props.children), _react.default.Children.toArray(next[idx].props.children));
      }
      if ((idx = next[idx]) && child.type === idx.type) {
        child = getChildData(child);
        idx = getChildData(idx);
        child = child && getKeyedData(child);
        idx = idx && getKeyedData(idx);
        child = {entering:child && getKeyedDataDifference(idx, child), exiting:idx && getKeyedDataDifference(child, idx)};
        var {entering, exiting} = child || {};
        nodesWillExit = nodesWillExit || !!exiting;
        nodesWillEnter = nodesWillEnter || !!entering;
        child = {entering:entering || !1, exiting:exiting || !1};
      } else {
        child = {};
      }
      return child;
    });
    oldChildren = getTransitionsFromChildren(_react.default.Children.toArray(oldChildren), _react.default.Children.toArray(nextChildren));
    return {nodesWillExit, nodesWillEnter, childrenTransitions:oldChildren, nodesShouldEnter:!1};
  };
  exports.getTransitionPropsFactory = function(props, state, setState) {
    const nodesWillExit = state && state.nodesWillExit, nodesWillEnter = state && state.nodesWillEnter, nodesShouldEnter = state && state.nodesShouldEnter, nodesShouldLoad = state && state.nodesShouldLoad, nodesDoneLoad = state && state.nodesDoneLoad, childrenTransitions = state && state.childrenTransitions || [];
    var JSCompiler_object_inline_enter_1059 = props.animate && props.animate.onEnter && props.animate.onEnter.duration, JSCompiler_object_inline_exit_1060 = props.animate && props.animate.onExit && props.animate.onExit.duration, JSCompiler_object_inline_load_1061 = props.animate && props.animate.onLoad && props.animate.onLoad.duration, JSCompiler_object_inline_move_1062 = props.animate && props.animate.duration;
    const onLoad = (child, data, animate) => nodesShouldLoad ? getChildOnLoad(animate, data, () => {
      setState({nodesShouldLoad:!1, nodesDoneLoad:!0});
    }) : getChildBeforeLoad(animate, child, data, () => {
      setState({nodesDoneLoad:!0});
    }), onExit = (nodes, child, data, animate) => getChildPropsOnExit(animate, child, data, nodes, () => {
      setState({nodesWillExit:!1});
    }), onEnter = (nodes, child, data, animate) => nodesShouldEnter ? getChildPropsOnEnter(animate, data, nodes, () => {
      setState({nodesWillEnter:!1});
    }) : getChildPropsBeforeEnter(animate, child, data, nodes, () => {
      setState({nodesShouldEnter:!0});
    }), getChildTransitionDuration = function(child, type) {
      var animate = child.props.animate;
      return child.type ? (child = child.props && child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions) ? (animate = animate[type] && animate[type].duration, void 0 !== animate ? animate : child[type] && child[type].duration) : {} : {};
    };
    return function(child, index) {
      const data = getChildData(child) || [], animate = (0,_defaults2.default)({}, props.animate, child.props.animate);
      var defaultTransitions = child.props.polar ? child.type.defaultPolarTransitions || child.type.defaultTransitions : child.type.defaultTransitions;
      animate.onExit = (0,_defaults2.default)({}, animate.onExit, defaultTransitions && defaultTransitions.onExit);
      animate.onEnter = (0,_defaults2.default)({}, animate.onEnter, defaultTransitions && defaultTransitions.onEnter);
      animate.onLoad = (0,_defaults2.default)({}, animate.onLoad, defaultTransitions && defaultTransitions.onLoad);
      index = childrenTransitions[index] || childrenTransitions[0];
      if (nodesDoneLoad) {
        if (nodesWillExit) {
          return index = index && index.exiting, defaultTransitions = void 0 !== JSCompiler_object_inline_exit_1060 ? JSCompiler_object_inline_exit_1060 : getChildTransitionDuration(child, "onExit"), onExit(index, child, data, Object.assign({}, animate, index ? {duration:defaultTransitions} : {delay:defaultTransitions}));
        }
        if (nodesWillEnter) {
          index = index && index.entering;
          defaultTransitions = void 0 !== JSCompiler_object_inline_enter_1059 ? JSCompiler_object_inline_enter_1059 : getChildTransitionDuration(child, "onEnter");
          const move = void 0 !== JSCompiler_object_inline_move_1062 ? JSCompiler_object_inline_move_1062 : child.props.animate && child.props.animate.duration;
          return onEnter(index, child, data, Object.assign({}, animate, {duration:nodesShouldEnter && index ? defaultTransitions : move}));
        }
        if (!state && animate && animate.onExit) {
          return getInitialChildProps(animate, data);
        }
      } else {
        return index = {duration:void 0 !== JSCompiler_object_inline_load_1061 ? JSCompiler_object_inline_load_1061 : getChildTransitionDuration(child, "onLoad")}, onLoad(child, data, Object.assign({}, animate, index));
      }
      return {animate, data};
    };
  };
  var _identity2 = _interopRequireDefault(require("module$node_modules$lodash$identity")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _react = _interopRequireDefault(require("module$node_modules$react$index"));
};

//# sourceMappingURL=module$node_modules$victory_core$lib$victory_util$transitions.js.map
