shadow$provide.module$node_modules$victory_voronoi$lib$helper_methods = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  Object.defineProperty(exports, "_internalD3Voronoi", {enumerable:!0, get:function() {
    return _d3Voronoi.voronoi;
  }});
  exports.getBaseProps = void 0;
  var _d3Voronoi = require("module$node_modules$d3_voronoi$dist$d3_voronoi"), _victoryCore = require("module$node_modules$victory_core$lib$index");
  const getVoronoi = (props, range, scale) => {
    const minRange = [Math.min(...range.x), Math.min(...range.y)];
    range = [Math.max(...range.x), Math.max(...range.y)];
    return (0,_d3Voronoi.voronoi)().x(d => props.polar ? -1 * scale.x(void 0 !== d._x1 ? d._x1 : d._x) + Math.PI / 2 : props.horizontal ? scale.y(void 0 !== d._y1 ? d._y1 : d._y) : scale.x(void 0 !== d._x1 ? d._x1 : d._x)).y(d => props.horizontal ? scale.x(void 0 !== d._x1 ? d._x1 : d._x) : scale.y(void 0 !== d._y1 ? d._y1 : d._y)).extent([minRange, range]);
  }, getCalculatedValues = props => {
    const style = _victoryCore.Helpers.getStyles(props.style, props.theme && props.theme.voronoi && props.theme.voronoi.style ? props.theme.voronoi.style : {});
    var range = {x:_victoryCore.Helpers.getRange(props, "x"), y:_victoryCore.Helpers.getRange(props, "y")};
    const domain = {x:_victoryCore.Domain.getDomain(props, "x"), y:_victoryCore.Domain.getDomain(props, "y")}, scale = {x:_victoryCore.Scale.getBaseScale(props, "x").domain(domain.x).range(props.horizontal ? range.y : range.x), y:_victoryCore.Scale.getBaseScale(props, "y").domain(domain.y).range(props.horizontal ? range.x : range.y)};
    let data = _victoryCore.Data.getData(props);
    data = _victoryCore.Data.formatDataFromDomain(data, domain);
    data = data.filter(datum => null === datum._x || null === datum._y ? !1 : !0);
    range = getVoronoi(props, range, scale).polygons(data);
    props = props.polar ? props.origin || _victoryCore.Helpers.getPolarOrigin(props) : void 0;
    return {domain, data, scale, style, polygons:range, origin:props};
  };
  exports.getBaseProps = (initialProps, fallbackProps) => {
    initialProps = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "scatter");
    const props = Object.assign({}, initialProps, getCalculatedValues(initialProps)), {data, domain, events, height, origin, padding, polar, polygons, scale, sharedEvents, standalone, style, theme, width, labels, name} = props;
    return data.reduce((childProps, datum, index) => {
      const polygon = polygons[index]?.filter(value => "data" !== value), eventKey = _victoryCore.Helpers.isNil(datum.eventKey) ? index : datum.eventKey, {x, y} = _victoryCore.Helpers.scalePoint(props, datum);
      childProps[eventKey] = {data:{x, y, datum, data, index, scale, polygon, origin, size:props.size, style:style.data}};
      datum = _victoryCore.LabelHelpers.getText(props, datum, index);
      if (void 0 !== datum && null !== datum || labels && (events || sharedEvents)) {
        childProps[eventKey].labels = _victoryCore.LabelHelpers.getProps(props, index);
      }
      return childProps;
    }, {parent:{style:style.parent, scale, domain, data, standalone, height, width, theme, origin, polar, padding, name}});
  };
};

//# sourceMappingURL=module$node_modules$victory_voronoi$lib$helper_methods.js.map
