shadow$provide.module$node_modules$victory_brush_container$lib$brush_helpers = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.BrushHelpers = void 0;
  var _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults"));
  global = _interopRequireDefault(require("module$node_modules$lodash$throttle"));
  var _victoryCore = require("module$node_modules$victory_core$lib$index"), _reactFastCompare = _interopRequireDefault(require("module$node_modules$react_fast_compare$index"));
  require = {getDimension(props) {
    const {horizontal, brushDimension} = props;
    return horizontal && brushDimension ? "x" === brushDimension ? "y" : "x" : brushDimension;
  }, withinBounds(point, bounds, padding) {
    const {x1, x2, y1, y2} = _victoryCore.Helpers.mapValues(bounds, Number), {x, y} = _victoryCore.Helpers.mapValues(point, Number);
    point = padding ? padding / 2 : 0;
    return x + point >= Math.min(x1, x2) && x - point <= Math.max(x1, x2) && y + point >= Math.min(y1, y2) && y - point <= Math.max(y1, y2);
  }, getDomainBox(props, fullDomain, selectedDomain) {
    const brushDimension = this.getDimension(props);
    fullDomain = (0,_defaults2.default)({}, fullDomain, props.domain);
    selectedDomain = (0,_defaults2.default)({}, selectedDomain, fullDomain);
    fullDomain = _victoryCore.Selection.getDomainCoordinates(props, fullDomain);
    props = _victoryCore.Selection.getDomainCoordinates(props, selectedDomain);
    return {x1:"y" !== brushDimension ? Math.min(...props.x) : Math.min(...fullDomain.x), x2:"y" !== brushDimension ? Math.max(...props.x) : Math.max(...fullDomain.x), y1:"x" !== brushDimension ? Math.min(...props.y) : Math.min(...fullDomain.y), y2:"x" !== brushDimension ? Math.max(...props.y) : Math.max(...fullDomain.y)};
  }, getHandles(props, domainBox) {
    const brushDimension = this.getDimension(props), {x1, x2, y1, y2} = domainBox;
    domainBox = Math.min(x1, x2);
    const maxX = Math.max(x1, x2), minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
    props = props.handleWidth / 2;
    return {left:"y" !== brushDimension && {x1:domainBox - props, x2:domainBox + props, y1, y2}, right:"y" !== brushDimension && {x1:maxX - props, x2:maxX + props, y1, y2}, top:"x" !== brushDimension && {x1, x2, y1:minY - props, y2:minY + props}, bottom:"x" !== brushDimension && {x1, x2, y1:maxY - props, y2:maxY + props}};
  }, getActiveHandles(point, props, domainBox) {
    const handles = this.getHandles(props, domainBox);
    props = ["top", "bottom", "left", "right"].reduce((memo, opt) => handles[opt] && this.withinBounds(point, handles[opt]) ? memo.concat(opt) : memo, []);
    return props.length && props;
  }, getResizeMutation(box, handles) {
    const {x1, y1, x2, y2} = box, mutations = {left:{x1:Math.max(x1, x2), x2:Math.min(x1, x2), y1, y2}, right:{x1:Math.min(x1, x2), x2:Math.max(x1, x2), y1, y2}, top:{y1:Math.max(y1, y2), y2:Math.min(y1, y2), x1, x2}, bottom:{y1:Math.min(y1, y2), y2:Math.max(y1, y2), x1, x2}};
    return handles.reduce((memo, current) => Object.assign(memo, mutations[current]), {});
  }, getMinimumDomain() {
    return {x:[0, 1 / Number.MAX_SAFE_INTEGER], y:[0, 1 / Number.MAX_SAFE_INTEGER]};
  }, getDefaultBrushArea(targetProps, cachedDomain, evt) {
    const {domain, fullDomain, scale, horizontal, allowResize} = targetProps;
    var defaultBrushArea = allowResize || targetProps.defaultBrushArea ? targetProps.defaultBrushArea : "move";
    if ("none" === defaultBrushArea) {
      return this.getMinimumDomain();
    }
    if ("disable" === defaultBrushArea) {
      return cachedDomain;
    }
    if ("move" === defaultBrushArea) {
      defaultBrushArea = this.getDomainBox(targetProps, fullDomain, cachedDomain);
      const parentSVG = targetProps.parentSVG || _victoryCore.Selection.getParentSVG(evt);
      cachedDomain = this.panBox({...targetProps, ...defaultBrushArea, brushDomain:cachedDomain, startX:(defaultBrushArea.x1 + defaultBrushArea.x2) / 2, startY:(defaultBrushArea.y1 + defaultBrushArea.y2) / 2}, _victoryCore.Selection.getSVGEventCoordinates(evt, parentSVG));
      targetProps = targetProps.fullDomainBox || this.getDomainBox(targetProps, fullDomain);
      targetProps = this.constrainBox(cachedDomain, targetProps);
      return _victoryCore.Selection.getBounds({...targetProps, scale, horizontal});
    }
    return domain;
  }, getSelectionMutation(point, box, brushDimension) {
    const {x, y} = point, {x1, x2, y1, y2} = box;
    return {x1:"y" !== brushDimension ? x : x1, y1:"x" !== brushDimension ? y : y1, x2:"y" !== brushDimension ? x : x2, y2:"x" !== brushDimension ? y : y2};
  }, panBox(props, point) {
    const {domain, startX, startY} = props, brushDimension = this.getDimension(props), brushDomain = (0,_defaults2.default)({}, props.brushDomain, domain), fullDomain = (0,_defaults2.default)({}, props.fullDomain, domain), {x1, x2, y1, y2} = props.x1 ? props : this.getDomainBox(props, fullDomain, brushDomain), {x, y} = point;
    props = startX ? startX - x : 0;
    point = startY ? startY - y : 0;
    return {x1:"y" !== brushDimension ? Math.min(x1, x2) - props : Math.min(x1, x2), x2:"y" !== brushDimension ? Math.max(x1, x2) - props : Math.max(x1, x2), y1:"x" !== brushDimension ? Math.min(y1, y2) - point : Math.min(y1, y2), y2:"x" !== brushDimension ? Math.max(y1, y2) - point : Math.max(y1, y2)};
  }, constrainBox(box, fullDomainBox) {
    const {x1, y1, x2, y2} = _victoryCore.Helpers.mapValues(fullDomainBox, Number);
    return {x1:box.x2 > x2 ? x2 - Math.abs(box.x2 - box.x1) : Math.max(box.x1, x1), y1:box.y2 > y2 ? y2 - Math.abs(box.y2 - box.y1) : Math.max(box.y1, y1), x2:box.x1 < x1 ? x1 + Math.abs(box.x2 - box.x1) : Math.min(box.x2, x2), y2:box.y1 < y1 ? y1 + Math.abs(box.y2 - box.y1) : Math.min(box.y2, y2)};
  }, constrainPoint(point, fullDomainBox) {
    const {x1, y1, x2, y2} = _victoryCore.Helpers.mapValues(fullDomainBox, Number);
    return {x:Math.min(Math.max(point.x, x1), x2), y:Math.min(Math.max(point.y, y1), y2)};
  }, hasMoved(props) {
    const {x1, x2, y1, y2, mouseMoveThreshold} = props;
    props = this.getDimension(props);
    const xMoved = Math.abs(x1 - x2) >= mouseMoveThreshold, yMoved = Math.abs(y1 - y2) >= mouseMoveThreshold;
    switch(props) {
      case "x":
        return xMoved;
      case "y":
        return yMoved;
      default:
        return xMoved || yMoved;
    }
  }, onMouseDown(evt, targetProps) {
    evt.preventDefault();
    const {handleWidth, cachedBrushDomain, domain, allowResize, allowDrag, allowDraw} = targetProps, brushDimension = this.getDimension(targetProps), defaultBrushArea = allowResize || targetProps.defaultBrushArea ? targetProps.defaultBrushArea : "move";
    if (!allowResize && !allowDrag) {
      return {};
    }
    const fullDomainBox = targetProps.fullDomainBox || this.getDomainBox(targetProps, domain), parentSVG = targetProps.parentSVG || _victoryCore.Selection.getParentSVG(evt), {x, y} = _victoryCore.Selection.getSVGEventCoordinates(evt, parentSVG);
    if (!this.withinBounds({x, y}, fullDomainBox, handleWidth)) {
      return {};
    }
    const brushDomain = (0,_defaults2.default)({}, targetProps.brushDomain, domain), currentDomain = (0,_reactFastCompare.default)(brushDomain, cachedBrushDomain) ? targetProps.currentDomain || brushDomain || domain : brushDomain || domain, domainBox = this.getDomainBox(targetProps, domain, currentDomain), activeHandles = allowResize && this.getActiveHandles({x, y}, targetProps, domainBox);
    return activeHandles ? [{target:"parent", mutation:() => ({isSelecting:!0, domainBox, fullDomainBox, cachedBrushDomain:brushDomain, currentDomain, parentSVG, ...this.getResizeMutation(domainBox, activeHandles)})}] : this.withinBounds({x, y}, domainBox) && !(0,_reactFastCompare.default)(domain, currentDomain) ? [{target:"parent", mutation:() => ({isPanning:allowDrag, startX:x, startY:y, domainBox, fullDomainBox, currentDomain, cachedBrushDomain:brushDomain, parentSVG, ...domainBox})}] : allowDraw ? 
    [{target:"parent", mutation:() => ({isSelecting:allowResize || "move" === defaultBrushArea, domainBox, fullDomainBox, parentSVG, cachedBrushDomain:brushDomain, cachedCurrentDomain:currentDomain, currentDomain:this.getMinimumDomain(), ...this.getSelectionMutation({x, y}, domainBox, brushDimension)})}] : {};
  }, onGlobalMouseMove(evt, targetProps) {
    const {scale, isPanning, isSelecting, fullDomainBox, onBrushDomainChange, allowResize, allowDrag, horizontal, mouseMoveThreshold, parentSVG} = targetProps;
    var brushDimension = this.getDimension(targetProps);
    const {x, y} = _victoryCore.Selection.getSVGEventCoordinates(evt, parentSVG);
    if (!allowResize && !allowDrag || 0 < mouseMoveThreshold && !this.hasMoved({...targetProps, x2:x, y2:y})) {
      return {};
    }
    if (allowDrag && isPanning) {
      const {startX, startY} = targetProps;
      evt = this.panBox(targetProps, {x, y});
      brushDimension = this.constrainBox(evt, fullDomainBox);
      const currentDomain = _victoryCore.Selection.getBounds({...brushDimension, scale, horizontal}), mutatedProps = {currentDomain, parentSVG, startX:evt.x2 >= fullDomainBox.x2 || evt.x1 <= fullDomainBox.x1 ? startX : x, startY:evt.y2 >= fullDomainBox.y2 || evt.y1 <= fullDomainBox.y1 ? startY : y, ...brushDimension};
      _victoryCore.Helpers.isFunction(onBrushDomainChange) && onBrushDomainChange(currentDomain, (0,_defaults2.default)({}, mutatedProps, targetProps));
      return [{target:"parent", mutation:() => mutatedProps}];
    }
    if (allowResize && isSelecting) {
      const {x:x2, y:y2} = this.constrainPoint({x:"y" !== brushDimension ? x : targetProps.x2, y:"x" !== brushDimension ? y : targetProps.y2}, fullDomainBox);
      evt = _victoryCore.Selection.getBounds({x2, y2, x1:targetProps.x1, y1:targetProps.y1, scale, horizontal});
      const mutatedProps = {x2, y2, currentDomain:evt, parentSVG};
      _victoryCore.Helpers.isFunction(onBrushDomainChange) && onBrushDomainChange(evt, (0,_defaults2.default)({}, mutatedProps, targetProps));
      return [{target:"parent", mutation:() => mutatedProps}];
    }
    return {};
  }, onGlobalMouseUp(evt, targetProps) {
    if (!targetProps.isPanning && !targetProps.isSelecting) {
      return {};
    }
    const {x1, y1, x2, y2, isPanning, isSelecting, onBrushDomainChange, onBrushDomainChangeEnd, onBrushCleared, currentDomain, allowResize, allowDrag} = targetProps, defaultBrushArea = allowResize || targetProps.defaultBrushArea ? targetProps.defaultBrushArea : "move", mutatedProps = {isPanning:!1, isSelecting:!1};
    !allowResize && (void 0 === defaultBrushArea || "none" === defaultBrushArea) || x1 !== x2 && y1 !== y2 ? (allowDrag && isPanning || allowResize && isSelecting) && _victoryCore.Helpers.isFunction(onBrushDomainChangeEnd) && onBrushDomainChangeEnd(currentDomain, (0,_defaults2.default)({}, mutatedProps, targetProps)) : (evt = this.getDefaultBrushArea(targetProps, targetProps.cachedCurrentDomain || currentDomain, evt), mutatedProps.currentDomain = evt, _victoryCore.Helpers.isFunction(onBrushDomainChange) && 
    onBrushDomainChange(evt, (0,_defaults2.default)({}, mutatedProps, targetProps)), _victoryCore.Helpers.isFunction(onBrushDomainChangeEnd) && onBrushDomainChangeEnd(evt, (0,_defaults2.default)({}, mutatedProps, targetProps)), _victoryCore.Helpers.isFunction(onBrushCleared) && onBrushCleared(evt, (0,_defaults2.default)({}, mutatedProps, targetProps)));
    return [{target:"parent", mutation:() => mutatedProps}];
  }};
  exports.BrushHelpers = {...require, onMouseDown:require.onMouseDown.bind(require), onGlobalMouseUp:require.onGlobalMouseUp.bind(require), onGlobalMouseMove:(0,global.default)(require.onGlobalMouseMove.bind(require), 16, {leading:!0, trailing:!1})};
};

//# sourceMappingURL=module$node_modules$victory_brush_container$lib$brush_helpers.js.map
