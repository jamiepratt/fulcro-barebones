shadow$provide.module$node_modules$victory_stack$lib$helper_methods = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function fillData(props, datasets) {
    const {fillInMissingData} = props;
    props = datasets.reduce((prev, dataset) => {
      dataset.forEach(datum => {
        prev[datum._x instanceof Date ? datum._x.getTime() : datum._x] = !0;
      });
      return prev;
    }, {});
    props = Object.keys(props).map(k => Number(k));
    const xArr = (0,_orderBy2.default)(props);
    return datasets.map(dataset => {
      let indexOffset = 0;
      const isDate = dataset[0] && dataset[0]._x instanceof Date;
      return xArr.map((x, index) => {
        x = Number(x);
        if (index = dataset[index - indexOffset]) {
          if ((isDate ? index._x.getTime() : index._x) === x) {
            return index;
          }
          indexOffset++;
          index = fillInMissingData ? 0 : null;
          x = isDate ? new Date(x) : x;
          return {x, y:index, _x:x, _y:index};
        }
        index = fillInMissingData ? 0 : null;
        x = isDate ? new Date(x) : x;
        return {x, y:index, _x:x, _y:index};
      });
    });
  }
  function getY0(datum, index, datasets) {
    if (datum.y0) {
      return datum.y0;
    }
    const y = datum._y;
    var group = datum._group;
    const firstDatasetBaseline = datasets[0].map(d => d.y0);
    index = datasets.slice(0, index).reduce((prev, dataset) => prev.concat(dataset.filter(previousDatum => datum._x instanceof Date ? previousDatum._x.getTime() === datum._x.getTime() : previousDatum._x === datum._x).map(previousDatum => previousDatum._y || 0)), []);
    group = index.length && index.reduce((memo, value) => 0 > y && 0 > value || 0 <= y && 0 <= value ? Number(value) + memo : memo, firstDatasetBaseline[group] || 0);
    return index.some(point => point instanceof Date) ? new Date(group) : group;
  }
  function addLayoutData(props, datasets, index) {
    const xOffset = props.xOffset || 0;
    return datasets[index].map(datum => {
      const yOffset = getY0(datum, index, datasets) || 0;
      return Object.assign({}, datum, {_y0:datum._y instanceof Date ? yOffset ? new Date(yOffset) : datum._y : yOffset, _y1:null === datum._y ? null : datum._y instanceof Date ? new Date(Number(datum._y) + Number(yOffset)) : datum._y + yOffset, _x1:null === datum._x ? null : datum._x instanceof Date ? new Date(Number(datum._x) + Number(xOffset)) : datum._x + xOffset});
    });
  }
  function stackData(props, childComponents) {
    childComponents = _victoryCore.Wrapper.getDataFromChildren(props, childComponents).map(dataset => dataset.filter(datum => null !== datum._x && null !== datum._y));
    const datasets = fillData(props, childComponents);
    return datasets.map((d, i) => addLayoutData(props, datasets, i));
  }
  function getCalculatedProps(initialProps, childComponents) {
    var children = childComponents || _react.default.Children.toArray(initialProps.children);
    initialProps = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "stack");
    childComponents = _victoryCore.Wrapper.getStyle(initialProps.theme, initialProps.style, "stack");
    const categories = initialProps.categories || _victoryCore.Wrapper.getCategories(initialProps, children), datasets = initialProps.datasets || stackData(initialProps, children);
    children = children.map((c, i) => _react.default.cloneElement(c, {data:datasets[i]}));
    children = {x:_victoryCore.Wrapper.getDomain(Object.assign({}, initialProps, {categories}), "x", children), y:_victoryCore.Wrapper.getDomain(Object.assign({}, initialProps, {categories}), "y", children)};
    const range = initialProps.range || {x:_victoryCore.Helpers.getRange(initialProps, "x"), y:_victoryCore.Helpers.getRange(initialProps, "y")};
    var JSCompiler_object_inline_x_1150 = _victoryCore.Scale.getScaleFromProps(initialProps, "x") || _victoryCore.Wrapper.getScale(initialProps, "x"), JSCompiler_object_inline_y_1151 = _victoryCore.Scale.getScaleFromProps(initialProps, "y") || _victoryCore.Wrapper.getScale(initialProps, "y");
    JSCompiler_object_inline_x_1150 = {x:JSCompiler_object_inline_x_1150.domain(children.x).range(initialProps.horizontal ? range.y : range.x), y:JSCompiler_object_inline_y_1151.domain(children.y).range(initialProps.horizontal ? range.x : range.y)};
    const {colorScale, horizontal} = initialProps;
    return {datasets, categories, range, domain:children, horizontal, scale:JSCompiler_object_inline_x_1150, style:childComponents, colorScale, role:"stack"};
  }
  function getChildProps(props, calculatedProps) {
    const {categories, domain, range, scale, horizontal} = calculatedProps;
    return {height:props.height, width:props.width, padding:_victoryCore.Helpers.getPadding(props), standalone:!1, theme:props.theme, categories, domain, range, scale, horizontal};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getCalculatedProps = getCalculatedProps;
  exports.getChildProps = getChildProps;
  exports.getChildren = function(initialProps, childComponents, calculatedProps) {
    const props = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "stack");
    initialProps = childComponents || _react.default.Children.toArray(props.children);
    const newCalculatedProps = calculatedProps || getCalculatedProps(props, initialProps), {datasets} = newCalculatedProps, childProps = getChildProps(props, newCalculatedProps), parentName = props.name || "stack";
    return initialProps.map((child, index) => {
      var role = child.type && child.type.role;
      const data = datasets[index], style = _victoryCore.Wrapper.getChildStyle(child, index, newCalculatedProps);
      var JSCompiler_temp = props.labels ? props.labels ? datasets.length === index + 1 ? props.labels : void 0 : void 0 : child.props.labels;
      role = child.props.name || `${parentName}-${role}-${index}`;
      var JSCompiler_temp_const = _react.default, JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.cloneElement, JSCompiler_temp_const$jscomp$1 = Object, JSCompiler_temp_const$jscomp$2 = JSCompiler_temp_const$jscomp$1.assign, JSCompiler_temp_const$jscomp$3 = child.props.domainPadding || props.domainPadding, JSCompiler_temp_const$jscomp$4 = props.theme, JSCompiler_temp_const$jscomp$5 = props.labelComponent || child.props.labelComponent;
      {
        var JSCompiler_inline_result = child.type && child.type.role;
        const colorScaleOptions = child.props.colorScale || props.colorScale;
        JSCompiler_inline_result = "group" !== JSCompiler_inline_result && "stack" !== JSCompiler_inline_result ? void 0 : props.theme ? colorScaleOptions || props.theme.props.colorScale : colorScaleOptions;
      }
      return JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const, child, JSCompiler_temp_const$jscomp$2.call(JSCompiler_temp_const$jscomp$1, {key:`${role}-key-${index}`, labels:JSCompiler_temp, name:role, domainPadding:JSCompiler_temp_const$jscomp$3, theme:JSCompiler_temp_const$jscomp$4, labelComponent:JSCompiler_temp_const$jscomp$5, style, colorScale:JSCompiler_inline_result, data, polar:props.polar}, childProps));
    });
  };
  exports.useMemoizedProps = function(initialProps) {
    const modifiedProps = withoutSharedEvents(initialProps), [props, setProps] = _react.default.useState(modifiedProps);
    _react.default.useEffect(() => {
      (0,_reactFastCompare.default)(modifiedProps, props) || setProps(modifiedProps);
    }, [props, setProps, modifiedProps]);
    return _react.default.useMemo(() => getCalculatedProps(props, props.children), [props]);
  };
  var _orderBy2 = _interopRequireDefault(require("module$node_modules$lodash$orderBy")), _react = _interopRequireDefault(require("module$node_modules$react$index")), _victoryCore = require("module$node_modules$victory_core$lib$index"), _reactFastCompare = _interopRequireDefault(require("module$node_modules$react_fast_compare$index"));
  const fallbackProps = {width:450, height:300, padding:50}, withoutSharedEvents = props => {
    var {children} = props;
    children = _react.default.Children.toArray(children).map(_child => ({..._child, props:_victoryCore.Helpers.omit(_child.props, ["sharedEvents"])}));
    props.children = children;
    return props;
  };
};

//# sourceMappingURL=module$node_modules$victory_stack$lib$helper_methods.js.map
