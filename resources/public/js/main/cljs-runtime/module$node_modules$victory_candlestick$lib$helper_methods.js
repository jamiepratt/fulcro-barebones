shadow$provide.module$node_modules$victory_candlestick$lib$helper_methods = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getDomain = exports.getData = exports.getBaseProps = void 0;
  var _isPlainObject2 = _interopRequireDefault(require("module$node_modules$lodash$isPlainObject")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _victoryCore = require("module$node_modules$victory_core$lib$index");
  const TYPES = ["close", "open", "high", "low"], getData = props => _victoryCore.Data.formatData(props.data, props, ["x", "high", "low", "close", "open"]);
  exports.getData = getData;
  const reduceData = (dataset, axis, type) => {
    const yDataTypes = {min:"_low", max:"_high"}, dataType = "x" === axis ? "_x" : yDataTypes[type];
    return dataset.reduce((memo, datum) => {
      datum = datum[dataType];
      return memo < datum && "min" === type || memo > datum && "max" === type ? memo : datum;
    }, "min" === type ? Infinity : -Infinity);
  }, getDomainFromData = (props, axis) => {
    var minDomain = _victoryCore.Domain.getMinFromProps(props, axis);
    const maxDomain = _victoryCore.Domain.getMaxFromProps(props, axis);
    props = getData(props);
    if (1 > props.length) {
      return void 0 !== minDomain && void 0 !== maxDomain ? _victoryCore.Domain.getDomainFromMinMax(minDomain, maxDomain) : void 0;
    }
    minDomain = void 0 !== minDomain ? minDomain : reduceData(props, axis, "min");
    axis = void 0 !== maxDomain ? maxDomain : reduceData(props, axis, "max");
    return _victoryCore.Domain.getDomainFromMinMax(minDomain, axis);
  }, getDomain = (props, axis) => _victoryCore.Domain.createDomainFunction(getDomainFromData)(props, axis);
  exports.getDomain = getDomain;
  const getLabelStyle = (props, styleObject, namespace) => {
    styleObject = styleObject[`${namespace}Labels`] || styleObject.labels;
    return _victoryCore.Helpers.isTooltip(props[`${namespace}LabelComponent`]) ? (0,_defaults2.default)({}, (props.theme && props.theme.tooltip || {}).style, styleObject) : styleObject;
  }, formatDataFromDomain = (datum, domain) => {
    const minDomainX = _victoryCore.Collection.getMinValue(domain.x), maxDomainX = _victoryCore.Collection.getMaxValue(domain.x), minDomainY = _victoryCore.Collection.getMinValue(domain.y);
    domain = _victoryCore.Collection.getMaxValue(domain.y);
    let {_x, _low, _open, _close, _high} = datum;
    if (_x < minDomainX || _x > maxDomainX) {
      _x = null;
    }
    _low < minDomainY && _open < minDomainY && _close < minDomainY && _high < minDomainY && (_low = _open = _close = _high = null);
    _low > domain && _open > domain && _close > domain && _high > domain && (_low = _open = _close = _high = null);
    return Object.assign({}, datum, {_x, _low, _open, _close, _high});
  }, getCalculatedValues = props => {
    var {polar} = props, defaultStyle = _victoryCore.Helpers.getDefaultStyles(props, "candlestick");
    var JSCompiler_inline_result = props.style;
    void 0 === defaultStyle && (defaultStyle = {});
    if (props.disableInlineStyles) {
      JSCompiler_inline_result = {};
    } else {
      if (JSCompiler_inline_result) {
        var defaultParent = defaultStyle.parent || {}, defaultData = defaultStyle.data || {}, labelStyle = (0,_defaults2.default)({}, JSCompiler_inline_result.labels, defaultStyle.labels || {});
        JSCompiler_inline_result = {parent:(0,_defaults2.default)({}, JSCompiler_inline_result.parent, defaultParent, {width:"100%", height:"100%"}), labels:labelStyle, data:(0,_defaults2.default)({}, JSCompiler_inline_result.data, defaultData), openLabels:(0,_defaults2.default)({}, JSCompiler_inline_result.openLabels, getLabelStyle(props, defaultStyle, "open"), labelStyle), closeLabels:(0,_defaults2.default)({}, JSCompiler_inline_result.closeLabels, getLabelStyle(props, defaultStyle, "close"), labelStyle), 
        lowLabels:(0,_defaults2.default)({}, JSCompiler_inline_result.lowLabels, getLabelStyle(props, defaultStyle, "low"), labelStyle), highLabels:(0,_defaults2.default)({}, JSCompiler_inline_result.highLabels, getLabelStyle(props, defaultStyle, "high"), labelStyle)};
      } else {
        JSCompiler_inline_result = (0,_defaults2.default)({parent:{height:"100%", width:"100%"}}, defaultStyle);
      }
    }
    defaultStyle = getData(props);
    defaultData = _victoryCore.Helpers.getRange(props, "x");
    labelStyle = _victoryCore.Helpers.getRange(props, "y");
    defaultParent = {x:getDomain(props, "x"), y:getDomain(props, "y")};
    defaultData = {x:_victoryCore.Scale.getBaseScale(props, "x").domain(defaultParent.x).range(props.horizontal ? labelStyle : defaultData), y:_victoryCore.Scale.getBaseScale(props, "y").domain(defaultParent.y).range(props.horizontal ? defaultData : labelStyle)};
    polar = polar ? props.origin || _victoryCore.Helpers.getPolarOrigin(props) : void 0;
    labelStyle = props.horizontal ? "top" : "right";
    return {domain:defaultParent, data:defaultStyle, scale:defaultData, style:JSCompiler_inline_result, origin:polar, labelOrientation:props.labelOrientation || labelStyle};
  }, getDataStyles = function(datum, style, props) {
    void 0 === style && (style = {});
    if (props.disableInlineStyles) {
      return {};
    }
    datum = datum._open > datum._close ? props.candleColors.negative : props.candleColors.positive;
    datum = style.fill || datum;
    props = style.stroke;
    return Object.assign({}, style, {stroke:"none" === props || "transparent" === props ? datum : props || "black", fill:datum});
  }, getCandleWidth = (props, style) => {
    const {data, candleWidth, scale} = props;
    if (candleWidth) {
      return _victoryCore.Helpers.isFunction(candleWidth) ? _victoryCore.Helpers.evaluateProp(candleWidth, props) : candleWidth;
    }
    if (style && style.width) {
      return style.width;
    }
    style = scale.x.range();
    style = Math.abs(style[1] - style[0]);
    const candles = data.length + 2;
    return Math.max(1, (props.candleRatio || 0.5) * (2 > data.length ? 8 : style / candles));
  }, getLabelProps = (props, text, style, type) => {
    const {x:x$jscomp$0, high, low, open, close, index, scale, datum, data, horizontal:horizontal$jscomp$0, candleWidth:candleWidth$jscomp$0, labelOrientation, theme} = props;
    props = props[`${type}LabelComponent`] || props.labelComponent;
    var defaultOrientation = horizontal$jscomp$0 ? "top" : "right", JSCompiler_temp;
    (JSCompiler_temp = props.props && props.props.orientation) || (JSCompiler_temp = type, void 0 === JSCompiler_temp && (JSCompiler_temp = "labels"), JSCompiler_temp = (0,_isPlainObject2.default)(labelOrientation) ? labelOrientation[JSCompiler_temp] : labelOrientation);
    defaultOrientation = JSCompiler_temp || defaultOrientation;
    style = style[type ? `${type}Labels` : "labels"] || style.labels;
    JSCompiler_temp = {top:"end", bottom:"start", left:"middle", right:"middle"};
    const defaultTextAnchors = {left:"end", right:"start", top:"middle", bottom:"middle"};
    {
      const {positions, labelStyle, x, horizontal, computedType, candleWidth, orientation} = {positions:{high, low, open, close}, labelStyle:style, x:x$jscomp$0, horizontal:horizontal$jscomp$0, computedType:type ? type : "labels", candleWidth:candleWidth$jscomp$0, orientation:defaultOrientation};
      positions.labels = (positions.open + positions.close) / 2;
      type = "left" === orientation ? -1 : 1;
      const signY = "top" === orientation ? -1 : 1;
      type = horizontal ? {yValue:x, xValue:positions[computedType], dx:"top" === orientation || "bottom" === orientation ? 0 : type * (labelStyle.padding || 1), dy:"top" === orientation || "bottom" === orientation ? candleWidth / 2 * signY + signY * (labelStyle.padding || 0) : 0} : {yValue:positions[computedType], xValue:x, dx:"top" === orientation || "bottom" === orientation ? 0 : candleWidth / 2 * type + type * (labelStyle.padding || 0), dy:"top" === orientation || "bottom" === orientation ? signY * 
      (labelStyle.padding || 1) : 0};
    }
    const {yValue, xValue, dx, dy} = type;
    text = {style, y:yValue, x:xValue, dx, dy, text, index, scale, datum, data, orientation:defaultOrientation, textAnchor:style.textAnchor || defaultTextAnchors[defaultOrientation], verticalAnchor:style.verticalAnchor || JSCompiler_temp[defaultOrientation], angle:style.angle, horizontal:horizontal$jscomp$0};
    return _victoryCore.Helpers.isTooltip(props) ? (0,_defaults2.default)({}, text, _victoryCore.Helpers.omit(theme && theme.tooltip || {}, ["style"])) : text;
  };
  exports.getBaseProps = (initialProps, fallbackProps) => {
    const props = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "candlestick");
    initialProps = getCalculatedValues(props);
    const {data, style, scale, domain, origin, labelOrientation} = initialProps, {groupComponent, width, height, padding, standalone, name, candleWidth, candleRatio, theme, polar, wickStrokeWidth, labels, events, sharedEvents, horizontal, disableInlineStyles} = props;
    return data.reduce((childProps, datum, index) => {
      const eventKey = _victoryCore.Helpers.isNil(datum.eventKey) ? index : datum.eventKey;
      var x = scale.x(void 0 !== datum._x1 ? datum._x1 : datum._x);
      datum = formatDataFromDomain(datum, domain);
      const {_low, _open, _close, _high} = datum, high = scale.y(_high), close = scale.y(_close), open = scale.y(_open), low = scale.y(_low), dataStyle = getDataStyles(datum, style.data, props);
      x = {x, high, low, candleWidth, candleRatio, scale, data, datum, groupComponent, index, style:dataStyle, width, polar, origin, wickStrokeWidth, open, close, horizontal, labelOrientation, disableInlineStyles};
      x.candleWidth = getCandleWidth(x);
      const extendedProps = (0,_defaults2.default)(Object.assign({}, x), props);
      childProps[eventKey] = {data:x};
      labels && (index = _victoryCore.LabelHelpers.getText(props, datum, index), void 0 !== index && null !== index || labels && (events || sharedEvents)) && (childProps[eventKey].labels = getLabelProps(extendedProps, index, style));
      TYPES.forEach(type => {
        {
          const {datum, index, labels} = extendedProps;
          var JSCompiler_inline_result = (JSCompiler_inline_result = extendedProps[`${type}Labels`]) || labels ? !0 === JSCompiler_inline_result || !0 === labels ? `${datum[`_${type}`]}` : Array.isArray(JSCompiler_inline_result) ? JSCompiler_inline_result[index] : JSCompiler_inline_result : null;
        }
        const labelProp = props.labels || props[`${type}Labels`];
        if (null !== JSCompiler_inline_result && void 0 !== JSCompiler_inline_result || labelProp && (events || sharedEvents)) {
          childProps[eventKey][`${type}Labels`] = getLabelProps(extendedProps, JSCompiler_inline_result, style, type);
        }
      });
      return childProps;
    }, {parent:{domain, scale, width, height, data, standalone, theme, polar, origin, name, style:style.parent, padding, horizontal}});
  };
};

//# sourceMappingURL=module$node_modules$victory_candlestick$lib$helper_methods.js.map
