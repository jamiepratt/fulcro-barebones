shadow$provide.module$node_modules$victory_pie$lib$helper_methods = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getYOffsetMultiplayerByAngle = exports.getYOffset = exports.getXOffsetMultiplayerByAngle = exports.getXOffset = exports.getLabelIndicatorPropsForLineSegment = exports.getBaseProps = exports.getAverage = void 0;
  var _isPlainObject2 = _interopRequireDefault(require("module$node_modules$lodash$isPlainObject")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), d3Shape = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$victory_vendor$lib$d3_shape")), _victoryCore = require("module$node_modules$victory_core$lib$index");
  const getSlices = (props, data) => {
    const padAngle = _victoryCore.Helpers.isFunction(props.padAngle) ? 0 : props.padAngle;
    return d3Shape.pie().sort(null).startAngle(_victoryCore.Helpers.degreesToRadians(props.startAngle)).endAngle(_victoryCore.Helpers.degreesToRadians(props.endAngle)).padAngle(_victoryCore.Helpers.degreesToRadians(padAngle)).value(datum => datum._y)(data);
  }, getCalculatedValues = props => {
    var {colorScale} = props, styleObject = _victoryCore.Helpers.getDefaultStyles(props, "pie");
    styleObject = _victoryCore.Helpers.getStyles(props.style, styleObject);
    colorScale = Array.isArray(colorScale) ? colorScale : _victoryCore.Style.getColorScale(colorScale);
    const padding = _victoryCore.Helpers.getPadding(props);
    var JSCompiler_inline_result = "number" === typeof props.radius ? props.radius : Math.min(props.width - padding.left - padding.right, props.height - padding.top - padding.bottom) / 2;
    const {width, height} = props;
    var JSCompiler_inline_result$jscomp$0 = (0,_isPlainObject2.default)(props.origin) ? props.origin : {};
    JSCompiler_inline_result$jscomp$0 = {x:void 0 !== JSCompiler_inline_result$jscomp$0.x ? JSCompiler_inline_result$jscomp$0.x : (padding.left - padding.right + width) / 2, y:void 0 !== JSCompiler_inline_result$jscomp$0.y ? JSCompiler_inline_result$jscomp$0.y : (padding.top - padding.bottom + height) / 2};
    const data = _victoryCore.Data.getData(props), slices = getSlices(props, data);
    return Object.assign({}, props, {style:styleObject, colors:colorScale, padding, defaultRadius:JSCompiler_inline_result, data, slices, origin:JSCompiler_inline_result$jscomp$0});
  }, getXOffsetMultiplayerByAngle = angle => Math.cos(angle - _victoryCore.Helpers.degreesToRadians(90));
  exports.getXOffsetMultiplayerByAngle = getXOffsetMultiplayerByAngle;
  const getYOffsetMultiplayerByAngle = angle => Math.sin(angle - _victoryCore.Helpers.degreesToRadians(90));
  exports.getYOffsetMultiplayerByAngle = getYOffsetMultiplayerByAngle;
  exports.getXOffset = (offset, angle) => offset * getXOffsetMultiplayerByAngle(angle);
  exports.getYOffset = (offset, angle) => offset * getYOffsetMultiplayerByAngle(angle);
  const getAverage = array => array.reduce((acc, cur) => acc + cur, 0) / array.length;
  exports.getAverage = getAverage;
  const getLabelIndicatorPropsForLineSegment = (props, calculatedValues, labelProps) => {
    const {innerRadius, radius, slice:{startAngle, endAngle}, labelIndicatorInnerOffset, labelIndicatorOuterOffset, index} = props, {height, width} = calculatedValues;
    var {calculatedLabelRadius} = labelProps, middleRadius = getAverage([innerRadius, radius]);
    props = getAverage([endAngle, startAngle]);
    labelProps = width / 2;
    calculatedValues = height / 2;
    var innerOffset = middleRadius + labelIndicatorInnerOffset;
    middleRadius = calculatedLabelRadius - labelIndicatorOuterOffset;
    calculatedLabelRadius = labelProps + innerOffset * getXOffsetMultiplayerByAngle(props);
    innerOffset = calculatedValues + innerOffset * getYOffsetMultiplayerByAngle(props);
    labelProps += middleRadius * getXOffsetMultiplayerByAngle(props);
    props = calculatedValues + middleRadius * getYOffsetMultiplayerByAngle(props);
    return (0,_defaults2.default)({}, {x1:calculatedLabelRadius, y1:innerOffset, x2:labelProps, y2:props, index});
  };
  exports.getLabelIndicatorPropsForLineSegment = getLabelIndicatorPropsForLineSegment;
  exports.getBaseProps = (initialProps, fallbackProps) => {
    const props = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "pie"), calculatedValues = getCalculatedValues(props), {slices, style, data, origin, defaultRadius, labels, events, sharedEvents, height, width, standalone, name, innerRadius, cornerRadius, padAngle, disableInlineStyles, labelIndicator} = calculatedValues, radius = props.radius || defaultRadius;
    return slices.reduce((childProps, slice$jscomp$0, index) => {
      var datum$jscomp$0 = (0,_defaults2.default)({}, data[index], {startAngle:_victoryCore.Helpers.radiansToDegrees(slice$jscomp$0.startAngle), endAngle:_victoryCore.Helpers.radiansToDegrees(slice$jscomp$0.endAngle), padAngle:_victoryCore.Helpers.radiansToDegrees(slice$jscomp$0.padAngle)});
      const eventKey = _victoryCore.Helpers.isNil(datum$jscomp$0.eventKey) ? index : datum$jscomp$0.eventKey;
      if (disableInlineStyles) {
        var JSCompiler_temp = {};
      } else {
        const {style, colors} = calculatedValues;
        JSCompiler_temp = Object.assign({fill:style && style.data && style.data.fill ? style.data.fill : colors && colors[index % colors.length]}, style.data);
      }
      slice$jscomp$0 = {index, slice:slice$jscomp$0, datum:datum$jscomp$0, data, origin, innerRadius, radius, cornerRadius, padAngle, style:JSCompiler_temp, disableInlineStyles};
      childProps[eventKey] = {data:slice$jscomp$0};
      index = datum$jscomp$0.label ? datum$jscomp$0.label : Array.isArray(props.labels) ? props.labels[index] : _victoryCore.Helpers.isFunction(props.labels) ? props.labels : datum$jscomp$0.xName || datum$jscomp$0._x;
      index = void 0 === index || null === index || _victoryCore.Helpers.isFunction(index) ? index : `${index}`;
      if (void 0 !== index && null !== index || labels && (events || sharedEvents)) {
        datum$jscomp$0 = _victoryCore.Helpers.evaluateProp(index, slice$jscomp$0);
        index = childProps[eventKey];
        {
          var dataProps = Object.assign({}, props, slice$jscomp$0);
          const {index, datum, data, slice, labelComponent, theme} = dataProps, {style, defaultRadius, origin, width, height} = calculatedValues;
          var labelRadius = _victoryCore.Helpers.evaluateProp(calculatedValues.labelRadius, Object.assign({text:datum$jscomp$0}, dataProps)), labelPosition = _victoryCore.Helpers.evaluateProp(calculatedValues.labelPosition, Object.assign({text:datum$jscomp$0}, dataProps)) || "centroid";
          JSCompiler_temp = _victoryCore.Helpers.evaluateProp(calculatedValues.labelPlacement, Object.assign({text:datum$jscomp$0}, dataProps)) || "vertical";
          const labelStyle = Object.assign({padding:0}, style.labels);
          dataProps = (dataProps = _victoryCore.Helpers.evaluateStyle(labelStyle, Object.assign({labelRadius, text:datum$jscomp$0}, dataProps))) && dataProps.padding || 0;
          labelRadius = labelRadius || defaultRadius + dataProps;
          dataProps = d3Shape.arc().outerRadius(labelRadius).innerRadius(labelRadius);
          var clonedArc = Object.assign({}, slice, {startAngle:"startAngle" === labelPosition ? slice.startAngle : slice.endAngle, endAngle:"endAngle" === labelPosition ? slice.endAngle : slice.startAngle});
          dataProps = dataProps.centroid(clonedArc);
          labelPosition = void 0 !== labelPosition.angle ? labelStyle.angle : "centroid" === labelPosition ? _victoryCore.Helpers.radiansToDegrees((slice.startAngle + slice.endAngle) / 2) : "startAngle" === labelPosition ? _victoryCore.Helpers.radiansToDegrees(slice.startAngle) : _victoryCore.Helpers.radiansToDegrees(slice.endAngle);
          labelPosition = (0 > labelPosition ? 360 - labelPosition : labelPosition) % 360;
          clonedArc = "perpendicular" === JSCompiler_temp ? 90 < labelPosition && 270 > labelPosition ? "bottom" : "top" : "parallel" === JSCompiler_temp ? 0 <= labelPosition && 180 >= labelPosition ? "right" : "left" : 45 > labelPosition || 315 < labelPosition ? "top" : 45 <= labelPosition && 135 > labelPosition ? "right" : 135 <= labelPosition && 225 > labelPosition ? "bottom" : "left";
          datum$jscomp$0 = {width, height, index, datum, data, slice, orientation:clonedArc, text:datum$jscomp$0, style:labelStyle, x:Math.round(dataProps[0]) + origin.x, y:Math.round(dataProps[1]) + origin.y, textAnchor:labelStyle.textAnchor || ("top" === clonedArc || "bottom" === clonedArc ? "middle" : "right" === clonedArc ? "start" : "end"), verticalAnchor:labelStyle.verticalAnchor || ("left" === clonedArc || "right" === clonedArc ? "middle" : "bottom" === clonedArc ? "start" : "end"), angle:"vertical" === 
          JSCompiler_temp ? 0 : "parallel" === JSCompiler_temp ? 180 < labelPosition && 360 > labelPosition ? labelPosition + 90 : labelPosition - 90 : 90 < labelPosition && 270 > labelPosition ? labelPosition - 180 : labelPosition, calculatedLabelRadius:labelRadius};
          datum$jscomp$0 = _victoryCore.Helpers.isTooltip(labelComponent) ? (0,_defaults2.default)({}, datum$jscomp$0, _victoryCore.Helpers.omit(theme && theme.tooltip || {}, ["style"])) : datum$jscomp$0;
        }
        index.labels = datum$jscomp$0;
        labelIndicator && (index = childProps[eventKey].labels, index.calculatedLabelRadius > radius && (childProps[eventKey].labelIndicators = getLabelIndicatorPropsForLineSegment(Object.assign({}, props, slice$jscomp$0), calculatedValues, index)));
      }
      return childProps;
    }, {parent:{standalone, height, width, slices, name, style:style.parent}});
  };
};

//# sourceMappingURL=module$node_modules$victory_pie$lib$helper_methods.js.map
