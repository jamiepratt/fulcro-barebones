shadow$provide.module$node_modules$victory_core$lib$victory_animation$victory_animation = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.VictoryAnimation = void 0;
  var _react = _interopRequireDefault(require("module$node_modules$react$index")), d3Ease = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$victory_vendor$lib$d3_ease")), _util = require("module$node_modules$victory_core$lib$victory_animation$util"), _timerContext = _interopRequireDefault(require("module$node_modules$victory_core$lib$victory_util$timer_context"));
  const formatAnimationName = name => `ease${name.charAt(0).toUpperCase() + name.slice(1)}`;
  exports.VictoryAnimation = _ref => {
    let {duration = 1000, easing = "quadInOut", delay = 0, data, children, onEnd} = _ref;
    const [state, setState] = _react.default.useState({data:Array.isArray(data) ? data[0] : data, animationInfo:{progress:0, animating:!1}}), timer = _react.default.useContext(_timerContext.default).animationTimer, queue = _react.default.useRef(Array.isArray(data) ? data.slice(1) : []), interpolator = _react.default.useRef(null), loopID = _react.default.useRef(void 0), ease = d3Ease[formatAnimationName(easing)];
    _react.default.useEffect(() => {
      queue.current.length && traverseQueue();
      return () => {
        loopID.current ? timer.unsubscribe(loopID.current) : timer.stop();
      };
    }, []);
    _react.default.useEffect(() => {
      interpolator.current && state.animationInfo && 1 > state.animationInfo.progress ? setState({data:interpolator.current(1), animationInfo:{progress:1, animating:!1, terminating:!0}}) : (timer.unsubscribe(loopID.current), queue.current = Array.isArray(data) ? data : [data], traverseQueue());
    }, [data]);
    const traverseQueue = () => {
      queue.current.length ? (interpolator.current = (0,_util.victoryInterpolator)(state.data, queue.current[0]), delay ? setTimeout(() => {
        loopID.current = timer.subscribe(functionToBeRunEachFrame, duration);
      }, delay) : loopID.current = timer.subscribe(functionToBeRunEachFrame, duration)) : onEnd && onEnd();
    }, functionToBeRunEachFrame = elapsed => {
      interpolator.current && (elapsed = duration ? elapsed / duration : 1, 1 <= elapsed ? (setState({data:interpolator.current(1), animationInfo:{progress:1, animating:!1, terminating:!0}}), loopID.current && timer.unsubscribe(loopID.current), queue.current.shift(), traverseQueue()) : setState({data:interpolator.current(ease(elapsed)), animationInfo:{progress:elapsed, animating:1 > elapsed}}));
    };
    return children(state.data, state.animationInfo);
  };
};

//# sourceMappingURL=module$node_modules$victory_core$lib$victory_animation$victory_animation.js.map
