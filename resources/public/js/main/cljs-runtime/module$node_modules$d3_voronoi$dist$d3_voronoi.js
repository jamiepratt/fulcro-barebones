shadow$provide.module$node_modules$d3_voronoi$dist$d3_voronoi = function(global, require, module, exports) {
  (function(global, factory) {
    "object" === typeof exports && "undefined" !== typeof module ? factory(exports) : "function" === typeof define && define.amd ? define(["exports"], factory) : factory(global.d3 = global.d3 || {});
  })(this, function(exports) {
    function constant(x) {
      return function() {
        return x;
      };
    }
    function x(d) {
      return d[0];
    }
    function y(d) {
      return d[1];
    }
    function RedBlackTree() {
      this._ = null;
    }
    function RedBlackNode(node) {
      node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    function RedBlackRotateLeft(tree, node) {
      var q = node.R, parent = node.U;
      parent ? parent.L === node ? parent.L = q : parent.R = q : tree._ = q;
      q.U = parent;
      node.U = q;
      node.R = q.L;
      node.R && (node.R.U = node);
      q.L = node;
    }
    function RedBlackRotateRight(tree, node) {
      var q = node.L, parent = node.U;
      parent ? parent.L === node ? parent.L = q : parent.R = q : tree._ = q;
      q.U = parent;
      node.U = q;
      node.L = q.R;
      node.L && (node.L.U = node);
      q.R = node;
    }
    function RedBlackFirst(node) {
      for (; node.L;) {
        node = node.L;
      }
      return node;
    }
    function createEdge(left, right, v0, v1) {
      var edge = [null, null], index = edges.push(edge) - 1;
      edge.left = left;
      edge.right = right;
      v0 && setEdgeEnd(edge, left, right, v0);
      v1 && setEdgeEnd(edge, right, left, v1);
      cells[left.index].halfedges.push(index);
      cells[right.index].halfedges.push(index);
      return edge;
    }
    function createBorderEdge(left, v0, v1) {
      v0 = [v0, v1];
      v0.left = left;
      return v0;
    }
    function setEdgeEnd(edge, left, right, vertex) {
      edge[0] || edge[1] ? edge.left === right ? edge[1] = vertex : edge[0] = vertex : (edge[0] = vertex, edge.left = left, edge.right = right);
    }
    function clipEdge(edge, x0, y0, x1, y1) {
      var a = edge[0], b = edge[1], ax = a[0];
      a = a[1];
      var t0 = 0, t1 = 1, dx = b[0] - ax;
      b = b[1] - a;
      x0 -= ax;
      if (dx || !(0 < x0)) {
        x0 /= dx;
        if (0 > dx) {
          if (x0 < t0) {
            return;
          }
          x0 < t1 && (t1 = x0);
        } else if (0 < dx) {
          if (x0 > t1) {
            return;
          }
          x0 > t0 && (t0 = x0);
        }
        x0 = x1 - ax;
        if (dx || !(0 > x0)) {
          x0 /= dx;
          if (0 > dx) {
            if (x0 > t1) {
              return;
            }
            x0 > t0 && (t0 = x0);
          } else if (0 < dx) {
            if (x0 < t0) {
              return;
            }
            x0 < t1 && (t1 = x0);
          }
          x0 = y0 - a;
          if (b || !(0 < x0)) {
            x0 /= b;
            if (0 > b) {
              if (x0 < t0) {
                return;
              }
              x0 < t1 && (t1 = x0);
            } else if (0 < b) {
              if (x0 > t1) {
                return;
              }
              x0 > t0 && (t0 = x0);
            }
            x0 = y1 - a;
            if (b || !(0 > x0)) {
              x0 /= b;
              if (0 > b) {
                if (x0 > t1) {
                  return;
                }
                x0 > t0 && (t0 = x0);
              } else if (0 < b) {
                if (x0 < t0) {
                  return;
                }
                x0 < t1 && (t1 = x0);
              }
              if (!(0 < t0 || 1 > t1)) {
                return !0;
              }
              0 < t0 && (edge[0] = [ax + t0 * dx, a + t0 * b]);
              1 > t1 && (edge[1] = [ax + t1 * dx, a + t1 * b]);
              return !0;
            }
          }
        }
      }
    }
    function connectEdge(edge, x0, y0, x1, y1) {
      var v1 = edge[1];
      if (v1) {
        return !0;
      }
      var v0 = edge[0], left = edge.left, right = edge.right;
      v1 = left[0];
      left = left[1];
      var rx = right[0];
      right = right[1];
      var fx = (v1 + rx) / 2;
      if (right === left) {
        if (fx < x0 || fx >= x1) {
          return;
        }
        if (v1 > rx) {
          if (!v0) {
            v0 = [fx, y0];
          } else if (v0[1] >= y1) {
            return;
          }
          v1 = [fx, y1];
        } else {
          if (!v0) {
            v0 = [fx, y1];
          } else if (v0[1] < y0) {
            return;
          }
          v1 = [fx, y0];
        }
      } else {
        var fm = (v1 - rx) / (right - left);
        fx = (left + right) / 2 - fm * fx;
        if (-1 > fm || 1 < fm) {
          if (v1 > rx) {
            if (!v0) {
              v0 = [(y0 - fx) / fm, y0];
            } else if (v0[1] >= y1) {
              return;
            }
            v1 = [(y1 - fx) / fm, y1];
          } else {
            if (!v0) {
              v0 = [(y1 - fx) / fm, y1];
            } else if (v0[1] < y0) {
              return;
            }
            v1 = [(y0 - fx) / fm, y0];
          }
        } else {
          if (left < right) {
            if (!v0) {
              v0 = [x0, fm * x0 + fx];
            } else if (v0[0] >= x1) {
              return;
            }
            v1 = [x1, fm * x1 + fx];
          } else {
            if (!v0) {
              v0 = [x1, fm * x1 + fx];
            } else if (v0[0] < x0) {
              return;
            }
            v1 = [x0, fm * x0 + fx];
          }
        }
      }
      edge[0] = v0;
      edge[1] = v1;
      return !0;
    }
    function cellHalfedgeAngle(cell, edge) {
      cell = cell.site;
      var va = edge.left, vb = edge.right;
      cell === vb && (vb = va, va = cell);
      if (vb) {
        return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
      }
      cell === va ? (va = edge[1], vb = edge[0]) : (va = edge[0], vb = edge[1]);
      return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
    }
    function cellHalfedgeStart(cell, edge) {
      return edge[+(edge.left !== cell.site)];
    }
    function sortCellHalfedges() {
      for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
        if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
          var index = Array(m), array = Array(m);
          for (j = 0; j < m; ++j) {
            index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
          }
          index.sort(function(i, j) {
            return array[j] - array[i];
          });
          for (j = 0; j < m; ++j) {
            array[j] = halfedges[index[j]];
          }
          for (j = 0; j < m; ++j) {
            halfedges[j] = array[j];
          }
        }
      }
    }
    function Circle() {
      RedBlackNode(this);
      this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function attachCircle(arc) {
      var lArc = arc.P, rArc = arc.N;
      if (lArc && rArc) {
        var lSite = lArc.site;
        lArc = arc.site;
        var rSite = rArc.site;
        if (lSite !== rSite) {
          rArc = lArc[0];
          var by = lArc[1], ax = lSite[0] - rArc, ay = lSite[1] - by;
          lSite = rSite[0] - rArc;
          var cy = rSite[1] - by;
          rSite = 2 * (ax * cy - ay * lSite);
          if (!(rSite >= -epsilon2)) {
            var ha = ax * ax + ay * ay, hc = lSite * lSite + cy * cy;
            ay = (cy * ha - ay * hc) / rSite;
            lSite = (ax * hc - lSite * ha) / rSite;
            ax = circlePool.pop() || new Circle();
            ax.arc = arc;
            ax.site = lArc;
            ax.x = ay + rArc;
            ax.y = (ax.cy = lSite + by) + Math.sqrt(ay * ay + lSite * lSite);
            arc.circle = ax;
            arc = null;
            for (lArc = circles._; lArc;) {
              if (ax.y < lArc.y || ax.y === lArc.y && ax.x <= lArc.x) {
                if (lArc.L) {
                  lArc = lArc.L;
                } else {
                  arc = lArc.P;
                  break;
                }
              } else {
                if (lArc.R) {
                  lArc = lArc.R;
                } else {
                  arc = lArc;
                  break;
                }
              }
            }
            circles.insert(arc, ax);
            arc || (firstCircle = ax);
          }
        }
      }
    }
    function detachCircle(arc) {
      var circle = arc.circle;
      circle && (circle.P || (firstCircle = circle.N), circles.remove(circle), circlePool.push(circle), RedBlackNode(circle), arc.circle = null);
    }
    function Beach() {
      RedBlackNode(this);
      this.edge = this.site = this.circle = null;
    }
    function createBeach(site) {
      var beach = beachPool.pop() || new Beach();
      beach.site = site;
      return beach;
    }
    function detachBeach(beach) {
      detachCircle(beach);
      beaches.remove(beach);
      beachPool.push(beach);
      RedBlackNode(beach);
    }
    function leftBreakPoint(arc, directrix) {
      var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
      if (!pby2) {
        return rfocx;
      }
      arc = arc.P;
      if (!arc) {
        return -Infinity;
      }
      site = arc.site;
      arc = site[0];
      site = site[1];
      directrix = site - directrix;
      if (!directrix) {
        return arc;
      }
      var hl = arc - rfocx, aby2 = 1 / pby2 - 1 / directrix, b = hl / directrix;
      return aby2 ? (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * directrix) - site + directrix / 2 + rfocy - pby2 / 2))) / aby2 + rfocx : (rfocx + arc) / 2;
    }
    function lexicographic(a, b) {
      return b[1] - a[1] || b[0] - a[0];
    }
    function Diagram(sites, extent) {
      var site = sites.sort(lexicographic).pop(), x;
      edges = [];
      cells = Array(sites.length);
      beaches = new RedBlackTree();
      for (circles = new RedBlackTree();;) {
        var circle = firstCircle;
        if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
          if (site[0] !== x || site[1] !== y) {
            var y = x = void 0;
            circle = site;
            for (var x$jscomp$0 = circle[0], directrix = circle[1], node = beaches._; node;) {
              var dxl = leftBreakPoint(node, directrix) - x$jscomp$0;
              if (dxl > epsilon) {
                node = node.L;
              } else {
                var arc = node;
                var dxr = directrix;
                var rArc = arc.N;
                rArc ? dxr = leftBreakPoint(rArc, dxr) : (arc = arc.site, dxr = arc[1] === dxr ? arc[0] : Infinity);
                dxr = x$jscomp$0 - dxr;
                if (dxr > epsilon) {
                  if (!node.R) {
                    y = node;
                    break;
                  }
                  node = node.R;
                } else {
                  dxl > -epsilon ? (y = node.P, x = node) : dxr > -epsilon ? (y = node, x = node.N) : y = x = node;
                  break;
                }
              }
            }
            cells[circle.index] = {site:circle, halfedges:[]};
            dxl = createBeach(circle);
            beaches.insert(y, dxl);
            if (y || x) {
              if (y === x) {
                detachCircle(y), x = createBeach(y.site), beaches.insert(dxl, x), dxl.edge = x.edge = createEdge(y.site, dxl.site), attachCircle(y), attachCircle(x);
              } else {
                if (x) {
                  detachCircle(y);
                  detachCircle(x);
                  x$jscomp$0 = y.site;
                  node = x$jscomp$0[0];
                  dxr = x$jscomp$0[1];
                  arc = circle[0] - node;
                  rArc = circle[1] - dxr;
                  directrix = x.site;
                  var cx = directrix[0] - node, cy = directrix[1] - dxr, d = 2 * (arc * cy - rArc * cx), hb = arc * arc + rArc * rArc, hc = cx * cx + cy * cy;
                  node = [(cy * hb - rArc * hc) / d + node, (arc * hc - cx * hb) / d + dxr];
                  setEdgeEnd(x.edge, x$jscomp$0, directrix, node);
                  dxl.edge = createEdge(x$jscomp$0, circle, null, node);
                  x.edge = createEdge(circle, directrix, null, node);
                  attachCircle(y);
                  attachCircle(x);
                } else {
                  dxl.edge = createEdge(y.site, dxl.site);
                }
              }
            }
            x = site[0];
            y = site[1];
          }
          site = sites.pop();
        } else if (circle) {
          directrix = circle.arc;
          circle = directrix.circle;
          x$jscomp$0 = circle.x;
          node = circle.cy;
          circle = [x$jscomp$0, node];
          arc = directrix.P;
          dxr = directrix.N;
          dxl = [directrix];
          detachBeach(directrix);
          for (directrix = arc; directrix.circle && Math.abs(x$jscomp$0 - directrix.circle.x) < epsilon && Math.abs(node - directrix.circle.cy) < epsilon;) {
            arc = directrix.P, dxl.unshift(directrix), detachBeach(directrix), directrix = arc;
          }
          dxl.unshift(directrix);
          detachCircle(directrix);
          for (arc = dxr; arc.circle && Math.abs(x$jscomp$0 - arc.circle.x) < epsilon && Math.abs(node - arc.circle.cy) < epsilon;) {
            dxr = arc.N, dxl.push(arc), detachBeach(arc), arc = dxr;
          }
          dxl.push(arc);
          detachCircle(arc);
          node = dxl.length;
          for (x$jscomp$0 = 1; x$jscomp$0 < node; ++x$jscomp$0) {
            arc = dxl[x$jscomp$0], directrix = dxl[x$jscomp$0 - 1], setEdgeEnd(arc.edge, directrix.site, arc.site, circle);
          }
          directrix = dxl[0];
          arc = dxl[node - 1];
          arc.edge = createEdge(directrix.site, arc.site, null, circle);
          attachCircle(directrix);
          attachCircle(arc);
        } else {
          break;
        }
      }
      sortCellHalfedges();
      if (extent) {
        x = +extent[0][0];
        sites = +extent[0][1];
        site = +extent[1][0];
        extent = +extent[1][1];
        y = edges.length;
        for (var edge; y--;) {
          connectEdge(edge = edges[y], x, sites, site, extent) && clipEdge(edge, x, sites, site, extent) && (Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon) || delete edges[y];
        }
        edge = cells.length;
        y = !0;
        for (circle = 0; circle < edge; ++circle) {
          if (dxl = cells[circle]) {
            var site$jscomp$0 = dxl.site;
            directrix = dxl.halfedges;
            for (x$jscomp$0 = directrix.length; x$jscomp$0--;) {
              edges[directrix[x$jscomp$0]] || directrix.splice(x$jscomp$0, 1);
            }
            x$jscomp$0 = 0;
            for (node = directrix.length; x$jscomp$0 < node;) {
              if (dxr = edges[directrix[x$jscomp$0]], arc = dxr[+(dxr.left === dxl.site)], rArc = arc[0], cx = arc[1], cy = cellHalfedgeStart(dxl, edges[directrix[++x$jscomp$0 % node]]), dxr = cy[0], cy = cy[1], Math.abs(rArc - dxr) > epsilon || Math.abs(cx - cy) > epsilon) {
                directrix.splice(x$jscomp$0, 0, edges.push(createBorderEdge(site$jscomp$0, arc, Math.abs(rArc - x) < epsilon && extent - cx > epsilon ? [x, Math.abs(dxr - x) < epsilon ? cy : extent] : Math.abs(cx - extent) < epsilon && site - rArc > epsilon ? [Math.abs(cy - extent) < epsilon ? dxr : site, extent] : Math.abs(rArc - site) < epsilon && cx - sites > epsilon ? [site, Math.abs(dxr - site) < epsilon ? cy : sites] : Math.abs(cx - sites) < epsilon && rArc - x > epsilon ? [Math.abs(cy - sites) < 
                epsilon ? dxr : x, sites] : null)) - 1), ++node;
              }
            }
            node && (y = !1);
          }
        }
        if (y) {
          x$jscomp$0 = Infinity;
          circle = 0;
          for (y = null; circle < edge; ++circle) {
            if (dxl = cells[circle]) {
              site$jscomp$0 = dxl.site, directrix = site$jscomp$0[0] - x, node = site$jscomp$0[1] - sites, directrix = directrix * directrix + node * node, directrix < x$jscomp$0 && (x$jscomp$0 = directrix, y = dxl);
            }
          }
          y && (circle = [x, sites], x = [x, extent], extent = [site, extent], sites = [site, sites], y.halfedges.push(edges.push(createBorderEdge(site$jscomp$0 = y.site, circle, x)) - 1, edges.push(createBorderEdge(site$jscomp$0, x, extent)) - 1, edges.push(createBorderEdge(site$jscomp$0, extent, sites)) - 1, edges.push(createBorderEdge(site$jscomp$0, sites, circle)) - 1));
        }
        for (circle = 0; circle < edge; ++circle) {
          if (dxl = cells[circle]) {
            dxl.halfedges.length || delete cells[circle];
          }
        }
      }
      this.edges = edges;
      this.cells = cells;
      beaches = circles = edges = cells = null;
    }
    RedBlackTree.prototype = {constructor:RedBlackTree, insert:function(after, node) {
      var uncle;
      if (after) {
        node.P = after;
        if (node.N = after.N) {
          after.N.P = node;
        }
        after.N = node;
        if (after.R) {
          for (after = after.R; after.L;) {
            after = after.L;
          }
          after.L = node;
        } else {
          after.R = node;
        }
        var parent = after;
      } else {
        this._ ? (after = RedBlackFirst(this._), node.P = null, node.N = after, after.P = after.L = node, parent = after) : (node.P = node.N = null, this._ = node, parent = null);
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = !0;
      for (after = node; parent && parent.C;) {
        node = parent.U, parent === node.L ? (uncle = node.R) && uncle.C ? (parent.C = uncle.C = !1, node.C = !0, after = node) : (after === parent.R && (RedBlackRotateLeft(this, parent), after = parent, parent = after.U), parent.C = !1, node.C = !0, RedBlackRotateRight(this, node)) : (uncle = node.L) && uncle.C ? (parent.C = uncle.C = !1, node.C = !0, after = node) : (after === parent.L && (RedBlackRotateRight(this, parent), after = parent, parent = after.U), parent.C = !1, node.C = !0, RedBlackRotateLeft(this, 
        node)), parent = after.U;
      }
      this._.C = !1;
    }, remove:function(node) {
      node.N && (node.N.P = node.P);
      node.P && (node.P.N = node.N);
      node.N = node.P = null;
      var parent = node.U, left = node.L, right = node.R;
      var next = left ? right ? RedBlackFirst(right) : left : right;
      parent ? parent.L === node ? parent.L = next : parent.R = next : this._ = next;
      if (left && right) {
        var red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        next !== right ? (parent = next.U, next.U = node.U, node = next.R, parent.L = node, next.R = right, right.U = next) : (next.U = parent, parent = next, node = next.R);
      } else {
        red = node.C, node = next;
      }
      node && (node.U = parent);
      if (!red) {
        if (node && node.C) {
          node.C = !1;
        } else {
          do {
            if (node === this._) {
              break;
            }
            if (node === parent.L) {
              if (node = parent.R, node.C && (node.C = !1, parent.C = !0, RedBlackRotateLeft(this, parent), node = parent.R), node.L && node.L.C || node.R && node.R.C) {
                node.R && node.R.C || (node.L.C = !1, node.C = !0, RedBlackRotateRight(this, node), node = parent.R);
                node.C = parent.C;
                parent.C = node.R.C = !1;
                RedBlackRotateLeft(this, parent);
                node = this._;
                break;
              }
            } else {
              if (node = parent.L, node.C && (node.C = !1, parent.C = !0, RedBlackRotateRight(this, parent), node = parent.L), node.L && node.L.C || node.R && node.R.C) {
                node.L && node.L.C || (node.R.C = !1, node.C = !0, RedBlackRotateLeft(this, node), node = parent.L);
                node.C = parent.C;
                parent.C = node.L.C = !1;
                RedBlackRotateRight(this, parent);
                node = this._;
                break;
              }
            }
            node.C = !0;
            node = parent;
            parent = parent.U;
          } while (!node.C);
          node && (node.C = !1);
        }
      }
    }};
    var circlePool = [], firstCircle, beachPool = [], epsilon = 1e-6, epsilon2 = 1e-12, beaches, cells, circles, edges;
    Diagram.prototype = {constructor:Diagram, polygons:function() {
      var edges = this.edges;
      return this.cells.map(function(cell) {
        var polygon = cell.halfedges.map(function(i) {
          return cellHalfedgeStart(cell, edges[i]);
        });
        polygon.data = cell.site.data;
        return polygon;
      });
    }, triangles:function() {
      var triangles = [], edges = this.edges;
      this.cells.forEach(function(cell, i) {
        if (m = (halfedges = cell.halfedges).length) {
          cell = cell.site;
          var halfedges, j = -1, m, e1 = edges[halfedges[m - 1]];
          for (e1 = e1.left === cell ? e1.right : e1.left; ++j < m;) {
            var s0 = e1;
            e1 = edges[halfedges[j]];
            e1 = e1.left === cell ? e1.right : e1.left;
            s0 && e1 && i < s0.index && i < e1.index && 0 > (cell[0] - e1[0]) * (s0[1] - cell[1]) - (cell[0] - s0[0]) * (e1[1] - cell[1]) && triangles.push([cell.data, s0.data, e1.data]);
          }
        }
      });
      return triangles;
    }, links:function() {
      return this.edges.filter(function(edge) {
        return edge.right;
      }).map(function(edge) {
        return {source:edge.left.data, target:edge.right.data};
      });
    }, find:function(x, y, radius) {
      var that = this, i1 = that._found || 0;
      var i0 = that.cells.length;
      for (var cell; !(cell = that.cells[i1]);) {
        if (++i1 >= i0) {
          return null;
        }
      }
      i0 = x - cell.site[0];
      var dy = y - cell.site[1], d2 = i0 * i0 + dy * dy;
      do {
        cell = that.cells[i0 = i1], i1 = null, cell.halfedges.forEach(function(e) {
          var edge = that.edges[e];
          e = edge.left;
          if (e !== cell.site && e || (e = edge.right)) {
            edge = x - e[0];
            var vy = y - e[1];
            edge = edge * edge + vy * vy;
            edge < d2 && (d2 = edge, i1 = e.index);
          }
        });
      } while (null !== i1);
      that._found = i0;
      return null == radius || d2 <= radius * radius ? cell.site : null;
    }};
    exports.voronoi = function() {
      function voronoi(data) {
        return new Diagram(data.map(function(d, i) {
          var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
          s.index = i;
          s.data = d;
          return s;
        }), extent);
      }
      var x$$1 = x, y$$1 = y, extent = null;
      voronoi.polygons = function(data) {
        return voronoi(data).polygons();
      };
      voronoi.links = function(data) {
        return voronoi(data).links();
      };
      voronoi.triangles = function(data) {
        return voronoi(data).triangles();
      };
      voronoi.x = function(_) {
        return arguments.length ? (x$$1 = "function" === typeof _ ? _ : constant(+_), voronoi) : x$$1;
      };
      voronoi.y = function(_) {
        return arguments.length ? (y$$1 = "function" === typeof _ ? _ : constant(+_), voronoi) : y$$1;
      };
      voronoi.extent = function(_) {
        return arguments.length ? (extent = null == _ ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
      };
      voronoi.size = function(_) {
        return arguments.length ? (extent = null == _ ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
      };
      return voronoi;
    };
    Object.defineProperty(exports, "__esModule", {value:!0});
  });
};

//# sourceMappingURL=module$node_modules$d3_voronoi$dist$d3_voronoi.js.map
