shadow$provide.module$node_modules$victory_brush_line$lib$victory_brush_line = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.VictoryBrushLine = void 0;
  var _pick2 = _interopRequireDefault(require("module$node_modules$lodash$pick")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _react = _interopRequireDefault(require("module$node_modules$react$index")), _victoryCore = require("module$node_modules$victory_core$lib$index"), _reactFastCompare = _interopRequireDefault(require("module$node_modules$react_fast_compare$index"));
  const SMALL_NUMBER = 1 / Number.MAX_SAFE_INTEGER, getScale = props => {
    const {scale = {}, dimension = "x"} = props;
    if (scale[dimension]) {
      return scale[dimension];
    }
    const fallbackScale = _victoryCore.Scale.getBaseScale(props, dimension), range = _victoryCore.Helpers.getRange(props, dimension);
    props = _victoryCore.Domain.getDomainFromProps(props, dimension) || [0, 1];
    fallbackScale.range(range).domain(props);
    return fallbackScale;
  }, getDimension = props => {
    const {horizontal, dimension = "x"} = props;
    return horizontal ? "x" === dimension ? "y" : "x" : dimension;
  }, toRange = (props, domain) => {
    props = getScale(props);
    return [props(Math.min(...domain)), props(Math.max(...domain))];
  }, toDomain = (props, range) => {
    props = getScale(props);
    return [props.invert(Math.min(...range)), props.invert(Math.max(...range))];
  }, withinBound = (value, bound) => value >= _victoryCore.Collection.getMinValue(bound) && value <= _victoryCore.Collection.getMaxValue(bound), getBrushDomain = (brushDomain, fullDomain) => {
    if (brushDomain) {
      var brushMin = _victoryCore.Collection.getMinValue(brushDomain);
      brushDomain = _victoryCore.Collection.getMaxValue(brushDomain);
      var domainMin = _victoryCore.Collection.getMinValue(fullDomain);
      const domainMax = _victoryCore.Collection.getMaxValue(fullDomain), defaultMin = brushMin < domainMin ? domainMin : Number(domainMax) - SMALL_NUMBER;
      domainMin = brushDomain > domainMax ? domainMax : Number(domainMin) + SMALL_NUMBER;
      brushMin = withinBound(brushMin, fullDomain) ? brushMin : defaultMin;
      fullDomain = withinBound(brushDomain, fullDomain) ? brushDomain : domainMin;
      return [brushMin, fullDomain];
    }
    return fullDomain;
  }, getActiveHandle = (props, position, range) => {
    const width = props.handleWidth / 2, dimension = getDimension(props);
    props = ["min", "max"].reduce((memo, type) => {
      const base = {min:"x" === dimension ? Math.min(...range) : Math.max(...range), max:"x" === dimension ? Math.max(...range) : Math.min(...range)};
      memo[type] = withinBound(position, [base[type] - width, base[type] + width]) ? type : void 0;
      return memo;
    }, {});
    return props.min && props.max ? "both" : props.min || props.max;
  }, panBox = (props, position) => {
    const {brushDomain, startPosition} = props;
    var range = toRange(props, brushDomain), fullRange = getScale(props).range();
    props = Math.abs(range[1] - range[0]);
    const globalMin = Math.min(...fullRange);
    fullRange = Math.max(...fullRange);
    const delta = startPosition ? startPosition - position : 0;
    position = Math.min(...range) - delta;
    range = Math.max(...range) - delta;
    return [position > fullRange - props ? fullRange - props : Math.max(position, globalMin), range < globalMin + props ? globalMin + props : Math.min(range, fullRange)];
  };
  var JSCompiler_object_inline_brushAreaStyle_1107 = {stroke:"none", fill:"black", opacity:_ref => {
    ({active:_ref} = _ref);
    return _ref ? 0.2 : 0.1;
  }}, JSCompiler_object_inline_brushStyle_1108 = {pointerEvents:"none", stroke:"none", fill:"black", opacity:_ref2 => {
    ({active:_ref2} = _ref2);
    return _ref2 ? 0.4 : 0.3;
  }}, JSCompiler_object_inline_handleStyle_1109 = {pointerEvents:"none", stroke:"none", fill:"none"};
  class VictoryBrushLine extends _react.default.Component {
    static $jscomp$static$init$m532808061$0$defaultProps() {
      return {allowDrag:!0, allowDraw:!0, allowResize:!0, brushAreaComponent:_react.default.createElement(_victoryCore.Box, null), brushComponent:_react.default.createElement(_victoryCore.Box, null), groupComponent:_react.default.createElement("g", null), handleComponent:_react.default.createElement(_victoryCore.Box, null), handleWidth:10, lineComponent:_react.default.createElement(_victoryCore.LineSegment, null), width:10};
    }
    static $jscomp$static$init$m532808061$1$defaultEvents() {
      return function(props) {
        return props.disable ? void 0 : [{target:props.type, eventHandlers:{onMouseEnter:(evt, targetProps) => {
          evt.preventDefault();
          const {allowResize, brushDomain} = targetProps;
          var dimension = getDimension(targetProps);
          const parentSVG = targetProps.parentSVG || _victoryCore.Selection.getParentSVG(evt);
          evt = _victoryCore.Selection.getSVGEventCoordinates(evt, parentSVG)[dimension];
          dimension = getScale(targetProps).domain();
          const currentDomain = getBrushDomain(brushDomain, dimension), range = toRange(targetProps, currentDomain), activeHandle = allowResize && getActiveHandle(targetProps, evt, range), activeBrushes = {brushArea:!targetProps.brushDomain, brush:withinBound(evt, range) && !(0,_reactFastCompare.default)(dimension, currentDomain), minHandle:"min" === activeHandle || "both" === activeHandle, maxHandle:"min" === activeHandle || "both" === activeHandle};
          return [{mutation:() => ({activeBrushes, brushDomain:targetProps.brushDomain, parentSVG})}];
        }, onMouseDown:(evt, targetProps) => {
          evt.preventDefault();
          const {allowResize, allowDrag, allowDraw, activeBrushes, brushDomain} = targetProps, dimension = getDimension(targetProps);
          if (!allowResize && !allowDrag) {
            return [];
          }
          const fullDomain = getScale(targetProps).domain(), currentDomain = getBrushDomain(brushDomain, fullDomain), parentSVG = targetProps.parentSVG || _victoryCore.Selection.getParentSVG(evt), position = _victoryCore.Selection.getSVGEventCoordinates(evt, parentSVG)[dimension];
          evt = toRange(targetProps, currentDomain);
          const activeHandle = allowResize && getActiveHandle(targetProps, position, evt);
          return activeHandle ? [{mutation:() => ({parentSVG, isSelecting:!0, activeHandle, brushDomain:currentDomain, startPosition:position, activeBrushes})}] : withinBound(position, evt) && !(0,_reactFastCompare.default)(fullDomain, currentDomain) ? [{mutation:() => ({isPanning:allowDrag, startPosition:position, brushDomain:currentDomain, activeBrushes, parentSVG})}] : allowDraw ? [{mutation:() => ({isSelecting:allowResize, brushDomain:null, startPosition:position, activeBrushes, parentSVG})}] : 
          [];
        }, onMouseMove:(evt, targetProps) => {
          const {isPanning, isSelecting, allowResize, allowDrag, onBrushDomainChange, brushDomain} = targetProps;
          var dimension = getDimension(targetProps);
          if (isPanning || isSelecting) {
            evt.preventDefault(), evt.stopPropagation();
          }
          const parentSVG = targetProps.parentSVG || _victoryCore.Selection.getParentSVG(evt);
          evt = _victoryCore.Selection.getSVGEventCoordinates(evt, parentSVG)[dimension];
          var fullDomain = getScale(targetProps).domain(), domain = getBrushDomain(brushDomain, fullDomain), initialRange = toRange(targetProps, domain), activeHandle = getActiveHandle(targetProps, evt, initialRange);
          const activeBrushes = {brushArea:!targetProps.brushDomain, brush:withinBound(evt, initialRange) && !(0,_reactFastCompare.default)(fullDomain, domain), minHandle:"min" === activeHandle || "both" === activeHandle, maxHandle:"max" === activeHandle || "both" === activeHandle};
          if (!targetProps.isPanning && !targetProps.isSelecting) {
            return [{mutation:() => ({activeBrushes, brushDomain:targetProps.brushDomain, parentSVG})}];
          }
          if (allowDrag && isPanning) {
            dimension = getScale(targetProps).range();
            activeHandle = panBox(targetProps, evt);
            fullDomain = toDomain(targetProps, activeHandle);
            const mutatedProps = {startPosition:Math.max(...activeHandle) >= Math.max(...dimension) || Math.min(...activeHandle) <= Math.min(...dimension) ? targetProps.startPosition : evt, isPanning:!0, brushDomain:fullDomain, activeBrushes:{brush:!0}, parentSVG};
            _victoryCore.Helpers.isFunction(onBrushDomainChange) && onBrushDomainChange(fullDomain, (0,_defaults2.default)({}, mutatedProps, targetProps));
            return [{mutation:() => mutatedProps}];
          }
          if (allowResize && isSelecting) {
            domain = brushDomain || [0, SMALL_NUMBER];
            domain = toRange(targetProps, domain);
            fullDomain = "min" === targetProps.activeHandle ? "max" : "min";
            (fullDomain = targetProps.activeHandle && "both" === getActiveHandle(targetProps, evt, domain) ? fullDomain : targetProps.activeHandle) ? (initialRange = "x" === dimension ? Math.max(...domain) : Math.min(...domain), dimension = "x" === dimension ? Math.min(...domain) : Math.max(...domain), domain = toDomain(targetProps, ["max" === fullDomain ? dimension : evt, "min" === fullDomain ? initialRange : evt])) : domain = toDomain(targetProps, [targetProps.startPosition, evt]);
            const mutatedProps = {brushDomain:domain, startPosition:targetProps.startPosition, isSelecting, activeHandle:fullDomain, parentSVG, activeBrushes:{brush:!0, minHandle:"min" === activeHandle, maxHandle:"max" === activeHandle}};
            _victoryCore.Helpers.isFunction(onBrushDomainChange) && onBrushDomainChange(domain, (0,_defaults2.default)({}, mutatedProps, targetProps));
            return [{mutation:() => mutatedProps}];
          }
          return [];
        }, onMouseUp:(evt, targetProps) => {
          const {onBrushDomainChange, brushDomain, allowResize, activeBrushes} = targetProps, mutatedProps = {isPanning:!1, isSelecting:!1, activeHandle:null, startPosition:null, brushDomain, activeBrushes};
          allowResize && _victoryCore.Helpers.isFunction(onBrushDomainChange) && onBrushDomainChange(brushDomain, (0,_defaults2.default)({}, mutatedProps, targetProps));
          return [{mutation:() => mutatedProps}];
        }, onMouseLeave:(evt, targetProps) => {
          const {brushDomain} = targetProps;
          return [{mutation:() => ({isPanning:!1, isSelecting:!1, activeHandle:null, startPosition:null, brushDomain, activeBrushes:{}})}];
        }}}];
      };
    }
    getRectDimensions(props, brushWidth, domain) {
      const {brushDomain} = props;
      var dimension = getDimension(props);
      domain = toRange(props, domain || getBrushDomain(brushDomain, getScale(props).domain()));
      props = "x" === dimension ? {y1:props.y1, y2:props.y2, x1:Math.min(...domain), x2:Math.max(...domain)} : {x1:props.x1, x2:props.x2, y1:Math.min(...domain), y2:Math.max(...domain)};
      const {x1, x2, y1, y2} = props;
      props = "x" === dimension ? 0 : brushWidth / 2;
      brushWidth = "y" === dimension ? 0 : brushWidth / 2;
      dimension = Math.min(x1, x2) - props;
      domain = Math.min(y1, y2) - brushWidth;
      return {x:dimension, y:domain, width:Math.max(x1, x2) + props - dimension, height:Math.max(y1, y2) + brushWidth - domain};
    }
    getHandleDimensions(props) {
      const {handleWidth, x1, x2, y1, y2, brushDomain} = props;
      var dimension = getDimension(props);
      const brushWidth = props.brushWidth || props.width;
      var domain = getBrushDomain(brushDomain, getScale(props).domain()), range = toRange(props, domain);
      domain = Math.min(x1, x2) - brushWidth / 2;
      var defaultY = Math.min(y1, y2) - brushWidth / 2;
      props = "x" === dimension ? Math.min(...range) - handleWidth / 2 : domain;
      domain = "x" === dimension ? Math.max(...range) - handleWidth / 2 : domain;
      var JSCompiler_object_inline_min_1105 = "y" === dimension ? Math.max(...range) - handleWidth / 2 : defaultY;
      range = "y" === dimension ? Math.min(...range) - handleWidth / 2 : defaultY;
      defaultY = "x" === dimension ? handleWidth : brushWidth;
      dimension = "x" === dimension ? brushWidth : handleWidth;
      return {min:{x:props, y:JSCompiler_object_inline_min_1105, width:defaultY, height:dimension}, max:{x:domain, y:range, width:defaultY, height:dimension}};
    }
    getCursor(props) {
      const {activeBrushes = {}} = props;
      props = getDimension(props);
      return activeBrushes.minHandle || activeBrushes.maxHandle ? "x" === props ? "ew-resize" : "ns-resize" : activeBrushes.brush ? "move" : "crosshair";
    }
    renderHandles(props) {
      const {handleComponent, handleStyle, id, brushDomain, datum = {}, activeBrushes = {}} = props;
      if (!brushDomain) {
        return null;
      }
      props = this.getHandleDimensions(props);
      const style = Object.assign({}, JSCompiler_object_inline_handleStyle_1109, handleStyle);
      var minDatum = Object.assign({handleValue:_victoryCore.Collection.getMinValue(brushDomain)}, datum);
      const maxDatum = Object.assign({handleValue:_victoryCore.Collection.getMaxValue(brushDomain)}, datum);
      minDatum = Object.assign({key:`${id}-min`, style:_victoryCore.Helpers.evaluateStyle(style, {datum:minDatum, active:activeBrushes.minHandle})}, props.min);
      props = Object.assign({key:`${id}-max`, style:_victoryCore.Helpers.evaluateStyle(style, {datum:maxDatum, active:activeBrushes.maxHandle})}, props.max);
      return [_react.default.cloneElement(handleComponent, minDatum), _react.default.cloneElement(handleComponent, props)];
    }
    renderBrush(props) {
      const {brushComponent, brushStyle, activeBrushes = {}, datum = {}, brushDomain} = props;
      if (!brushDomain) {
        return null;
      }
      props = this.getRectDimensions(props, props.brushWidth || props.width);
      var baseStyle = Object.assign({}, JSCompiler_object_inline_brushStyle_1108, brushStyle);
      baseStyle = _victoryCore.Helpers.evaluateStyle(baseStyle, {datum, active:activeBrushes.brush});
      props = Object.assign({style:baseStyle}, props);
      return _react.default.cloneElement(brushComponent, props);
    }
    renderBrushArea(props) {
      const {brushAreaComponent, brushAreaStyle, activeBrushes = {}, datum = {}} = props, brushAreaWidth = props.brushAreaWidth || props.width;
      var cursor = this.getCursor(props);
      props = this.getRectDimensions(props, brushAreaWidth, getScale(props).domain());
      cursor = Object.assign({cursor}, JSCompiler_object_inline_brushAreaStyle_1107, brushAreaStyle);
      cursor = _victoryCore.Helpers.evaluateStyle(cursor, {datum, active:activeBrushes.brushArea});
      cursor = Object.assign({style:cursor}, props);
      return _react.default.cloneElement(brushAreaComponent, cursor);
    }
    renderLine(props) {
      const filteredProps = (0,_pick2.default)(props, "x1 x2 y1 y2 datum scale active style".split(" "));
      return _react.default.cloneElement(props.lineComponent, filteredProps);
    }
    render() {
      return _react.default.createElement("g", this.props.events, this.renderLine(this.props), this.renderBrushArea(this.props), this.renderBrush(this.props), this.renderHandles(this.props));
    }
  }
  VictoryBrushLine.defaultProps = VictoryBrushLine.$jscomp$static$init$m532808061$0$defaultProps();
  VictoryBrushLine.defaultEvents = VictoryBrushLine.$jscomp$static$init$m532808061$1$defaultEvents();
  exports.VictoryBrushLine = VictoryBrushLine;
};

//# sourceMappingURL=module$node_modules$victory_brush_line$lib$victory_brush_line.js.map
