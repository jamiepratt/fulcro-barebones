shadow$provide.module$node_modules$victory_bar$lib$path_helper_methods = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getVerticalPolarBarPath = exports.getVerticalBarPath = exports.getPolarBarPath = exports.getHorizontalBarPath = exports.getCustomBarPath = exports.getBarPath = void 0;
  var d3Shape = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$victory_vendor$lib$d3_shape")), _geometryHelperMethods = require("module$node_modules$victory_bar$lib$geometry_helper_methods");
  const getPosition = (props, width) => {
    const {x, x0, y, y0, horizontal} = props;
    props = props.alignment || "middle";
    width = "middle" === props ? width / 2 : width;
    const sign = horizontal ? -1 : 1;
    return horizontal ? {x0, x1:x, y0:"start" === props ? y : y - sign * width, y1:"end" === props ? y : y + sign * width} : {x0:"start" === props ? x : x - sign * width, x1:"end" === props ? x : x + sign * width, y0, y1:y};
  }, getAngle = (props, index) => {
    const {data, scale} = props;
    return scale.x(data[index][void 0 === data[index]._x1 ? "_x" : "_x1"]);
  }, getAngularWidth = (props, width) => {
    ({scale:props} = props);
    var range = props.y.range();
    range = Math.max(...range);
    props = Math.abs(props.x.range()[1] - props.x.range()[0]);
    return width / (2 * Math.PI * range) * props;
  }, getCustomBarPath = (props, width) => {
    const {getPath} = props;
    if ("function" === typeof getPath) {
      return props = {...props, ...getPosition(props, width)}, getPath(props);
    }
  };
  exports.getCustomBarPath = getCustomBarPath;
  const getStartAngle = (props, index) => {
    const {data, scale, alignment} = props, currentAngle = getAngle(props, index), angularRange = Math.abs(scale.x.range()[1] - scale.x.range()[0]);
    props = 0 === index ? getAngle(props, data.length - 1) - 2 * Math.PI : getAngle(props, index - 1);
    return 0 === index && angularRange < 2 * Math.PI ? scale.x.range()[0] : "start" === alignment || "end" === alignment ? "start" === alignment ? props : currentAngle : (currentAngle + props) / 2;
  }, getEndAngle = (props, index) => {
    const {data, scale, alignment} = props, currentAngle = getAngle(props, index), angularRange = Math.abs(scale.x.range()[1] - scale.x.range()[0]), lastAngle = scale.x.range()[1] === 2 * Math.PI ? getAngle(props, 0) + 2 * Math.PI : scale.x.range()[1];
    props = index === data.length - 1 ? getAngle(props, 0) + 2 * Math.PI : getAngle(props, index + 1);
    return index === data.length - 1 && angularRange < 2 * Math.PI ? lastAngle : "start" === alignment || "end" === alignment ? "start" === alignment ? currentAngle : props : (currentAngle + props) / 2;
  }, mapPointsToPath = (coords, cornerRadius, direction) => `${["M", `A ${`${cornerRadius.bottomLeft} ${cornerRadius.bottomLeft} ${direction}`},`, "L", `A ${`${cornerRadius.topLeft} ${cornerRadius.topLeft} ${direction}`},`, "L", `A ${`${cornerRadius.topRight} ${cornerRadius.topRight} ${direction}`},`, "L", `A ${`${cornerRadius.bottomRight} ${cornerRadius.bottomRight} ${direction}`},`].reduce((acc, command, i) => `${acc}${command} ${coords[i].x}, ${coords[i].y} \n`, "")} z`, getVerticalBarPoints = 
  (position, sign, cr) => {
    const {x0, x1, y0, y1} = position;
    position = side => {
      const isLeft = "Left" === side;
      var signL = isLeft ? 1 : -1, x = isLeft ? x0 : x1, bottomPoint = {x:x + signL * cr[`bottom${side}`], y:y0}, bottomMiddlePoint = {x, y:y0 - sign * cr[`bottom${side}`]};
      let topMiddlePoint = {x, y:y1 + sign * cr[`top${side}`]};
      var topPoint = {x:x + signL * cr[`top${side}`], y:y1};
      if (1 === sign ? y0 - cr[`bottom${side}`] < y1 + cr[`top${side}`] : y0 + cr[`bottom${side}`] > y1 - cr[`top${side}`]) {
        bottomMiddlePoint = (0,_geometryHelperMethods.point)(x + signL * cr[`top${side}`], y1 + sign * cr[`top${side}`]), bottomMiddlePoint = (0,_geometryHelperMethods.circle)(bottomMiddlePoint, cr[`top${side}`]), signL = (0,_geometryHelperMethods.point)(x + signL * cr[`bottom${side}`], y0 - sign * cr[`bottom${side}`]), signL = (0,_geometryHelperMethods.circle)(signL, cr[`bottom${side}`]), x = bottomMiddlePoint.intersection(signL), 0 < x.length ? (side = x[isLeft ? 0 : 1], bottomMiddlePoint = {x:side.x, 
        y:side.y}, topMiddlePoint = {x:side.x, y:side.y}) : cr[`top${side}`] > cr[`bottom${side}`] ? (side = bottomMiddlePoint.solveX(y0)[isLeft ? 0 : 1], bottomPoint = {x:side, y:y0}, bottomMiddlePoint = {x:side, y:y0}, topMiddlePoint = {x:side, y:y0}) : (topPoint = signL.solveX(y1)[isLeft ? 0 : 1], bottomMiddlePoint = {x:topPoint, y:y1}, topMiddlePoint = {x:topPoint, y:y1}, topPoint = {x:topPoint, y:y1});
      }
      bottomPoint = [bottomPoint, bottomMiddlePoint, topMiddlePoint, topPoint];
      return isLeft ? bottomPoint : bottomPoint.reverse();
    };
    return position("Left").concat(position("Right"));
  }, getHorizontalBarPoints = (position, sign, cr) => {
    const {y0, y1} = position, x0 = position.x0 < position.x1 ? position.x0 : position.x1, x1 = position.x0 < position.x1 ? position.x1 : position.x0;
    var getHalfPoints = side => {
      const isTop = "top" === side;
      var signL = isTop ? -1 : 1, y = isTop ? y1 : y0;
      let leftPoint = {x:x0, y:y - signL * cr[`${side}Left`]};
      var leftMiddlePoint = {x:x0 + cr[`${side}Left`], y};
      let rightMiddlePoint = {x:x1 - cr[`${side}Right`], y}, rightPoint = {x:x1, y:y - signL * cr[`${side}Right`]};
      leftMiddlePoint.x > rightMiddlePoint.x && (leftMiddlePoint = (0,_geometryHelperMethods.point)(x0 + cr[`${side}Left`], y - signL * cr[`${side}Left`]), leftMiddlePoint = (0,_geometryHelperMethods.circle)(leftMiddlePoint, cr[`${side}Left`]), signL = (0,_geometryHelperMethods.point)(x1 - cr[`${side}Right`], y - signL * cr[`${side}Right`]), signL = (0,_geometryHelperMethods.circle)(signL, cr[`${side}Right`]), y = leftMiddlePoint.intersection(signL), 0 < y.length ? (side = y[0 < sign ? 1 : 0], leftMiddlePoint = 
      {x:side.x, y:side.y}, rightMiddlePoint = {x:side.x, y:side.y}) : cr[`${side}Right`] > cr[`${side}Left`] ? (side = signL.solveY(x0)[isTop ? 0 : 1], leftPoint = {x:x0, y:side}, leftMiddlePoint = {x:x0, y:side}, rightMiddlePoint = {x:x0, y:side}) : (side = leftMiddlePoint.solveY(x1)[isTop ? 0 : 1], rightPoint = {x:x1, y:side}, rightMiddlePoint = {x:x1, y:side}, leftMiddlePoint = {x:x1, y:side}));
      return [leftPoint, leftMiddlePoint, rightMiddlePoint, rightPoint];
    };
    position = getHalfPoints("top");
    getHalfPoints = getHalfPoints("bottom");
    return [getHalfPoints[1], getHalfPoints[0], ...position, getHalfPoints[3], getHalfPoints[2]];
  }, getVerticalBarPath = (props, width, cornerRadius) => {
    width = getPosition(props, width);
    const sign = width.y0 > width.y1 ? 1 : -1;
    props = 0 < sign ? "0 0 1" : "0 0 0";
    width = getVerticalBarPoints(width, sign, cornerRadius);
    return mapPointsToPath(width, cornerRadius, props);
  };
  exports.getVerticalBarPath = getVerticalBarPath;
  const getHorizontalBarPath = (props, width, cornerRadius) => {
    props = getPosition(props, width);
    width = props.x0 < props.x1 ? 1 : -1;
    cornerRadius = {topRight:0 < width ? cornerRadius.topLeft : cornerRadius.bottomLeft, bottomRight:0 < width ? cornerRadius.topRight : cornerRadius.bottomRight, bottomLeft:0 < width ? cornerRadius.bottomRight : cornerRadius.topRight, topLeft:0 < width ? cornerRadius.bottomLeft : cornerRadius.topLeft};
    props = getHorizontalBarPoints(props, width, cornerRadius);
    return mapPointsToPath(props, cornerRadius, "0 0 1");
  };
  exports.getHorizontalBarPath = getHorizontalBarPath;
  const getVerticalPolarBarPath = (props, cornerRadius) => {
    const {datum, scale, index, alignment, style} = props, r1 = scale.y(datum._y0 || 0), r2 = scale.y(void 0 !== datum._y1 ? datum._y1 : datum._y);
    var currentAngle = scale.x(void 0 !== datum._x1 ? datum._x1 : datum._x);
    let start, end;
    style.width ? (props = getAngularWidth(props, style.width), props = "middle" === alignment ? props / 2 : props, start = "start" === alignment ? currentAngle : currentAngle - props, end = "end" === alignment ? currentAngle : currentAngle + props) : (start = getStartAngle(props, Number(index)), end = getEndAngle(props, Number(index)));
    const getPath = edge => d3Shape.arc().innerRadius(r1).outerRadius(r2).startAngle(-1 * start + Math.PI / 2).endAngle(-1 * end + Math.PI / 2).cornerRadius(cornerRadius[edge])(), getPathData = edge => {
      var rightPath = getPath(`${edge}Right`);
      const rightMoves = rightPath.match(/[A-Z]/g) || [];
      rightPath = rightPath.split(/[A-Z]/).slice(1);
      const rightMiddle = rightMoves.indexOf("L");
      var leftPath = getPath(`${edge}Left`);
      edge = leftPath.match(/[A-Z]/g) || [];
      leftPath = leftPath.split(/[A-Z]/).slice(1);
      const leftMiddle = edge.indexOf("L");
      return {rightMoves, rightCoords:rightPath, rightMiddle, leftMoves:edge, leftCoords:leftPath, leftMiddle};
    };
    currentAngle = (() => {
      const {topRight, topLeft} = cornerRadius;
      var arcLength = r2 * Math.abs(end - start);
      const {rightMoves, rightCoords, rightMiddle, leftMoves, leftCoords, leftMiddle} = getPathData("top");
      if (topRight === topLeft || arcLength < 2 * topRight + 2 * topLeft) {
        arcLength = topRight > topLeft ? rightMoves : leftMoves;
        var coords = topRight > topLeft ? rightCoords : leftCoords;
      } else {
        coords = topLeft > topRight && 3 > rightMiddle ? 1 : 2;
        var leftOffset = topRight > topLeft ? 3 > leftMiddle ? leftMiddle - 1 : 3 > rightMiddle ? leftMiddle : leftMiddle - 2 : 3 > rightMiddle ? 3 > leftMiddle ? 1 : 2 : leftMiddle - 2;
        arcLength = [...rightMoves.slice(0, coords), ...leftMoves.slice(leftOffset)];
        coords = [...rightCoords.slice(0, coords), ...leftCoords.slice(leftOffset)];
      }
      leftOffset = arcLength.indexOf("L");
      arcLength = arcLength.slice(0, leftOffset);
      const subCoords = coords.slice(0, leftOffset);
      return arcLength.map((m, i) => ({command:m, coords:subCoords[i].split(",")}));
    })();
    props = (() => {
      const {bottomRight, bottomLeft} = cornerRadius;
      var arcLength = r1 * Math.abs(end - start);
      const {rightMoves, rightCoords, rightMiddle, leftMoves, leftCoords, leftMiddle} = getPathData("bottom");
      if (bottomRight === bottomLeft || arcLength < 2 * bottomRight + 2 * bottomLeft) {
        arcLength = bottomRight > bottomLeft ? rightMoves : leftMoves;
        var coords = bottomRight > bottomLeft ? rightCoords : leftCoords;
      } else {
        coords = (bottomRight > bottomLeft ? 4 > rightMoves.length - rightMiddle : 4 > leftMoves.length - leftMiddle) ? -1 : -3, arcLength = [...leftMoves.slice(0, leftMiddle + 2), ...rightMoves.slice(coords)], coords = [...leftCoords.slice(0, leftMiddle + 2), ...rightCoords.slice(coords)];
      }
      const middle = arcLength.indexOf("L");
      arcLength = arcLength.slice(middle, -1);
      const subCoords = coords.slice(middle, -1);
      return arcLength.map((m, i) => ({command:m, coords:subCoords[i].split(",")}));
    })();
    return `${[...currentAngle, ...props].reduce((memo, move) => `${memo}${move.command} ${move.coords.join()}`, "")} z`;
  };
  exports.getVerticalPolarBarPath = getVerticalPolarBarPath;
  exports.getBarPath = (props, width, cornerRadius) => props.getPath ? getCustomBarPath(props, width) : props.horizontal ? getHorizontalBarPath(props, width, cornerRadius) : getVerticalBarPath(props, width, cornerRadius);
  exports.getPolarBarPath = (props, cornerRadius) => getVerticalPolarBarPath(props, cornerRadius);
};

//# sourceMappingURL=module$node_modules$victory_bar$lib$path_helper_methods.js.map
