shadow$provide.module$node_modules$victory_core$lib$victory_util$axis = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function identity(value) {
    return value;
  }
  function getAxis(props) {
    ({dependentAxis:props} = props);
    return props ? "y" : "x";
  }
  function findAxisComponents(childComponents, predicate) {
    const predicateFunction = predicate || identity, findAxes = children => children.reduce((memo, child) => child.type && "axis" === child.type.role && predicateFunction(child) ? memo.concat(child) : child.props && child.props.children ? memo.concat(findAxes(_react.default.Children.toArray(child.props.children))) : memo, []);
    return findAxes(childComponents);
  }
  function isVertical(props) {
    return {top:!1, bottom:!1, left:!0, right:!0}[props.orientation || (props.dependentAxis ? "left" : "bottom")];
  }
  function stringTicks(props) {
    return void 0 !== props.tickValues && Collection.containsStrings(props.tickValues);
  }
  function getDefaultTickFormat(props) {
    const {tickValues} = props;
    var axis = getAxis(props);
    axis = props.stringMap && props.stringMap[axis];
    const fallbackFormat = tickValues && !Collection.containsDates(tickValues) ? x => x : void 0;
    if (!axis) {
      return stringTicks(props) ? (x, index) => tickValues[index] : fallbackFormat;
    }
    const invertedStringMap = axis && Helpers.invert(axis), dataTicks = ["", ...(0,_orderBy2.default)(Object.values(axis), n => n).map(tick => invertedStringMap[tick]), ""];
    return x => dataTicks[x];
  }
  function getStringTicks(props) {
    var axis = getAxis(props);
    const stringMap = props.stringMap && props.stringMap[axis];
    props = (props = Array.isArray(props.categories) ? props.categories : props.categories && props.categories[axis]) && Collection.containsOnlyStrings(props) ? props.map(tick => stringMap[tick]) : void 0;
    axis = stringMap && Object.values(stringMap);
    return props && 0 !== props.length ? props : axis;
  }
  function getTickArray(props) {
    const {tickValues, tickFormat} = props;
    if (0 === tickValues?.length) {
      return [];
    }
    const axis = getAxis(props), stringMap = props.stringMap && props.stringMap[axis];
    var getTicksFromFormat = () => {
      if (tickFormat && Array.isArray(tickFormat)) {
        return Collection.containsStrings(tickFormat) ? tickFormat.map((t, i) => i) : tickFormat;
      }
    }, ticks = tickValues;
    stringMap && (ticks = getStringTicks(props));
    tickValues && Collection.containsStrings(tickValues) && (ticks = stringMap ? tickValues.map(tick => stringMap[tick]) : Helpers.range(1, tickValues.length + 1));
    getTicksFromFormat = ticks ? (0,_uniq2.default)(ticks) : getTicksFromFormat();
    ticks = arr => {
      const newTickArray = [], domain = props.domain && props.domain[axis] || props.domain;
      if (arr) {
        return arr.forEach((t, index) => {
          Array.isArray(domain) ? t >= Collection.getMinValue(domain) && t <= Collection.getMaxValue(domain) && newTickArray.push({value:t, index}) : newTickArray.push({value:t, index});
        }), newTickArray;
      }
    };
    return Array.isArray(getTicksFromFormat) && getTicksFromFormat.length ? ticks(getTicksFromFormat) : void 0;
  }
  function downsampleTicks(ticks, tickCount) {
    if (!tickCount || !Array.isArray(ticks) || ticks.length <= tickCount) {
      return ticks;
    }
    const k = Math.floor(ticks.length / tickCount);
    return ticks.filter((d, i) => 0 === i % k);
  }
  function getDomainFromData(props, axis) {
    const {polar, startAngle = 0, endAngle = 360} = props;
    var tickArray = getTickArray(props), tickValues = tickArray && 0 !== tickArray?.length ? tickArray.map(v => v.value) : void 0;
    if (Array.isArray(tickValues)) {
      var minDomain = Domain.getMinFromProps(props, axis), maxDomain = Domain.getMaxFromProps(props, axis), tickStrings = stringTicks(props);
      tickArray = tickValues.map(value => Number(value));
      var defaultMin = tickStrings ? 1 : Collection.getMinValue(tickArray);
      tickValues = tickStrings ? tickValues.length : Collection.getMaxValue(tickArray);
      minDomain = Domain.getDomainFromMinMax(void 0 !== minDomain ? minDomain : defaultMin, void 0 !== maxDomain ? maxDomain : tickValues);
      axis = polar && "x" === axis && 360 === Math.abs(startAngle - endAngle) ? Domain.getSymmetricDomain(minDomain, tickArray) : minDomain;
      isVertical(props) && !polar && axis.reverse();
      return axis;
    }
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.findAxisComponents = findAxisComponents;
  exports.getAxis = getAxis;
  exports.getAxisComponent = function(childComponents, axis) {
    return findAxisComponents(childComponents, component => component.type.getAxis(component.props) === axis)[0];
  };
  exports.getAxisComponentsWithParent = function(childComponents, type) {
    const findComponents = children => children.reduce((memo, child) => child.type && "axis" === child.type.role && ("dependent" === type ? child.props.dependentAxis : !child.props.dependentAxis) ? memo.concat(child) : child.props && child.props.children ? 0 < findComponents(_react.default.Children.toArray(child.props.children)).length ? memo.concat(child) : memo : memo, []);
    return findComponents(childComponents);
  };
  exports.getAxisValue = function(props, axis) {
    if (props.axisValue) {
      var scaleAxis = "x" === axis ? "y" : "x";
      if (scaleAxis = (0,_isObject2.default)(props.scale) && Helpers.isFunction(props.scale[scaleAxis]) ? props.scale[scaleAxis] : void 0) {
        return axis = "x" === axis ? "y" : "x", axis = (0,_isObject2.default)(props.stringMap) && props.stringMap[axis], scaleAxis(axis && "string" === typeof props.axisValue ? axis[props.axisValue] : props.axisValue);
      }
    }
  };
  exports.getDomain = function(props, axis) {
    const inherentAxis = getAxis(props);
    if (!axis || axis === inherentAxis) {
      return Domain.createDomainFunction(getDomainFromData)(props, inherentAxis);
    }
  };
  exports.getOrigin = function(domain) {
    const getSingleOrigin = d => {
      const domainMin = Math.min(...d);
      d = Math.max(...d);
      return 0 > d ? d : Math.max(0, domainMin);
    };
    return {x:Collection.containsDates(domain.x) ? new Date(Math.min(...domain.x)) : getSingleOrigin(domain.x), y:Collection.containsDates(domain.y) ? new Date(Math.min(...domain.y)) : getSingleOrigin(domain.y)};
  };
  exports.getOriginSign = function(origin, domain) {
    return Collection.containsDates(domain) ? "positive" : 0 >= origin && 0 >= Math.max(...domain) ? "negative" : "positive";
  };
  exports.getTickFormat = function(props, scale) {
    var {tickFormat} = props;
    const axis = getAxis(props), stringMap = props.stringMap && props.stringMap[axis];
    if (tickFormat) {
      if (tickFormat && Array.isArray(tickFormat)) {
        const tickArrayIndices = getTickArray(props)?.map(v => v.index), filteredTickFormat = tickFormat.filter((t, index) => tickArrayIndices?.includes(index));
        return (x, index) => filteredTickFormat[index];
      }
      if (tickFormat && Helpers.isFunction(tickFormat)) {
        return scale = (tick, index, ticks) => {
          const invertedStringMap = Helpers.invert(stringMap);
          ticks = ticks.map(t => invertedStringMap[t]);
          return props.tickFormat(invertedStringMap[tick], index, ticks);
        }, stringMap ? scale : tickFormat;
      }
    } else {
      return tickFormat = getDefaultTickFormat(props), scale = scale.tickFormat && Helpers.isFunction(scale.tickFormat) ? scale.tickFormat() : x => x, tickFormat || scale;
    }
    return x => x;
  };
  exports.getTicks = function(props, scale, filterZero) {
    void 0 === filterZero && (filterZero = !1);
    var {tickCount} = props;
    props = getTickArray(props);
    return 0 === props?.length ? [""] : (props = props ? props.map(v => v.value) : void 0) ? downsampleTicks(props, tickCount) : scale.ticks && Helpers.isFunction(scale.ticks) ? (props = scale.ticks(tickCount || 5), scale = Array.isArray(props) && props.length ? props : scale.domain(), tickCount = downsampleTicks(scale, tickCount), filterZero ? (filterZero = tickCount.filter(value => 0 !== value), filterZero.length ? filterZero : tickCount) : tickCount) : scale.domain();
  };
  exports.isVertical = isVertical;
  exports.modifyProps = function(props, fallbackProps) {
    if (!(0,_isObject2.default)(props.theme)) {
      return Helpers.modifyProps(props, fallbackProps, "axis");
    }
    var role = "axis";
    props.dependentAxis && props.theme.dependentAxis ? role = "dependentAxis" : !props.dependentAxis && props.theme.independentAxis && (role = "independentAxis");
    if ("axis" === role) {
      return Helpers.modifyProps(props, fallbackProps, "axis");
    }
    role = (0,_defaults2.default)({}, props.theme[role], props.theme.axis);
    role = Object.assign({}, props.theme, {axis:role});
    return Helpers.modifyProps(Object.assign({}, props, {theme:role}), fallbackProps, "axis");
  };
  exports.stringTicks = stringTicks;
  var _orderBy2 = _interopRequireDefault(require("module$node_modules$lodash$orderBy")), _uniq2 = _interopRequireDefault(require("module$node_modules$lodash$uniq")), _isObject2 = _interopRequireDefault(require("module$node_modules$lodash$isObject")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _react = _interopRequireDefault(require("module$node_modules$react$index")), Collection = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$collection")), 
  Domain = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$domain")), Helpers = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$helpers"));
};

//# sourceMappingURL=module$node_modules$victory_core$lib$victory_util$axis.js.map
