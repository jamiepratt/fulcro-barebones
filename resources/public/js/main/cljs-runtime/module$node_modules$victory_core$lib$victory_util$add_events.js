shadow$provide.module$node_modules$victory_core$lib$victory_util$add_events = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.addEvents = function(WrappedComponent, options) {
    void 0 === options && (options = {});
    class AddEventsMixin extends WrappedComponent {
      constructor(props) {
        super(props);
        this.state = {};
        this.getEventState = Events.getEventState.bind(this);
        this.getScopedEvents = Events.getScopedEvents.bind(this);
        this.getEvents = (p, target, eventKey) => Events.getEvents.call(this, p, target, eventKey, this.getScopedEvents);
        this.externalMutations = this.getExternalMutations(this.props);
        this.calculatedState = this.getStateChanges(this.props);
        this.globalEvents = {};
        this.prevGlobalEventKeys = [];
        this.boundGlobalEvents = {};
        this.cacheValues(this.getCalculatedValues(props));
      }
      shouldComponentUpdate(nextProps) {
        var externalMutations = this.getExternalMutations(nextProps);
        const animating = this.props.animating || this.props.animate, newMutation = !(0,_reactFastCompare.default)(externalMutations, this.externalMutations);
        if (animating || newMutation) {
          return this.cacheValues(this.getCalculatedValues(nextProps)), this.externalMutations = externalMutations, this.applyExternalMutations(nextProps, externalMutations), !0;
        }
        externalMutations = this.getStateChanges(nextProps);
        return (0,_reactFastCompare.default)(this.calculatedState, externalMutations) && (0,_reactFastCompare.default)(this.props, nextProps) ? !1 : (this.cacheValues(this.getCalculatedValues(nextProps)), !0);
      }
      componentDidMount() {
        const globalEventKeys = Object.keys(this.globalEvents);
        globalEventKeys.forEach(key => this.addGlobalListener(key));
        this.prevGlobalEventKeys = globalEventKeys;
      }
      componentDidUpdate(prevProps) {
        this.calculatedState = this.getStateChanges(prevProps);
        prevProps = Object.keys(this.globalEvents);
        (0,_collection.difference)(this.prevGlobalEventKeys, prevProps).forEach(key => this.removeGlobalListener(key));
        (0,_collection.difference)(prevProps, this.prevGlobalEventKeys).forEach(key => this.addGlobalListener(key));
        this.prevGlobalEventKeys = prevProps;
      }
      componentWillUnmount() {
        this.prevGlobalEventKeys.forEach(key => this.removeGlobalListener(key));
      }
      addGlobalListener(key) {
        const boundListener = event => {
          const listener = this.globalEvents[key];
          return listener && listener(Events.emulateReactEvent(event));
        };
        this.boundGlobalEvents[key] = boundListener;
        window.addEventListener(Events.getGlobalEventNameFromKey(key), boundListener);
      }
      removeGlobalListener(key) {
        window.removeEventListener(Events.getGlobalEventNameFromKey(key), this.boundGlobalEvents[key]);
      }
      getStateChanges(props) {
        if (!this.hasEvents) {
          return {};
        }
        const getState = (key, type) => {
          key = (0,_defaults2.default)({}, this.getEventState(key, type), this.getSharedEventState(key, type));
          return (0,_isEmpty2.default)(key) ? void 0 : key;
        };
        return (options.components || defaultComponents).map(component => {
          if (props.standalone || "parent" !== component.name) {
            return void 0 !== component.index ? getState(component.index, component.name) : this.dataKeys.map(key => getState(key, component.name)).filter(Boolean);
          }
        }).filter(Boolean);
      }
      applyExternalMutations(props, externalMutations) {
        if (!(0,_isEmpty2.default)(externalMutations)) {
          const callbacks = props.externalEventMutations.reduce((memo, mutation) => (0,_helpers.isFunction)(mutation.callback) ? memo.concat(mutation.callback) : memo, []);
          this.setState(externalMutations, callbacks.length ? () => {
            callbacks.forEach(c => c());
          } : void 0);
        }
      }
      getCalculatedValues(props) {
        var {sharedEvents} = props;
        const componentEvents = Events.getComponentEvents(props, WrappedComponent.expectedComponents);
        sharedEvents = sharedEvents && (0,_helpers.isFunction)(sharedEvents.getEventState) ? sharedEvents.getEventState : () => {
        };
        const baseProps = this.getBaseProps(props, sharedEvents), dataKeys = Object.keys(baseProps).filter(key => "parent" !== key), hasEvents = props.events || props.sharedEvents || componentEvents;
        props = this.getAllEvents(props);
        return {componentEvents, getSharedEventState:sharedEvents, baseProps, dataKeys, hasEvents, events:props};
      }
      getExternalMutations(props) {
        const {sharedEvents, externalEventMutations} = props;
        return (0,_isEmpty2.default)(externalEventMutations) || sharedEvents ? void 0 : Events.getExternalMutations(externalEventMutations, this.baseProps, this.state);
      }
      cacheValues(obj) {
        Object.keys(obj).forEach(key => {
          this[key] = obj[key];
        });
      }
      getBaseProps(props, getSharedEventState) {
        getSharedEventState = (getSharedEventState || this.getSharedEventState.bind(this))("parent", "parent");
        var parentState = this.getEventState("parent", "parent");
        getSharedEventState = (0,_defaults2.default)({}, parentState, getSharedEventState);
        getSharedEventState = (parentState = getSharedEventState.parentControlledProps) ? (0,_pick2.default)(getSharedEventState, parentState) : {};
        props = (0,_defaults2.default)({}, getSharedEventState, props);
        return "function" === typeof WrappedComponent.getBaseProps ? WrappedComponent.getBaseProps(props) : {};
      }
      getAllEvents(props) {
        return Array.isArray(this.componentEvents) ? Array.isArray(props.events) ? this.componentEvents.concat(...props.events) : this.componentEvents : props.events;
      }
      getComponentProps(component, type, index) {
        var key = this.dataKeys && this.dataKeys[index] || index;
        const id = `${this.props.name || WrappedComponent.role}-${type}-${key}`, baseProps = this.baseProps[key] && this.baseProps[key][type] || this.baseProps[key];
        if (baseProps || this.hasEvents) {
          var currentProps = component && "object" === typeof component && "props" in component ? component.props : void 0;
          return this.hasEvents ? (component = this.getEvents(this.props, type, key), type = (0,_defaults2.default)({index, key:id}, this.getEventState(key, type), this.getSharedEventState(key, type), currentProps, baseProps, {id}), key = (0,_defaults2.default)({}, Events.getPartialEvents(component, key, type), type.events), Object.assign({}, type, {events:key})) : (0,_defaults2.default)({index, key:id}, currentProps, baseProps, {id});
        }
      }
      renderContainer(component, children) {
        const parentProps = component.type && "container" === component.type.role ? this.getComponentProps(component, "parent", "parent") : {};
        parentProps.events && (this.globalEvents = Events.getGlobalEvents(parentProps.events), parentProps.events = Events.omitGlobalEvents(parentProps.events));
        return _react.default.cloneElement(component, parentProps, children);
      }
      animateComponent(props, defaultAnimationWhitelist) {
        return _react.default.createElement(_victoryTransition.VictoryTransition, {animate:props.animate, animationWhitelist:"object" === typeof props.animate && props.animate?.animationWhitelist || defaultAnimationWhitelist}, _react.default.createElement(this.constructor, props));
      }
      renderContinuousData(props) {
        const {dataComponent, labelComponent, groupComponent} = props;
        props = this.dataKeys.filter(value => "all" !== value).reduce((memo, key) => {
          (key = this.getComponentProps(labelComponent, "labels", key)) && void 0 !== key.text && null !== key.text && (memo = memo.concat(_react.default.cloneElement(labelComponent, key)));
          return memo;
        }, []);
        const dataProps = this.getComponentProps(dataComponent, "data", "all");
        props = [_react.default.cloneElement(dataComponent, dataProps), ...props];
        return this.renderContainer(groupComponent, props);
      }
      renderData(props, shouldRenderDatum) {
        void 0 === shouldRenderDatum && (shouldRenderDatum = datumHasXandY);
        const {dataComponent, labelComponent, groupComponent} = props;
        props = this.dataKeys.reduce((validDataComponents, _dataKey, index) => {
          _dataKey = this.getComponentProps(dataComponent, "data", index);
          shouldRenderDatum(_dataKey.datum) && validDataComponents.push(_react.default.cloneElement(dataComponent, _dataKey));
          return validDataComponents;
        }, []);
        const labelComponents = this.dataKeys.map((_dataKey, index) => {
          _dataKey = this.getComponentProps(labelComponent, "labels", index);
          if (void 0 !== _dataKey.text && null !== _dataKey.text) {
            return _react.default.cloneElement(labelComponent, _dataKey);
          }
        }).filter(Boolean);
        props = [...props, ...labelComponents];
        return this.renderContainer(groupComponent, props);
      }
    }
    return AddEventsMixin;
  };
  var _pick2 = _interopRequireDefault(require("module$node_modules$lodash$pick")), _isEmpty2 = _interopRequireDefault(require("module$node_modules$lodash$isEmpty")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _react = _interopRequireDefault(require("module$node_modules$react$index")), _reactFastCompare = _interopRequireDefault(require("module$node_modules$react_fast_compare$index")), _victoryTransition = require("module$node_modules$victory_core$lib$victory_transition$victory_transition"), 
  _collection = require("module$node_modules$victory_core$lib$victory_util$collection"), Events = function(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }(require("module$node_modules$victory_core$lib$victory_util$events")), _helpers = require("module$node_modules$victory_core$lib$victory_util$helpers");
  const datumHasXandY = datum => !(0,_helpers.isNil)(datum._x) && !(0,_helpers.isNil)(datum._y), defaultComponents = [{name:"parent", index:"parent"}, {name:"data"}, {name:"labels"}];
};

//# sourceMappingURL=module$node_modules$victory_core$lib$victory_util$add_events.js.map
