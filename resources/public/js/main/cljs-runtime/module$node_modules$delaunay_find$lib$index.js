shadow$provide.module$node_modules$delaunay_find$lib$index = function(global, require, module, exports) {
  function pointX(p) {
    return p[0];
  }
  function pointY(p) {
    return p[1];
  }
  function collinear(d) {
    var triangles = d.triangles;
    d = d.coords;
    for (var i = 0; i < triangles.length; i += 3) {
      var a = 2 * triangles[i], b = 2 * triangles[i + 1], c = 2 * triangles[i + 2];
      if (1e-10 < (d[c] - d[a]) * (d[b + 1] - d[a + 1]) - (d[b] - d[a]) * (d[c + 1] - d[a + 1])) {
        return !1;
      }
    }
    return !0;
  }
  function jitter(x, y, r) {
    return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
  }
  exports.__esModule = !0;
  exports["default"] = void 0;
  var _delaunator = function(obj) {
    return obj && obj.__esModule ? obj : {"default":obj};
  }(require("module$node_modules$delaunator$delaunator")), Delaunay = function() {
    function Delaunay(points) {
      var delaunator = new _delaunator["default"](points);
      this.inedges = new Int32Array(points.length / 2);
      this._hullIndex = new Int32Array(points.length / 2);
      this.points = delaunator.coords;
      this._init(delaunator);
    }
    var _proto = Delaunay.prototype;
    _proto._init = function(delaunator) {
      var d = delaunator, points = this.points;
      if (d.hull && 2 < d.hull.length && collinear(d)) {
        this.collinear = Int32Array.from({length:points.length / 2}, function(_, i) {
          return i;
        }).sort(function(i, j) {
          return points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1];
        });
        d = this.collinear[0];
        delaunator = this.collinear[this.collinear.length - 1];
        d = [points[2 * d], points[2 * d + 1], points[2 * delaunator], points[2 * delaunator + 1]];
        d = 1e-8 * Math.sqrt(Math.pow(d[3] - d[1], 2) + Math.pow(d[2] - d[0], 2));
        delaunator = 0;
        for (var n = points.length / 2; delaunator < n; ++delaunator) {
          var p = jitter(points[2 * delaunator], points[2 * delaunator + 1], d);
          points[2 * delaunator] = p[0];
          points[2 * delaunator + 1] = p[1];
        }
        delaunator = new _delaunator["default"](points);
      }
      p = this.halfedges = delaunator.halfedges;
      d = this.hull = delaunator.hull;
      var triangles = this.triangles = delaunator.triangles;
      delaunator = this.inedges.fill(-1);
      n = this._hullIndex.fill(-1);
      for (var _e = 0, _n = p.length; _e < _n; ++_e) {
        var _p = triangles[2 === _e % 3 ? _e - 2 : _e + 1];
        if (-1 === p[_e] || -1 === delaunator[_p]) {
          delaunator[_p] = _e;
        }
      }
      p = 0;
      for (triangles = d.length; p < triangles; ++p) {
        n[d[p]] = p;
      }
      2 >= d.length && 0 < d.length && (this.triangles = (new Int32Array(3)).fill(-1), this.halfedges = (new Int32Array(3)).fill(-1), this.triangles[0] = d[0], this.triangles[1] = d[1], this.triangles[2] = d[1], delaunator[d[0]] = 1, 2 === d.length && (delaunator[d[1]] = 0));
    };
    _proto.neighbors = function(i) {
      var results = [], hull = this.hull, _hullIndex = this._hullIndex, halfedges = this.halfedges, triangles = this.triangles, e0 = this.inedges[i];
      if (-1 === e0) {
        return results;
      }
      var e = e0;
      do {
        var p0 = triangles[e];
        results.push(p0);
        e = 2 === e % 3 ? e - 2 : e + 1;
        if (triangles[e] !== i) {
          break;
        }
        e = halfedges[e];
        if (-1 === e) {
          i = hull[(_hullIndex[i] + 1) % hull.length];
          i !== p0 && results.push(i);
          break;
        }
      } while (e !== e0);
      return results;
    };
    _proto.find = function(x, y, i) {
      void 0 === i && (i = 0);
      if ((x = +x, x !== x) || (y = +y, y !== y)) {
        return -1;
      }
      for (var i0 = i, c; 0 <= (c = this._step(i, x, y)) && c !== i && c !== i0;) {
        i = c;
      }
      return c;
    };
    _proto._step = function(i, x, y) {
      var points = this.points;
      if (-1 === this.inedges[i] || !points.length) {
        return (i + 1) % (points.length >> 1);
      }
      var c = i, dc = Math.pow(x - points[2 * i], 2) + Math.pow(y - points[2 * i + 1], 2);
      i = this.neighbors(i);
      var _isArray = Array.isArray(i), _i2 = 0;
      for (i = _isArray ? i : i[Symbol.iterator]();;) {
        if (_isArray) {
          if (_i2 >= i.length) {
            break;
          }
          var _ref = i[_i2++];
        } else {
          _i2 = i.next();
          if (_i2.done) {
            break;
          }
          _ref = _i2.value;
        }
        var dt = Math.pow(x - points[2 * _ref], 2) + Math.pow(y - points[2 * _ref + 1], 2);
        dt < dc && (dc = dt, c = _ref);
      }
      return c;
    };
    return Delaunay;
  }();
  exports["default"] = Delaunay;
  Delaunay.from = function(points, fx, fy, that) {
    void 0 === fx && (fx = pointX);
    void 0 === fy && (fy = pointY);
    for (var n = points.length, array = new Float64Array(2 * n), i = 0; i < n; ++i) {
      var p = points[i];
      array[2 * i] = fx.call(that, p, i, points);
      array[2 * i + 1] = fy.call(that, p, i, points);
    }
    return new Delaunay(array);
  };
};

//# sourceMappingURL=module$node_modules$delaunay_find$lib$index.js.map
