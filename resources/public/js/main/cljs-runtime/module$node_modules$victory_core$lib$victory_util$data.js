shadow$provide.module$node_modules$victory_core$lib$victory_util$data = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function parseDatum(datum) {
    const immutableDatumWhitelist = {errorX:!0, errorY:!0};
    return Immutable.isImmutable(datum) ? Immutable.shallowToJS(datum, immutableDatumWhitelist) : datum;
  }
  function getLength(data) {
    return Immutable.isIterable(data) ? data.size : data.length;
  }
  function generateDataArray(props, axis) {
    axis = ((0,_isPlainObject2.default)(props.domain) ? props.domain[axis] : props.domain) || Scale.getBaseScale(props, axis).domain();
    const samples = props.samples || 1;
    props = Math.max(...axis);
    axis = Math.min(...axis);
    axis = Helpers.range(axis, props, (props - axis) / samples);
    return axis[axis.length - 1] === props ? axis : axis.concat(props);
  }
  function sortData(dataset, sortKey, sortOrder) {
    void 0 === sortOrder && (sortOrder = "ascending");
    if (!sortKey) {
      return dataset;
    }
    let formattedSortKey = sortKey;
    if ("x" === sortKey || "y" === sortKey) {
      formattedSortKey = `_${sortKey}`;
    }
    return (0,_orderBy2.default)(dataset, formattedSortKey, "ascending" === sortOrder ? "asc" : "desc");
  }
  function cleanData(dataset, props) {
    const smallNumber = 1 / Number.MAX_SAFE_INTEGER, scaleType = {x:Scale.getScaleType(props, "x"), y:Scale.getScaleType(props, "y")};
    if ("log" !== scaleType.x && "log" !== scaleType.y) {
      return dataset;
    }
    const rules = (datum, axis) => "log" === scaleType[axis] ? 0 !== datum[`_${axis}`] : !0;
    return dataset.map(datum => {
      if (rules(datum, "x") && rules(datum, "y") && rules(datum, "y0")) {
        return datum;
      }
      const _x = rules(datum, "x") ? datum._x : smallNumber, _y = rules(datum, "y") ? datum._y : smallNumber, _y0 = rules(datum, "y0") ? datum._y0 : smallNumber;
      return Object.assign({}, datum, {_x, _y, _y0});
    });
  }
  function getEventKey(key) {
    return Helpers.isFunction(key) ? key : null === key || void 0 === key ? () => {
    } : (0,_property2.default)(key);
  }
  function addEventKeys(props, data) {
    const hasEventKeyAccessor = !!props.eventKey, eventKeyAccessor = getEventKey(props.eventKey);
    return data.map((datum, index) => void 0 === datum.eventKey && hasEventKeyAccessor ? (index = eventKeyAccessor(datum, index), void 0 !== index ? Object.assign({eventKey:index}, datum) : datum) : datum);
  }
  function createStringMap(props, axis) {
    var stringsFromAxes = getStringsFromAxes(props, axis);
    const stringsFromCategories = getStringsFromCategories(props, axis);
    props = getStringsFromData(props, axis);
    stringsFromAxes = (0,_uniq2.default)([...stringsFromAxes, ...stringsFromCategories, ...props]);
    return 0 === stringsFromAxes.length ? null : stringsFromAxes.reduce((memo, string, index) => {
      memo[string] = index + 1;
      return memo;
    }, {});
  }
  function formatData(dataset, props, expectedKeys) {
    if (!Array.isArray(dataset) && !Immutable.isIterable(dataset) || 1 > getLength(dataset)) {
      return [];
    }
    var defaultKeys = ["x", "y", "y0"];
    expectedKeys = Array.isArray(expectedKeys) ? expectedKeys : defaultKeys;
    const accessor = expectedKeys.reduce((memo, type) => {
      memo[type] = Helpers.createAccessor(void 0 !== props[type] ? props[type] : type);
      return memo;
    }, {});
    defaultKeys = (0,_isEqual2.default)(expectedKeys, defaultKeys) && "_x" === props.x && "_y" === props.y && "_y0" === props.y0;
    let stringMap;
    !1 === defaultKeys && (stringMap = {x:-1 !== expectedKeys.indexOf("x") ? createStringMap(props, "x") : void 0, y:-1 !== expectedKeys.indexOf("y") ? createStringMap(props, "y") : void 0, y0:-1 !== expectedKeys.indexOf("y0") ? createStringMap(props, "y") : void 0});
    dataset = defaultKeys ? dataset : dataset.reduce((dataArr, datum, index) => {
      const parsedDatum = parseDatum(datum), fallbackValues = {x:index, y:parsedDatum};
      datum = expectedKeys.reduce((memo, type) => {
        var processedValue = accessor[type](parsedDatum);
        processedValue = void 0 !== processedValue ? processedValue : fallbackValues[type];
        void 0 !== processedValue && ("string" === typeof processedValue && stringMap[type] ? (memo[`${type}Name`] = processedValue, memo[`_${type}`] = stringMap[type][processedValue]) : memo[`_${type}`] = processedValue);
        return memo;
      }, {});
      datum = Object.assign({}, datum, parsedDatum);
      (0,_isEmpty2.default)(datum) || dataArr.push(datum);
      return dataArr;
    }, []);
    dataset = sortData(dataset, props.sortKey, props.sortOrder);
    dataset = cleanData(dataset, props);
    return addEventKeys(props, dataset);
  }
  function generateData(props) {
    const xValues = generateDataArray(props, "x"), yValues = generateDataArray(props, "y");
    return xValues.map((x, i) => ({x, y:yValues[i]}));
  }
  function getCategories(props, axis) {
    return props.categories && !Array.isArray(props.categories) ? props.categories[axis] : props.categories;
  }
  function getStringsFromAxes(props, axis) {
    const {tickValues, tickFormat} = props;
    return (tickValues && (Array.isArray(tickValues) || tickValues[axis]) ? tickValues[axis] || tickValues : tickFormat && Array.isArray(tickFormat) ? tickFormat : []).filter(val => "string" === typeof val);
  }
  function getStringsFromCategories(props, axis) {
    return props.categories ? (props = (props = getCategories(props, axis)) && props.filter(val => "string" === typeof val)) ? Collection.removeUndefined(props) : [] : [];
  }
  function getStringsFromData(props, axis) {
    if (!Array.isArray(props.data) && !Immutable.isIterable(props.data)) {
      return [];
    }
    const accessor = Helpers.createAccessor(void 0 === props[axis] ? axis : props[axis]);
    axis = props.data.reduce((memo, d) => {
      memo.push(parseDatum(d));
      return memo;
    }, []);
    return sortData(axis, props.sortKey, props.sortOrder).reduce((dataArr, datum) => {
      datum = parseDatum(datum);
      dataArr.push(accessor(datum));
      return dataArr;
    }, []).filter(datum => "string" === typeof datum).reduce((prev, curr) => {
      void 0 !== curr && null !== curr && -1 === prev.indexOf(curr) && prev.push(curr);
      return prev;
    }, []);
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.createStringMap = createStringMap;
  exports.downsample = function(data, maxPoints, startingIndex) {
    void 0 === startingIndex && (startingIndex = 0);
    const dataLength = getLength(data);
    if (dataLength > maxPoints) {
      const k = Math.pow(2, Math.ceil(Math.log2(dataLength / maxPoints)));
      return data.filter((d, i) => 0 === (i + startingIndex) % k);
    }
    return data;
  };
  exports.formatData = formatData;
  exports.formatDataFromDomain = function(dataset, domain, defaultBaseline) {
    const minDomainX = Collection.getMinValue(domain.x), maxDomainX = Collection.getMaxValue(domain.x), minDomainY = Collection.getMinValue(domain.y), maxDomainY = Collection.getMaxValue(domain.y);
    domain = min => val => void 0 !== val && val < min;
    const overMax = max => val => void 0 !== val && val > max, isUnderMinX = domain(minDomainX), isUnderMinY = domain(minDomainY), isOverMaxX = overMax(maxDomainX), isOverMaxY = overMax(maxDomainY);
    return dataset.map(datum => {
      let {_x, _y, _y0, _y1} = datum;
      if (isUnderMinX(_x) || isOverMaxX(_x)) {
        _x = null;
      }
      const baseline = void 0 !== _y0 ? _y0 : defaultBaseline, value = void 0 !== _y1 ? _y1 : _y;
      if (void 0 === value) {
        return datum;
      }
      void 0 === baseline && (isUnderMinY(value) || isOverMaxY(value)) && (_y = null);
      if (isUnderMinY(baseline) && isUnderMinY(value) || isOverMaxY(baseline) && isOverMaxY(value)) {
        _y = _y0 = _y1 = null;
      }
      isUnderMinY(baseline) && !isUnderMinY(value) && (_y0 = minDomainY);
      isOverMaxY(baseline) && !isOverMaxY(value) && (_y0 = maxDomainY);
      return Object.assign({}, datum, (0,_omitBy2.default)({_x, _y, _y0, _y1}, _isUndefined2.default));
    });
  };
  exports.generateData = generateData;
  exports.getCategories = getCategories;
  exports.getData = function(props) {
    return props.data ? formatData(props.data, props) : formatData(generateData(props), props);
  };
  exports.getStringsFromAxes = getStringsFromAxes;
  exports.getStringsFromCategories = getStringsFromCategories;
  exports.getStringsFromData = getStringsFromData;
  exports.isDataComponent = function(component) {
    let role = component && component.type ? component.type.role : "";
    "portal" === role && (component = _react.default.Children.toArray(component.props.children), component = component.length ? (component = component[0]) && component.type ? component.type.role : "" : "", role = component);
    return "area bar boxplot candlestick errorbar group histogram line pie scatter stack voronoi".split(" ").includes(role);
  };
  var _omitBy2 = _interopRequireDefault(require("module$node_modules$lodash$omitBy")), _isUndefined2 = _interopRequireDefault(require("module$node_modules$lodash$isUndefined")), _isEqual2 = _interopRequireDefault(require("module$node_modules$lodash$isEqual")), _isEmpty2 = _interopRequireDefault(require("module$node_modules$lodash$isEmpty")), _orderBy2 = _interopRequireDefault(require("module$node_modules$lodash$orderBy")), _property2 = _interopRequireDefault(require("module$node_modules$lodash$property")), 
  _isPlainObject2 = _interopRequireDefault(require("module$node_modules$lodash$isPlainObject")), _uniq2 = _interopRequireDefault(require("module$node_modules$lodash$uniq")), _react = _interopRequireDefault(require("module$node_modules$react$index")), Helpers = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$helpers")), Collection = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$collection")), Scale = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$scale")), 
  Immutable = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$immutable"));
};

//# sourceMappingURL=module$node_modules$victory_core$lib$victory_util$data.js.map
