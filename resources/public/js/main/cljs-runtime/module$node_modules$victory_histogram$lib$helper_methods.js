shadow$provide.module$node_modules$victory_histogram$lib$helper_methods = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getFormattedData = exports.getDomain = exports.getData = exports.getBaseProps = void 0;
  var _victoryCore = require("module$node_modules$victory_core$lib$index"), _victoryBar = require("module$node_modules$victory_bar$lib$index"), _reactFastCompare = function(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }(require("module$node_modules$react_fast_compare$index")), d3Array = _interopRequireWildcard(require("module$node_modules$victory_vendor$lib$d3_array")), d3Scale = _interopRequireWildcard(require("module$node_modules$victory_vendor$lib$d3_scale"));
  const dataOrBinsContainDates = _ref => {
    let {data, bins, x} = _ref;
    const xAccessor = _victoryCore.Helpers.createAccessor(x || "x");
    _ref = data?.some(datum => xAccessor(datum) instanceof Date) || !1;
    const binsHasDates = Array.isArray(bins) && bins.some(bin => bin instanceof Date);
    return _ref || binsHasDates;
  }, getBinningFunc = _ref2 => {
    let {data, x, bins, dataOrBinsContainsDates} = _ref2;
    var xAccessor = _victoryCore.Helpers.createAccessor(x || "x");
    _ref2 = d3Array.bin().value(xAccessor);
    xAccessor = (dataOrBinsContainsDates ? d3Scale.scaleTime() : d3Scale.scaleLinear()).domain(d3Array.extent(data, xAccessor)).nice();
    if (Array.isArray(bins)) {
      return _ref2.domain([bins[0], bins[bins.length - 1]]), _ref2.thresholds(bins.slice(1, bins.length - 1)), _ref2;
    }
    if (Number.isInteger(bins)) {
      return _ref2.domain(xAccessor.domain()), _ref2.thresholds(bins), _ref2;
    }
    if (dataOrBinsContainsDates) {
      return _ref2.domain(xAccessor.domain()), _ref2.thresholds(xAccessor.ticks()), _ref2;
    }
    _ref2.domain(xAccessor.domain());
    return _ref2;
  }, getFormattedData = exports.getFormattedData = (func => {
    let called = !1, lastArgs, lastReturnVal;
    return function() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (called && (0,_reactFastCompare.default)(lastArgs, args)) {
        return lastReturnVal;
      }
      _len = func(...args);
      called = !0;
      lastReturnVal = _len;
      lastArgs = args;
      return _len;
    };
  })(_ref3 => {
    let {data = [], x, bins} = _ref3;
    if (!(data && data.length || Array.isArray(bins))) {
      return [];
    }
    const dataOrBinsContainsDates = dataOrBinsContainDates({data, bins, x});
    return [...getBinningFunc({data, x, bins, dataOrBinsContainsDates})(data)].filter(_ref4 => {
      let {x0, x1} = _ref4;
      return x0 instanceof Date && x1 instanceof Date ? (new Date(x0)).getTime() !== (new Date(x1)).getTime() : x0 !== x1;
    }).map(bin => {
      const x0 = dataOrBinsContainsDates ? new Date(bin.x0) : bin.x0 || 0, x1 = dataOrBinsContainsDates ? new Date(bin.x1) : bin.x1 || 0;
      return {x0, x1, x:dataOrBinsContainsDates ? new Date((x0.getTime() + x1.getTime()) / 2) : (x0 + x1) / 2, y:bin.length, binnedData:[...bin]};
    });
  }), getData = props => {
    const {bins, data, x} = props, formattedData = data?.some(_ref5 => {
      ({_y:_ref5} = _ref5);
      return !_victoryCore.Helpers.isNil(_ref5);
    }) ? data : getFormattedData({data, x, bins});
    return _victoryCore.Data.getData({...props, data:formattedData, x:"x"});
  };
  exports.getData = getData;
  const getDomain = (props, axis) => {
    const data = getData(props);
    return data.length ? "x" === axis ? _victoryCore.Domain.getDomainWithZero({...props, data:[{x:data[0].x0}, {x:data[data.length - 1].x1}], x:"x"}, "x") : props.data?.length ? _victoryCore.Domain.getDomainWithZero({...props, data}, "y") : [0, 1] : [0, 1];
  };
  exports.getDomain = getDomain;
  const getCalculatedValues = props => {
    var defaultStyles = _victoryCore.Helpers.getDefaultStyles(props, "histogram");
    defaultStyles = _victoryCore.Helpers.getStyles(props.style, defaultStyles);
    const range = props.range || {x:_victoryCore.Helpers.getRange(props, "x"), y:_victoryCore.Helpers.getRange(props, "y")}, domain = {x:getDomain(props, "x"), y:getDomain(props, "y")};
    let data = getData(props);
    data = _victoryCore.Data.formatDataFromDomain(data, domain, 0);
    props = {x:_victoryCore.Scale.getBaseScale(props, "x").domain(domain.x).range(props.horizontal ? range.y : range.x), y:_victoryCore.Scale.getBaseScale(props, "y").domain(domain.y).range(props.horizontal ? range.x : range.y)};
    return {style:defaultStyles, data, scale:props, domain};
  };
  exports.getBaseProps = (initialProps, fallbackProps) => {
    initialProps = _victoryCore.Helpers.modifyProps(initialProps, fallbackProps, "histogram");
    const props = Object.assign({}, initialProps, getCalculatedValues(initialProps)), {binSpacing, cornerRadius, data, domain, events, height, horizontal, padding, scale, sharedEvents, standalone, style, theme, width, labels, name, getPath, disableInlineStyles} = props, getDistance = datum => {
      const current = scale.x(datum.x0);
      datum = scale.x(datum.x1);
      return Math.abs(datum - current);
    };
    return data.reduce((childProps, datum, index) => {
      const eventKey = _victoryCore.Helpers.isNil(datum.eventKey) ? index : datum.eventKey, {x, y, y0, x0} = (0,_victoryBar.getBarPosition)(props, datum);
      var JSCompiler_inline_result = binSpacing ? getDistance(datum) - binSpacing : getDistance(datum);
      childProps[eventKey] = {data:{alignment:"middle", barWidth:JSCompiler_inline_result, cornerRadius, data, datum, horizontal, index, scale, style:disableInlineStyles ? {} : style.data, width, height, x, y, y0, x0, getPath, disableInlineStyles}};
      datum = _victoryCore.LabelHelpers.getText(props, datum, index);
      if (void 0 !== datum && null !== datum || labels && (events || sharedEvents)) {
        childProps[eventKey].labels = _victoryCore.LabelHelpers.getProps(props, index);
      }
      return childProps;
    }, {parent:{horizontal, domain, scale, width, height, data, standalone, name, theme, padding, style:style.parent}});
  };
};

//# sourceMappingURL=module$node_modules$victory_histogram$lib$helper_methods.js.map
