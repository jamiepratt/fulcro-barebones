shadow$provide.module$node_modules$delaunator$delaunator = function(global, require, module, exports) {
  (function(global, factory) {
    "object" === typeof exports && "undefined" !== typeof module ? module.exports = factory() : "function" === typeof define && define.amd ? define(factory) : (global = global || self, global.Delaunator = factory());
  })(this, function() {
    function dist(ax, ay, bx, by) {
      ax -= bx;
      ay -= by;
      return ax * ax + ay * ay;
    }
    function orientIfSure(px, py, rx, ry, qx, qy) {
      ry = (ry - py) * (qx - px);
      px = (rx - px) * (qy - py);
      return Math.abs(ry - px) >= 3.3306690738754716e-16 * Math.abs(ry + px) ? ry - px : 0;
    }
    function orient(rx, ry, qx, qy, px, py) {
      return 0 > (orientIfSure(px, py, rx, ry, qx, qy) || orientIfSure(rx, ry, qx, qy, px, py) || orientIfSure(qx, qy, px, py, rx, ry));
    }
    function quicksort(ids, dists, left, right) {
      if (20 >= right - left) {
        for (var i = left + 1; i <= right; i++) {
          for (var temp = ids[i], tempDist = dists[temp], j = i - 1; j >= left && dists[ids[j]] > tempDist;) {
            ids[j + 1] = ids[j--];
          }
          ids[j + 1] = temp;
        }
      } else {
        i = left + 1;
        temp = right;
        swap(ids, left + right >> 1, i);
        dists[ids[left]] > dists[ids[right]] && swap(ids, left, right);
        dists[ids[i]] > dists[ids[right]] && swap(ids, i, right);
        dists[ids[left]] > dists[ids[i]] && swap(ids, left, i);
        tempDist = ids[i];
        for (j = dists[tempDist];;) {
          do {
            i++;
          } while (dists[ids[i]] < j);
          do {
            temp--;
          } while (dists[ids[temp]] > j);
          if (temp < i) {
            break;
          }
          swap(ids, i, temp);
        }
        ids[left + 1] = ids[temp];
        ids[temp] = tempDist;
        right - i + 1 >= temp - left ? (quicksort(ids, dists, i, right), quicksort(ids, dists, left, temp - 1)) : (quicksort(ids, dists, left, temp - 1), quicksort(ids, dists, i, right));
      }
    }
    function swap(arr, i, j) {
      var tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    function defaultGetX(p) {
      return p[0];
    }
    function defaultGetY(p) {
      return p[1];
    }
    var EPSILON = Math.pow(2, -52), EDGE_STACK = new Uint32Array(512), Delaunator = function(coords) {
      var n = coords.length >> 1;
      if (0 < n && "number" !== typeof coords[0]) {
        throw Error("Expected coords to contain numbers.");
      }
      this.coords = coords;
      coords = Math.max(2 * n - 5, 0);
      this._triangles = new Uint32Array(3 * coords);
      this._halfedges = new Int32Array(3 * coords);
      this._hashSize = Math.ceil(Math.sqrt(n));
      this._hullPrev = new Uint32Array(n);
      this._hullNext = new Uint32Array(n);
      this._hullTri = new Uint32Array(n);
      this._hullHash = (new Int32Array(this._hashSize)).fill(-1);
      this._ids = new Uint32Array(n);
      this._dists = new Float64Array(n);
      this.update();
    };
    Delaunator.from = function(points, getX, getY) {
      void 0 === getX && (getX = defaultGetX);
      void 0 === getY && (getY = defaultGetY);
      for (var n = points.length, coords = new Float64Array(2 * n), i = 0; i < n; i++) {
        var p = points[i];
        coords[2 * i] = getX(p);
        coords[2 * i + 1] = getY(p);
      }
      return new Delaunator(coords);
    };
    Delaunator.prototype.update = function() {
      for (var JSCompiler_object_inline_x_1130, JSCompiler_object_inline_y_1131, coords = this.coords, hullPrev = this._hullPrev, hullNext = this._hullNext, hullTri = this._hullTri, hullHash = this._hullHash, n = coords.length >> 1, minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity, i = 0; i < n; i++) {
        var x = coords[2 * i];
        JSCompiler_object_inline_x_1130 = coords[2 * i + 1];
        x < minX && (minX = x);
        JSCompiler_object_inline_x_1130 < minY && (minY = JSCompiler_object_inline_x_1130);
        x > maxX && (maxX = x);
        JSCompiler_object_inline_x_1130 > maxY && (maxY = JSCompiler_object_inline_x_1130);
        this._ids[i] = i;
      }
      maxX = (minX + maxX) / 2;
      minY = (minY + maxY) / 2;
      minX = Infinity;
      for (maxY = 0; maxY < n; maxY++) {
        if (i = dist(maxX, minY, coords[2 * maxY], coords[2 * maxY + 1]), i < minX) {
          var i0 = maxY;
          minX = i;
        }
      }
      minY = coords[2 * i0];
      maxY = coords[2 * i0 + 1];
      minX = Infinity;
      for (maxX = 0; maxX < n; maxX++) {
        if (maxX !== i0 && (i = dist(minY, maxY, coords[2 * maxX], coords[2 * maxX + 1]), i < minX && 0 < i)) {
          var i1 = maxX;
          minX = i;
        }
      }
      minX = coords[2 * i1];
      maxX = coords[2 * i1 + 1];
      JSCompiler_object_inline_x_1130 = Infinity;
      for (i = 0; i < n; i++) {
        if (i !== i0 && i !== i1) {
          x = minX - minY;
          var dy = maxX - maxY;
          JSCompiler_object_inline_y_1131 = coords[2 * i] - minY;
          var ey = coords[2 * i + 1] - maxY, bl = x * x + dy * dy, cl = JSCompiler_object_inline_y_1131 * JSCompiler_object_inline_y_1131 + ey * ey, d = 0.5 / (x * ey - dy * JSCompiler_object_inline_y_1131);
          dy = (ey * bl - dy * cl) * d;
          x = (x * cl - JSCompiler_object_inline_y_1131 * bl) * d;
          x = dy * dy + x * x;
          if (x < JSCompiler_object_inline_x_1130) {
            var i2 = i;
            JSCompiler_object_inline_x_1130 = x;
          }
        }
      }
      i = coords[2 * i2];
      x = coords[2 * i2 + 1];
      if (Infinity === JSCompiler_object_inline_x_1130) {
        for (hullNext = 0; hullNext < n; hullNext++) {
          this._dists[hullNext] = coords[2 * hullNext] - coords[0] || coords[2 * hullNext + 1] - coords[1];
        }
        quicksort(this._ids, this._dists, 0, n - 1);
        hullNext = new Uint32Array(n);
        hullPrev = coords = 0;
        for (hullTri = -Infinity; hullPrev < n; hullPrev++) {
          hullHash = this._ids[hullPrev], this._dists[hullHash] > hullTri && (hullNext[coords++] = hullHash, hullTri = this._dists[hullHash]);
        }
        this.hull = hullNext.subarray(0, coords);
        this.triangles = new Uint32Array(0);
        this.halfedges = new Uint32Array(0);
      } else {
        orient(minY, maxY, minX, maxX, i, x) && (JSCompiler_object_inline_x_1130 = i1, JSCompiler_object_inline_y_1131 = minX, bl = maxX, i1 = i2, minX = i, maxX = x, i2 = JSCompiler_object_inline_x_1130, i = JSCompiler_object_inline_y_1131, x = bl);
        JSCompiler_object_inline_y_1131 = minX - minY;
        JSCompiler_object_inline_x_1130 = maxX - maxY;
        bl = i - minY;
        ey = x - maxY;
        cl = JSCompiler_object_inline_y_1131 * JSCompiler_object_inline_y_1131 + JSCompiler_object_inline_x_1130 * JSCompiler_object_inline_x_1130;
        d = bl * bl + ey * ey;
        dy = 0.5 / (JSCompiler_object_inline_y_1131 * ey - JSCompiler_object_inline_x_1130 * bl);
        JSCompiler_object_inline_x_1130 = minY + (ey * cl - JSCompiler_object_inline_x_1130 * d) * dy;
        JSCompiler_object_inline_y_1131 = maxY + (JSCompiler_object_inline_y_1131 * d - bl * cl) * dy;
        this._cx = JSCompiler_object_inline_x_1130;
        this._cy = JSCompiler_object_inline_y_1131;
        for (bl = 0; bl < n; bl++) {
          this._dists[bl] = dist(coords[2 * bl], coords[2 * bl + 1], JSCompiler_object_inline_x_1130, JSCompiler_object_inline_y_1131);
        }
        quicksort(this._ids, this._dists, 0, n - 1);
        this._hullStart = i0;
        n = 3;
        hullNext[i0] = hullPrev[i2] = i1;
        hullNext[i1] = hullPrev[i0] = i2;
        hullNext[i2] = hullPrev[i1] = i0;
        hullTri[i0] = 0;
        hullTri[i1] = 1;
        hullTri[i2] = 2;
        hullHash.fill(-1);
        hullHash[this._hashKey(minY, maxY)] = i0;
        hullHash[this._hashKey(minX, maxX)] = i1;
        hullHash[this._hashKey(i, x)] = i2;
        this.trianglesLen = 0;
        this._addTriangle(i0, i1, i2, -1, -1, -1);
        minY = 0;
        for (minX = maxY = void 0; minY < this._ids.length; minY++) {
          if (maxX = this._ids[minY], i = coords[2 * maxX], x = coords[2 * maxX + 1], !(0 < minY && Math.abs(i - maxY) <= EPSILON && Math.abs(x - minX) <= EPSILON) && (maxY = i, minX = x, maxX !== i0 && maxX !== i1 && maxX !== i2)) {
            JSCompiler_object_inline_y_1131 = JSCompiler_object_inline_x_1130 = 0;
            for (bl = this._hashKey(i, x); JSCompiler_object_inline_y_1131 < this._hashSize && (JSCompiler_object_inline_x_1130 = hullHash[(bl + JSCompiler_object_inline_y_1131) % this._hashSize], -1 === JSCompiler_object_inline_x_1130 || JSCompiler_object_inline_x_1130 === hullNext[JSCompiler_object_inline_x_1130]); JSCompiler_object_inline_y_1131++) {
            }
            JSCompiler_object_inline_y_1131 = JSCompiler_object_inline_x_1130 = hullPrev[JSCompiler_object_inline_x_1130];
            for (bl = void 0; bl = hullNext[JSCompiler_object_inline_y_1131], !orient(i, x, coords[2 * JSCompiler_object_inline_y_1131], coords[2 * JSCompiler_object_inline_y_1131 + 1], coords[2 * bl], coords[2 * bl + 1]);) {
              if (JSCompiler_object_inline_y_1131 = bl, JSCompiler_object_inline_y_1131 === JSCompiler_object_inline_x_1130) {
                JSCompiler_object_inline_y_1131 = -1;
                break;
              }
            }
            if (-1 !== JSCompiler_object_inline_y_1131) {
              cl = this._addTriangle(JSCompiler_object_inline_y_1131, maxX, hullNext[JSCompiler_object_inline_y_1131], -1, -1, hullTri[JSCompiler_object_inline_y_1131]);
              hullTri[maxX] = this._legalize(cl + 2);
              hullTri[JSCompiler_object_inline_y_1131] = cl;
              n++;
              for (d = hullNext[JSCompiler_object_inline_y_1131]; bl = hullNext[d], orient(i, x, coords[2 * d], coords[2 * d + 1], coords[2 * bl], coords[2 * bl + 1]);) {
                cl = this._addTriangle(d, maxX, bl, hullTri[maxX], -1, hullTri[d]), hullTri[maxX] = this._legalize(cl + 2), hullNext[d] = d, n--, d = bl;
              }
              if (JSCompiler_object_inline_y_1131 === JSCompiler_object_inline_x_1130) {
                for (; bl = hullPrev[JSCompiler_object_inline_y_1131], orient(i, x, coords[2 * bl], coords[2 * bl + 1], coords[2 * JSCompiler_object_inline_y_1131], coords[2 * JSCompiler_object_inline_y_1131 + 1]);) {
                  cl = this._addTriangle(bl, maxX, JSCompiler_object_inline_y_1131, -1, hullTri[JSCompiler_object_inline_y_1131], hullTri[bl]), this._legalize(cl + 2), hullTri[bl] = cl, hullNext[JSCompiler_object_inline_y_1131] = JSCompiler_object_inline_y_1131, n--, JSCompiler_object_inline_y_1131 = bl;
                }
              }
              this._hullStart = hullPrev[maxX] = JSCompiler_object_inline_y_1131;
              hullNext[JSCompiler_object_inline_y_1131] = hullPrev[d] = maxX;
              hullNext[maxX] = d;
              hullHash[this._hashKey(i, x)] = maxX;
              hullHash[this._hashKey(coords[2 * JSCompiler_object_inline_y_1131], coords[2 * JSCompiler_object_inline_y_1131 + 1])] = JSCompiler_object_inline_y_1131;
            }
          }
        }
        this.hull = new Uint32Array(n);
        coords = 0;
        for (hullPrev = this._hullStart; coords < n; coords++) {
          this.hull[coords] = hullPrev, hullPrev = hullNext[hullPrev];
        }
        this.triangles = this._triangles.subarray(0, this.trianglesLen);
        this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
      }
    };
    Delaunator.prototype._hashKey = function(x, y) {
      var JSCompiler_temp_const = Math;
      x -= this._cx;
      y -= this._cy;
      x /= Math.abs(x) + Math.abs(y);
      return JSCompiler_temp_const.floor.call(JSCompiler_temp_const, (0 < y ? 3 - x : 1 + x) / 4 * this._hashSize) % this._hashSize;
    };
    Delaunator.prototype._legalize = function(a) {
      for (var triangles = this._triangles, halfedges = this._halfedges, coords = this.coords, i = 0, ar;;) {
        var b = halfedges[a], a0 = a - a % 3;
        ar = a0 + (a + 2) % 3;
        if (-1 === b) {
          if (0 === i) {
            break;
          }
          a = EDGE_STACK[--i];
        } else {
          var b0 = b - b % 3, bl = b0 + (b + 2) % 3, p0 = triangles[ar], pr = triangles[a], pl = triangles[a0 + (a + 1) % 3];
          a0 = triangles[bl];
          var px = coords[2 * a0], py = coords[2 * a0 + 1], dx = coords[2 * p0] - px, dy = coords[2 * p0 + 1] - py, ex = coords[2 * pr] - px;
          pr = coords[2 * pr + 1] - py;
          px = coords[2 * pl] - px;
          pl = coords[2 * pl + 1] - py;
          py = ex * ex + pr * pr;
          var cp = px * px + pl * pl;
          if (0 > dx * (pr * cp - py * pl) - dy * (ex * cp - py * px) + (dx * dx + dy * dy) * (ex * pl - pr * px)) {
            triangles[a] = a0;
            triangles[b] = p0;
            p0 = halfedges[bl];
            if (-1 === p0) {
              a0 = this._hullStart;
              do {
                if (this._hullTri[a0] === bl) {
                  this._hullTri[a0] = a;
                  break;
                }
                a0 = this._hullPrev[a0];
              } while (a0 !== this._hullStart);
            }
            this._link(a, p0);
            this._link(b, halfedges[ar]);
            this._link(ar, bl);
            ar = b0 + (b + 1) % 3;
            i < EDGE_STACK.length && (EDGE_STACK[i++] = ar);
          } else {
            if (0 === i) {
              break;
            }
            a = EDGE_STACK[--i];
          }
        }
      }
      return ar;
    };
    Delaunator.prototype._link = function(a, b) {
      this._halfedges[a] = b;
      -1 !== b && (this._halfedges[b] = a);
    };
    Delaunator.prototype._addTriangle = function(i0, i1, i2, a, b, c) {
      var t = this.trianglesLen;
      this._triangles[t] = i0;
      this._triangles[t + 1] = i1;
      this._triangles[t + 2] = i2;
      this._link(t, a);
      this._link(t + 1, b);
      this._link(t + 2, c);
      this.trianglesLen += 3;
      return t;
    };
    return Delaunator;
  });
};

//# sourceMappingURL=module$node_modules$delaunator$delaunator.js.map
