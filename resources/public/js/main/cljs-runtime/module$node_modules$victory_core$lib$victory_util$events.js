shadow$provide.module$node_modules$victory_core$lib$victory_util$events = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function getExternalMutations(mutations, baseProps, baseState, childName) {
    void 0 === baseProps && (baseProps = {});
    void 0 === baseState && (baseState = {});
    return Object.keys(baseProps).reduce((memo, eventKey) => {
      const keyState = baseState[eventKey] || {}, keyProps = baseProps[eventKey] || {};
      if ("parent" === eventKey) {
        var mutation = getExternalMutation(mutations, keyProps, keyState, {eventKey, target:"parent"});
        memo[eventKey] = void 0 !== mutation ? Object.assign({}, keyState, mutation) : keyState;
      } else {
        mutation = (0,_uniq2.default)(Object.keys(keyProps).concat(Object.keys(keyState))), memo[eventKey] = mutation.reduce((m, target) => {
          const mutation = getExternalMutation(mutations, keyProps[target], keyState[target], {eventKey, target, childName});
          m[target] = void 0 !== mutation ? Object.assign({}, keyState[target], mutation) : keyState[target];
          return (0,_pickBy2.default)(m, v => !(0,_isEmpty2.default)(v));
        }, {});
      }
      return (0,_pickBy2.default)(memo, v => !(0,_isEmpty2.default)(v));
    }, {});
  }
  function getExternalMutation(mutations, baseProps, baseState, identifier) {
    const filterMutations = (mutation, type) => "string" === typeof mutation[type] ? "all" === mutation[type] || mutation[type] === identifier[type] : Array.isArray(mutation[type]) ? mutation[type].map(m => `${m}`).includes(identifier[type]) : !1;
    let scopedMutations = Array.isArray(mutations) ? mutations : [mutations];
    identifier.childName && (scopedMutations = mutations.filter(m => filterMutations(m, "childName")));
    mutations = scopedMutations.filter(m => filterMutations(m, "target"));
    if (!(0,_isEmpty2.default)(mutations) && (mutations = mutations.filter(m => filterMutations(m, "eventKey")), !(0,_isEmpty2.default)(mutations))) {
      return mutations.reduce((memo, curr) => {
        curr = (curr && (0,_helpers.isFunction)(curr.mutation) ? curr.mutation : () => {
        })(Object.assign({}, baseProps, baseState));
        return Object.assign({}, memo, curr);
      }, {});
    }
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.emulateReactEvent = void 0;
  exports.getComponentEvents = function(props, components) {
    return (components = Array.isArray(components) && components.reduce((memo, componentName) => {
      const defaultEvents = (componentName = props[componentName]) && componentName.type && componentName.type.defaultEvents;
      componentName = (0,_helpers.isFunction)(defaultEvents) ? defaultEvents(componentName.props) : defaultEvents;
      return Array.isArray(componentName) ? memo.concat(...componentName) : memo;
    }, [])) && components.length ? components : void 0;
  };
  exports.getEventState = function(eventKey, namespace, childType) {
    const state = this.state || {};
    return childType ? state[childType] && state[childType][eventKey] && state[childType][eventKey][namespace] : "parent" === eventKey ? state[eventKey] && state[eventKey][namespace] || state[eventKey] : state[eventKey] && state[eventKey][namespace];
  };
  exports.getEvents = function(props, target, eventKey, getScopedEvents) {
    var getEventsByTarget = events => {
      const selectedEvents = (() => {
        const targetEvents = events.reduce((memo, event) => void 0 !== event.target ? (Array.isArray(event.target) ? event.target.includes(target) : `${event.target}` === `${target}`) ? memo.concat(event) : memo : memo.concat(event), []);
        return void 0 !== eventKey && "parent" !== target ? targetEvents.filter(obj => {
          obj = obj.eventKey;
          return Array.isArray(obj) ? obj.some(k => k ? `${k}` === `${eventKey}` : !0) : obj ? `${obj}` === `${eventKey}` : !0;
        }) : targetEvents;
      })();
      return Array.isArray(selectedEvents) && selectedEvents.reduce((memo, event) => event ? Object.assign(memo, event.eventHandlers) : memo, {});
    }, allEvents = (() => Array.isArray(this.componentEvents) ? Array.isArray(props.events) ? this.componentEvents.concat(...props.events) : this.componentEvents : props.events)();
    getScopedEvents = allEvents && (0,_helpers.isFunction)(getScopedEvents) ? getScopedEvents(getEventsByTarget(allEvents), target) : void 0;
    if (!props.sharedEvents) {
      return getScopedEvents;
    }
    allEvents = props.sharedEvents.getEvents;
    getEventsByTarget = props.sharedEvents.events && allEvents(getEventsByTarget(props.sharedEvents.events), target);
    return Object.assign({}, getEventsByTarget, getScopedEvents);
  };
  exports.getExternalMutation = getExternalMutation;
  exports.getExternalMutations = getExternalMutations;
  exports.getExternalMutationsWithChildren = function(mutations, baseProps, baseState, childNames) {
    void 0 === baseProps && (baseProps = {});
    void 0 === baseState && (baseState = {});
    return childNames.reduce((memo, childName) => {
      const childState = baseState[childName], mutation = getExternalMutations(mutations, baseProps[childName], baseState[childName], childName);
      memo[childName] = mutation ? mutation : childState;
      return (0,_pickBy2.default)(memo, v => !(0,_isEmpty2.default)(v));
    }, {});
  };
  exports.getGlobalEventNameFromKey = function(key) {
    return (key = key.match(GLOBAL_EVENT_REGEX)) && key[1] && key[1].toLowerCase();
  };
  exports.getGlobalEvents = void 0;
  exports.getPartialEvents = function(events, eventKey, childProps) {
    return events ? Object.keys(events).reduce((memo, eventName) => {
      memo[eventName] = evt => events[eventName](evt, childProps, eventKey, eventName);
      return memo;
    }, {}) : {};
  };
  exports.getScopedEvents = function(events, namespace, childType, baseProps) {
    if ((0,_isEmpty2.default)(events)) {
      return {};
    }
    const newBaseProps = baseProps || this.baseProps, getTargetProps = (identifier, type) => {
      const {childName, target, key} = identifier;
      identifier = "props" === type ? newBaseProps : this.state || {};
      identifier = void 0 !== childName && null !== childName && identifier[childName] ? identifier[childName] : identifier;
      return "parent" === key ? identifier.parent : identifier[key] && identifier[key][target];
    }, parseEvent = (eventReturn, eventKey) => {
      var childNames = "parent" === namespace ? eventReturn.childName : eventReturn.childName || childType;
      const target = eventReturn.target || namespace, getKeys = childName => "parent" === target ? "parent" : "all" === eventReturn.eventKey ? newBaseProps[childName] ? Object.keys(newBaseProps[childName]).filter(value => "parent" !== value) : Object.keys(newBaseProps).filter(value => "parent" !== value) : void 0 === eventReturn.eventKey && "parent" === eventKey ? newBaseProps[childName] ? Object.keys(newBaseProps[childName]) : Object.keys(newBaseProps) : void 0 !== eventReturn.eventKey ? eventReturn.eventKey : 
      eventKey, getMutationObject = (key, childName) => {
        const baseState = this.state || {};
        if (!(0,_helpers.isFunction)(eventReturn.mutation)) {
          return baseState;
        }
        var mutationTargetProps = getTargetProps({childName, key, target}, "props"), mutationTargetState = getTargetProps({childName, key, target}, "state");
        const mutatedProps = eventReturn.mutation(Object.assign({}, mutationTargetProps, mutationTargetState), newBaseProps);
        mutationTargetProps = baseState[childName] || {};
        mutationTargetState = state => {
          state[key] && state[key][target] && delete state[key][target];
          state[key] && !Object.keys(state[key]).length && delete state[key];
          return state;
        };
        const extendState = state => "parent" === target ? Object.assign(state, {[key]:Object.assign(state[key] || {}, mutatedProps)}) : Object.assign(state, {[key]:Object.assign(state[key] || {}, {[target]:mutatedProps})});
        return void 0 !== childName && null !== childName ? Object.assign(baseState, {[childName]:mutatedProps ? extendState(mutationTargetProps) : mutationTargetState(mutationTargetProps)}) : mutatedProps ? extendState(baseState) : mutationTargetState(baseState);
      }, getReturnByChild = childName => {
        const mutationKeys = getKeys(childName);
        return Array.isArray(mutationKeys) ? mutationKeys.reduce((memo, key) => Object.assign(memo, getMutationObject(key, childName)), {}) : getMutationObject(mutationKeys, childName);
      };
      childNames = "all" === childNames ? Object.keys(newBaseProps).filter(value => "parent" !== value) : childNames;
      return Array.isArray(childNames) ? childNames.reduce((memo, childName) => Object.assign(memo, getReturnByChild(childName)), {}) : getReturnByChild(childNames);
    }, parseEventReturn = (eventReturn, eventKey) => Array.isArray(eventReturn) ? eventReturn.reduce((memo, props) => Object.assign({}, memo, parseEvent(props, eventKey)), {}) : parseEvent(eventReturn, eventKey), compileCallbacks = eventReturn => {
      const getCallback = obj => (0,_helpers.isFunction)(obj.callback) && obj.callback, callbackArray = (Array.isArray(eventReturn) ? eventReturn.map(evtObj => getCallback(evtObj)) : [getCallback(eventReturn)]).filter(callback => !1 !== callback);
      return callbackArray.length ? () => callbackArray.forEach(callback => callback()) : void 0;
    }, onEvent = (evt, childProps, eventKey, eventName) => {
      evt = events[eventName](evt, childProps, eventKey, this);
      (0,_isEmpty2.default)(evt) || (childProps = compileCallbacks(evt), this.setState(parseEventReturn(evt, eventKey), childProps));
    };
    return Object.keys(events).reduce((memo, event) => {
      memo[event] = onEvent;
      return memo;
    }, {});
  };
  exports.omitGlobalEvents = void 0;
  var _uniq2 = _interopRequireDefault(require("module$node_modules$lodash$uniq")), _omitBy2 = _interopRequireDefault(require("module$node_modules$lodash$omitBy")), _pickBy2 = _interopRequireDefault(require("module$node_modules$lodash$pickBy")), _isEmpty2 = _interopRequireDefault(require("module$node_modules$lodash$isEmpty")), _helpers = require("module$node_modules$victory_core$lib$victory_util$helpers");
  const GLOBAL_EVENT_REGEX = /^onGlobal(.*)$/;
  exports.getGlobalEvents = events => (0,_pickBy2.default)(events, (_, key) => GLOBAL_EVENT_REGEX.test(key));
  exports.omitGlobalEvents = events => (0,_omitBy2.default)(events, (_, key) => GLOBAL_EVENT_REGEX.test(key));
  exports.emulateReactEvent = event => Object.assign(event, {nativeEvent:event});
};

//# sourceMappingURL=module$node_modules$victory_core$lib$victory_util$events.js.map
