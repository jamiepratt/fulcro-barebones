shadow$provide.module$node_modules$victory_axis$lib$victory_axis = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.VictoryAxis = void 0;
  var _isEmpty2 = _interopRequireDefault(require("module$node_modules$lodash$isEmpty")), _react = _interopRequireDefault(require("module$node_modules$react$index")), _victoryCore = require("module$node_modules$victory_core$lib$index"), _helperMethods = require("module$node_modules$victory_axis$lib$helper_methods");
  const fallbackProps = {width:450, height:300, padding:50};
  class VictoryAxisBase extends _react.default.Component {
    static $jscomp$static$init$269151619$0$animationWhitelist() {
      return "style domain range tickCount tickValues offsetX offsetY padding width height".split(" ");
    }
    static $jscomp$static$init$269151619$1$displayName() {
      return "VictoryAxis";
    }
    static $jscomp$static$init$269151619$2$role() {
      return "axis";
    }
    static $jscomp$static$init$269151619$3$defaultTransitions() {
      return {onExit:{duration:500}, onEnter:{duration:500}};
    }
    static $jscomp$static$init$269151619$4$defaultProps() {
      return {axisComponent:_react.default.createElement(_victoryCore.LineSegment, null), axisLabelComponent:_react.default.createElement(_victoryCore.VictoryLabel, null), tickLabelComponent:_react.default.createElement(_victoryCore.VictoryLabel, null), tickComponent:_react.default.createElement(_victoryCore.LineSegment, null), gridComponent:_react.default.createElement(_victoryCore.LineSegment, null), standalone:!0, theme:_victoryCore.VictoryTheme.grayscale, containerComponent:_react.default.createElement(_victoryCore.VictoryContainer, 
      null), groupComponent:_react.default.createElement("g", {role:"presentation"}), fixLabelOverlap:!1};
    }
    static $jscomp$static$init$269151619$5$getDomain() {
      return _victoryCore.Axis.getDomain;
    }
    static $jscomp$static$init$269151619$6$getAxis() {
      return _victoryCore.Axis.getAxis;
    }
    static getStyles(props) {
      return (0,_helperMethods.getStyles)(props);
    }
    static getBaseProps(props) {
      return (0,_helperMethods.getBaseProps)(props, fallbackProps);
    }
    static $jscomp$static$init$269151619$7$expectedComponents() {
      return "axisComponent axisLabelComponent groupComponent containerComponent tickComponent tickLabelComponent gridComponent".split(" ");
    }
    renderLine(props) {
      ({axisComponent:props} = props);
      const axisProps = this.getComponentProps(props, "axis", 0);
      return _react.default.cloneElement(props, axisProps);
    }
    renderLabel(props) {
      const {axisLabelComponent, label} = props;
      if (!label) {
        return null;
      }
      props = this.getComponentProps(axisLabelComponent, "axisLabel", 0);
      return _react.default.cloneElement(axisLabelComponent, props);
    }
    renderGridAndTicks(props) {
      const {tickComponent, tickLabelComponent, gridComponent, name} = props, shouldRender = componentProps => {
        const {style = {}, events = {}} = componentProps;
        return "transparent" !== style.stroke && "none" !== style.stroke && 0 !== style.strokeWidth || !(0,_isEmpty2.default)(events);
      };
      return this.dataKeys.map((key, index) => {
        var tickProps = this.getComponentProps(tickComponent, "ticks", index);
        tickProps = _react.default.cloneElement(tickComponent, tickProps);
        tickProps = shouldRender(tickProps.props) ? tickProps : void 0;
        var gridProps = this.getComponentProps(gridComponent, "grid", index);
        gridProps = _react.default.cloneElement(gridComponent, gridProps);
        gridProps = shouldRender(gridProps.props) ? gridProps : void 0;
        index = this.getComponentProps(tickLabelComponent, "tickLabels", index);
        index = _react.default.cloneElement(tickLabelComponent, index);
        index = [gridProps, tickProps, index].filter(Boolean);
        return _react.default.cloneElement(props.groupComponent, {key:`${name}-tick-group-${key}`}, index);
      });
    }
    fixLabelOverlap(gridAndTicks, props) {
      const isVertical = _victoryCore.Axis.isVertical(props);
      props = isVertical ? props.height : props.width;
      const isVictoryLabel = child => child.type && "label" === child.type.role, labelsSumSize = gridAndTicks.map(gridAndTick => gridAndTick.props.children).reduce((accumulator, childArr) => accumulator.concat(childArr), []).filter(isVictoryLabel).map(child => child.props).reduce((sum, label) => {
        var JSCompiler_inline_result = label.style.padding;
        JSCompiler_inline_result = "object" === typeof JSCompiler_inline_result ? Object.assign({}, {top:0, right:0, bottom:0, left:0}, JSCompiler_inline_result) : {top:JSCompiler_inline_result, right:JSCompiler_inline_result, bottom:JSCompiler_inline_result, left:JSCompiler_inline_result};
        label = _victoryCore.TextSize.approximateTextSize(label.text, {angle:label.angle, fontSize:label.style.fontSize, letterSpacing:label.style.letterSpacing, fontFamily:label.style.fontFamily});
        return sum + (isVertical ? label.height + JSCompiler_inline_result.top + JSCompiler_inline_result.bottom : label.width + JSCompiler_inline_result.right + JSCompiler_inline_result.left);
      }, 0), divider = Math.ceil(gridAndTicks.length / Math.floor(props * gridAndTicks.length / labelsSumSize)) || 1, getLabelCoord = gridAndTick => gridAndTick.props.children.filter(isVictoryLabel).reduce((prev, child) => (isVertical ? child.props.y : child.props.x) || 0, 0);
      return gridAndTicks.sort((a, b) => isVertical ? getLabelCoord(b) - getLabelCoord(a) : getLabelCoord(a) - getLabelCoord(b)).filter((gridAndTick, index) => 0 === index % divider);
    }
    shouldAnimate() {
      return !!this.props.animate;
    }
    render() {
      var {animationWhitelist} = VictoryAxis;
      const props = _victoryCore.Axis.modifyProps(this.props, fallbackProps), userProps = _victoryCore.UserProps.getSafeUserProps(this.props);
      if (this.shouldAnimate()) {
        return this.animateComponent(props, animationWhitelist);
      }
      animationWhitelist = this.renderGridAndTicks(props);
      animationWhitelist = props.fixLabelOverlap ? this.fixLabelOverlap(animationWhitelist, props) : animationWhitelist;
      animationWhitelist = [this.renderLine(props), this.renderLabel(props), ...animationWhitelist];
      const container = _react.default.cloneElement(props.containerComponent, userProps);
      return props.standalone ? this.renderContainer(container, animationWhitelist) : _react.default.cloneElement(props.groupComponent, userProps, animationWhitelist);
    }
  }
  VictoryAxisBase.animationWhitelist = VictoryAxisBase.$jscomp$static$init$269151619$0$animationWhitelist();
  VictoryAxisBase.displayName = VictoryAxisBase.$jscomp$static$init$269151619$1$displayName();
  VictoryAxisBase.role = VictoryAxisBase.$jscomp$static$init$269151619$2$role();
  VictoryAxisBase.defaultTransitions = VictoryAxisBase.$jscomp$static$init$269151619$3$defaultTransitions();
  VictoryAxisBase.defaultProps = VictoryAxisBase.$jscomp$static$init$269151619$4$defaultProps();
  VictoryAxisBase.getDomain = VictoryAxisBase.$jscomp$static$init$269151619$5$getDomain();
  VictoryAxisBase.getAxis = VictoryAxisBase.$jscomp$static$init$269151619$6$getAxis();
  VictoryAxisBase.expectedComponents = VictoryAxisBase.$jscomp$static$init$269151619$7$expectedComponents();
  const VictoryAxis = exports.VictoryAxis = (0,_victoryCore.addEvents)(VictoryAxisBase, {components:[{name:"axis", index:0}, {name:"axisLabel", index:0}, {name:"grid"}, {name:"parent", index:"parent"}, {name:"ticks"}, {name:"tickLabels"}]});
};

//# sourceMappingURL=module$node_modules$victory_axis$lib$victory_axis.js.map
