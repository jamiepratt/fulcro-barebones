shadow$provide.module$node_modules$victory_polar_axis$lib$helper_methods = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.getStyles = exports.getScale = exports.getBaseProps = void 0;
  var _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _uniqBy2 = _interopRequireDefault(require("module$node_modules$lodash$uniqBy")), _victoryCore = require("module$node_modules$victory_core$lib$index");
  const getPosition = (r, angle, axis) => "x" === axis ? r * Math.cos(angle) : -r * Math.sin(angle), getAxisType = props => {
    const typicalType = props.dependentAxis ? "radial" : "angular";
    return props.horizontal ? "angular" === typicalType ? "radial" : "angular" : typicalType;
  }, filterTicks = (ticks, scale) => (0,_uniqBy2.default)(ticks, t => scale(t) % (2 * Math.PI)), getEvaluatedStyles = (style, props) => ({tickStyle:_victoryCore.Helpers.evaluateStyle(style.ticks, props), labelStyle:_victoryCore.Helpers.evaluateStyle(style.tickLabels, props), gridStyle:_victoryCore.Helpers.evaluateStyle(style.grid, props)}), getStyleObject = props => {
    const {theme = {}, dependentAxis} = props, generalAxisStyle = theme.polarAxis && theme.polarAxis.style || theme.axis && theme.axis.style, specificAxisStyle = theme?.[dependentAxis ? "polarDependentAxis" : "polarIndependentAxis"]?.style || theme?.[dependentAxis ? "dependentAxis" : "independentAxis"]?.style;
    props = () => "axis axisLabel grid parent tickLabels ticks".split(" ").reduce((memo, curr) => {
      memo[curr] = (0,_defaults2.default)({}, specificAxisStyle?.[curr], generalAxisStyle?.[curr]);
      return memo;
    }, {});
    return generalAxisStyle && specificAxisStyle ? props() : specificAxisStyle || generalAxisStyle;
  }, getRadius = props => {
    const {left, right, top, bottom} = _victoryCore.Helpers.getPadding(props), {width, height} = props;
    if (void 0 === width || void 0 === height) {
      throw Error("VictoryPolarAxis: width and height properties are required for standalone axes.");
    }
    return Math.min(width - left - right, height - top - bottom) / 2;
  }, getRange = (props, axis) => {
    if (props.range && props.range[axis]) {
      return props.range[axis];
    }
    if (props.range && Array.isArray(props.range)) {
      return props.range;
    }
    if ("angular" === getAxisType(props)) {
      return axis = _victoryCore.Helpers.degreesToRadians(props.startAngle), props = _victoryCore.Helpers.degreesToRadians(props.endAngle), [axis, props];
    }
    axis = getRadius(props);
    return [props.innerRadius || 0, axis];
  }, getScale = props => {
    const axis = _victoryCore.Axis.getAxis(props), scale = _victoryCore.Scale.getBaseScale(props, axis), domain = _victoryCore.Axis.getDomain(props, axis) || scale.domain();
    props = getRange(props, axis);
    scale.range(props);
    scale.domain(domain);
    return scale;
  };
  exports.getScale = getScale;
  const getStyles = function(props, styleObject) {
    void 0 === styleObject && (styleObject = {});
    if (props.disableInlineStyles) {
      return {};
    }
    props = props.style || {};
    return {parent:(0,_defaults2.default)({height:"auto", width:"100%"}, props.parent, styleObject.parent), axis:(0,_defaults2.default)({}, props.axis, styleObject.axis), axisLabel:(0,_defaults2.default)({}, props.axisLabel, styleObject.axisLabel), grid:(0,_defaults2.default)({}, props.grid, styleObject.grid), ticks:(0,_defaults2.default)({}, props.ticks, styleObject.ticks), tickLabels:(0,_defaults2.default)({}, props.tickLabels, styleObject.tickLabels)};
  };
  exports.getStyles = getStyles;
  const getAxisAngle = props => {
    const {axisAngle, startAngle, dependentAxis} = props, axis = _victoryCore.Axis.getAxis(props);
    props = _victoryCore.Axis.getAxisValue(props, axis);
    return void 0 !== props && dependentAxis ? _victoryCore.Helpers.radiansToDegrees(props) : void 0 === axisAngle ? startAngle : axisAngle;
  }, getAxisLabelProps = (props, calculatedValues) => {
    const {axisType, radius, style, origin} = calculatedValues;
    ({axisLabelComponent:calculatedValues} = props);
    if ("radial" !== axisType) {
      return {};
    }
    var labelPlacement = calculatedValues?.props.labelPlacement ? calculatedValues.props.labelPlacement : props.labelPlacement;
    calculatedValues = style && style.axisLabel || {};
    const axisAngle = "radial" === axisType ? getAxisAngle(props) : void 0, textAngle = void 0 === calculatedValues.angle ? _victoryCore.LabelHelpers.getPolarAngle(Object.assign({}, props, {labelPlacement}), axisAngle) : calculatedValues.angle, labelRadius = radius + (calculatedValues.padding || 0), textAnchor = calculatedValues.textAnchor || _victoryCore.LabelHelpers.getPolarTextAnchor(Object.assign({}, props, {labelPlacement}), axisAngle);
    labelPlacement = calculatedValues.verticalAnchor || _victoryCore.LabelHelpers.getPolarVerticalAnchor(Object.assign({}, props, {labelPlacement}), axisAngle);
    return {style:calculatedValues, angle:textAngle, textAnchor, verticalAnchor:labelPlacement, text:props.label, x:getPosition(labelRadius, _victoryCore.Helpers.degreesToRadians(axisAngle), "x") + origin.x, y:getPosition(labelRadius, _victoryCore.Helpers.degreesToRadians(axisAngle), "y") + origin.y};
  }, getAxisProps = (modifiedProps, calculatedValues) => {
    const {style, axisType, radius, origin} = calculatedValues, {startAngle, endAngle, innerRadius = 0} = modifiedProps;
    modifiedProps = "radial" === axisType ? _victoryCore.Helpers.degreesToRadians(getAxisAngle(modifiedProps)) : void 0;
    return "radial" === axisType ? {style:style.axis, x1:getPosition(innerRadius, modifiedProps, "x") + origin.x, x2:getPosition(radius, modifiedProps, "x") + origin.x, y1:getPosition(innerRadius, modifiedProps, "y") + origin.y, y2:getPosition(radius, modifiedProps, "y") + origin.y} : {style:style.axis, cx:origin.x, cy:origin.y, r:radius, startAngle, endAngle};
  }, getCalculatedValues = initialProps => {
    initialProps = Object.assign({polar:!0}, initialProps);
    var defaultStyles = getStyleObject(initialProps);
    defaultStyles = getStyles(initialProps, defaultStyles);
    const padding = _victoryCore.Helpers.getPadding(initialProps), axis = _victoryCore.Axis.getAxis(initialProps), axisType = getAxisType(initialProps), stringTicks = _victoryCore.Axis.stringTicks(initialProps) ? initialProps.tickValues : void 0, domain = _victoryCore.Axis.getDomain(initialProps, axis), range = getRange(initialProps, axis), scale = getScale(initialProps);
    var initialTicks = _victoryCore.Axis.getTicks(initialProps, scale);
    initialTicks = "angular" === axisType ? filterTicks(initialTicks, scale) : initialTicks;
    const tickFormat = _victoryCore.Axis.getTickFormat(initialProps, scale), radius = getRadius(initialProps);
    initialProps = _victoryCore.Helpers.getPolarOrigin(initialProps);
    return {axis, style:defaultStyles, padding, stringTicks, axisType, scale, ticks:initialTicks, tickFormat, domain, range, radius, origin:initialProps};
  };
  exports.getBaseProps = (initialProps, fallbackProps) => {
    const props = _victoryCore.Axis.modifyProps(initialProps, fallbackProps), calculatedValues = getCalculatedValues(props), {style, scale, ticks, domain} = calculatedValues, {width, height, standalone, theme, name} = props, axisProps = getAxisProps(props, calculatedValues), axisLabelProps = getAxisLabelProps(props, calculatedValues);
    return ticks.reduce((childProps, tick, index) => {
      const {axisType, radius, scale, style, stringTicks, ticks, tickFormat, origin} = calculatedValues;
      var text = tickFormat(tick, index, ticks);
      var JSCompiler_inline_result = stringTicks ? stringTicks[index] : tick;
      ({tickStyle:text} = getEvaluatedStyles(style, {tick:JSCompiler_inline_result, tickValue:tick, index, ticks, stringTicks, radius, scale, axisType, text}));
      var axisAngle = "radial" === axisType ? getAxisAngle(props) : void 0, tickPadding = text.padding || text.size || 0, padAngle = _victoryCore.Helpers.degreesToRadians(90 - axisAngle);
      axisAngle = "angular" === axisType ? scale(tick) : _victoryCore.Helpers.degreesToRadians(-1 * axisAngle);
      var tickRadius = "angular" === axisType ? radius : scale(tick);
      JSCompiler_inline_result = "angular" === axisType ? {index, datum:JSCompiler_inline_result, style:text, x1:getPosition(tickRadius, axisAngle, "x") + origin.x, y1:getPosition(tickRadius, axisAngle, "y") + origin.y, x2:getPosition(tickRadius + tickPadding, axisAngle, "x") + origin.x, y2:getPosition(tickRadius + tickPadding, axisAngle, "y") + origin.y} : {index, datum:JSCompiler_inline_result, style:text, x1:tickRadius * Math.cos(axisAngle) + Math.cos(padAngle) * tickPadding + origin.x, x2:tickRadius * 
      Math.cos(axisAngle) - Math.cos(padAngle) * tickPadding + origin.x, y1:tickRadius * Math.sin(axisAngle) + Math.sin(padAngle) * tickPadding + origin.y, y2:tickRadius * Math.sin(axisAngle) - Math.sin(padAngle) * tickPadding + origin.y};
      const {axisType:axisType$jscomp$0, radius:radius$jscomp$0, tickFormat:tickFormat$jscomp$0, style:style$jscomp$0, scale:scale$jscomp$0, ticks:ticks$jscomp$0, stringTicks:stringTicks$jscomp$0, origin:origin$jscomp$0} = calculatedValues;
      text = tickFormat$jscomp$0(tick, index, ticks$jscomp$0);
      tickPadding = stringTicks$jscomp$0 ? stringTicks$jscomp$0[index] : tick;
      ({labelStyle:padAngle} = getEvaluatedStyles(style$jscomp$0, {text, tick:tickPadding, tickValue:tick, index, ticks:ticks$jscomp$0, stringTicks:stringTicks$jscomp$0, radius:radius$jscomp$0, scale:scale$jscomp$0, axisType:axisType$jscomp$0}));
      ({tickLabelComponent:axisAngle} = props);
      axisAngle = axisAngle?.props.labelPlacement ? axisAngle.props.labelPlacement : props.labelPlacement;
      var tickPadding$jscomp$0 = padAngle.padding || 0;
      tickRadius = "radial" === axisType$jscomp$0 ? getAxisAngle(props) : void 0;
      tickRadius = "angular" === axisType$jscomp$0 ? _victoryCore.Helpers.radiansToDegrees(scale$jscomp$0(tick)) : tickRadius + 0;
      const textAngle = void 0 === padAngle.angle ? _victoryCore.LabelHelpers.getPolarAngle(Object.assign({}, props, {labelPlacement:axisAngle}), tickRadius) : padAngle.angle;
      tickPadding$jscomp$0 = "angular" === axisType$jscomp$0 ? radius$jscomp$0 + tickPadding$jscomp$0 : scale$jscomp$0(tick);
      axisAngle = padAngle.textAnchor || _victoryCore.LabelHelpers.getPolarTextAnchor(Object.assign({}, props, {labelPlacement:axisAngle}), tickRadius);
      text = {index, datum:tickPadding, style:padAngle, angle:textAngle, textAnchor:axisAngle, text, x:tickPadding$jscomp$0 * Math.cos(_victoryCore.Helpers.degreesToRadians(tickRadius)) + origin$jscomp$0.x, y:-tickPadding$jscomp$0 * Math.sin(_victoryCore.Helpers.degreesToRadians(tickRadius)) + origin$jscomp$0.y};
      const {axisType:axisType$jscomp$1, radius:radius$jscomp$1, style:style$jscomp$1, scale:scale$jscomp$1, stringTicks:stringTicks$jscomp$1, ticks:ticks$jscomp$1, tickFormat:tickFormat$jscomp$1, origin:origin$jscomp$1} = calculatedValues;
      padAngle = tickFormat$jscomp$1(tick, index, ticks$jscomp$1);
      const {startAngle, endAngle, innerRadius = 0} = props;
      tickPadding = stringTicks$jscomp$1 ? stringTicks$jscomp$1[index] : tick;
      ({gridStyle:padAngle} = getEvaluatedStyles(style$jscomp$1, {tick:tickPadding, tickValue:tick, index, ticks:ticks$jscomp$1, stringTicks:stringTicks$jscomp$1, radius:radius$jscomp$1, scale:scale$jscomp$1, axisType:axisType$jscomp$1, text:padAngle}));
      axisAngle = scale$jscomp$1(tick);
      tick = "angular" === axisType$jscomp$1 ? {index, datum:tickPadding, style:padAngle, x1:getPosition(radius$jscomp$1, axisAngle, "x") + origin$jscomp$1.x, y1:getPosition(radius$jscomp$1, axisAngle, "y") + origin$jscomp$1.y, x2:getPosition(innerRadius, axisAngle, "x") + origin$jscomp$1.x, y2:getPosition(innerRadius, axisAngle, "y") + origin$jscomp$1.y} : {style:padAngle, index, datum:tickPadding, cx:origin$jscomp$1.x, cy:origin$jscomp$1.y, r:scale$jscomp$1(tick), startAngle, endAngle};
      childProps[index] = {axis:axisProps, axisLabel:axisLabelProps, ticks:JSCompiler_inline_result, tickLabels:text, grid:tick};
      return childProps;
    }, {parent:{style:style.parent, ticks, scale, width, height, domain, standalone, theme, name}});
  };
};

//# sourceMappingURL=module$node_modules$victory_polar_axis$lib$helper_methods.js.map
