{
"version":3,
"file":"module$node_modules$victory_core$lib$victory_animation$util.js",
"lineCount":69,
"mappings":"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",
"sources":["node_modules/victory-core/lib/victory-animation/util.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$victory_core$lib$victory_animation$util\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.victoryInterpolator = exports.isInterpolatable = exports.interpolateString = exports.interpolateObject = exports.interpolateImmediate = exports.interpolateFunction = void 0;\nvar _orderBy2 = _interopRequireDefault(require(\"lodash/orderBy\"));\nvar _isPlainObject2 = _interopRequireDefault(require(\"lodash/isPlainObject\"));\nvar _d3Interpolate = require(\"victory-vendor/d3-interpolate\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nconst isInterpolatable = function (obj) {\n  // d3 turns null into 0 and undefined into NaN, which we don't want.\n  if (obj !== null) {\n    switch (typeof obj) {\n      case \"undefined\":\n        return false;\n      case \"number\":\n        // The standard `isNaN` is fine in this case since we already know the\n        // type is number.\n        return !isNaN(obj) && obj !== Number.POSITIVE_INFINITY && obj !== Number.NEGATIVE_INFINITY;\n      case \"string\":\n        // d3 might not *actually* be able to interpolate the string, but it\n        // won't cause any issues to let it try.\n        return true;\n      case \"boolean\":\n        // d3 turns Booleans into integers, which we don't want. Sure, we could\n        // interpolate from 0 -> 1, but we'd be sending a non-Boolean to\n        // something expecting a Boolean.\n        return false;\n      case \"object\":\n        // Don't try to interpolate class instances (except Date or Array).\n        return obj instanceof Date || Array.isArray(obj) || (0, _isPlainObject2.default)(obj);\n      case \"function\":\n        // Careful! There may be extra properties on function objects that the\n        // component expects to access - for instance, it may be a `d3.scale()`\n        // function, which has its own methods attached. We don't know if the\n        // component is only going to call the function (in which case it's\n        // safely interpolatable) or if it's going to access special properties\n        // (in which case our function generated from `interpolateFunction` will\n        // most likely cause an error). We could check for enumerable properties\n        // on the function object here to see if it's a \"plain\" function, but\n        // let's just require that components prevent such function props from\n        // being animated in the first place.\n        return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Interpolate immediately to the end value at the given step `when`.\n * Some nicer default behavior might be to jump at the halfway point or return\n * `a` if `t` is 0 (instead of always returning `b`). But d3's default\n * interpolator does not do these things:\n *\n *   d3.interpolate('aaa', 'bbb')(0) === 'bbb'\n *\n * ...and things might get wonky if we don't replicate that behavior.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @param {Number} when - Step value (0 to 1) at which to jump to `b`.\n * @returns {Function} An interpolation function.\n */\nexports.isInterpolatable = isInterpolatable;\nconst interpolateImmediate = function (a, b, when) {\n  if (when === void 0) {\n    when = 0;\n  }\n  return function (t) {\n    return t < when ? a : b;\n  };\n};\n\n/**\n * Interpolate to or from a function. The interpolated value will be a function\n * that calls `a` (if it's a function) and `b` (if it's a function) and calls\n * `d3.interpolate` on the resulting values. Note that our function won't\n * necessarily be called (that's up to the component this eventually gets\n * passed to) - but if it does get called, it will return an appropriately\n * interpolated value.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function} An interpolation function.\n */\nexports.interpolateImmediate = interpolateImmediate;\nconst interpolateFunction = function (a, b) {\n  return function (t) {\n    if (t >= 1) {\n      return b;\n    }\n    return function () {\n      /* eslint-disable no-invalid-this, prefer-rest-params */\n      const aval = typeof a === \"function\" ? a.apply(this, arguments) : a;\n      const bval = typeof b === \"function\" ? b.apply(this, arguments) : b;\n      return (0, _d3Interpolate.interpolate)(aval, bval)(t);\n    };\n  };\n};\n\n/**\n * Interpolate to or from an object. This method is a modification of the object interpolator in\n * d3-interpolate https://github.com/d3/d3-interpolate/blob/master/src/object.js. This interpolator\n * differs in that it uses our custom interpolators when interpolating the value of each property in\n * an object. This allows the correct interpolation of nested objects, including styles\n *\n * @param {any} startValue - Start value.\n * @param {any} endValue - End value.\n * @returns {Function} An interpolation function.\n */\nexports.interpolateFunction = interpolateFunction;\nconst interpolateObject = function (startValue, endValue) {\n  const interpolateTypes = (x, y) => {\n    if (x === y || !isInterpolatable(x) || !isInterpolatable(y)) {\n      return interpolateImmediate(x, y);\n    }\n    if (typeof x === \"function\" || typeof y === \"function\") {\n      return interpolateFunction(x, y);\n    }\n    if (typeof x === \"object\" && (0, _isPlainObject2.default)(x) || typeof y === \"object\" && (0, _isPlainObject2.default)(y)) {\n      return interpolateObject(x, y);\n    }\n    return (0, _d3Interpolate.interpolate)(x, y);\n  };\n\n  // When the value is an array, attempt to sort by \"key\" so that animating nodes may be identified\n  // based on \"key\" instead of index\n  const keyData = val => {\n    return Array.isArray(val) ? (0, _orderBy2.default)(val, \"key\") : val;\n  };\n  const i = {};\n  const c = {};\n  let a = startValue;\n  let b = endValue;\n  let k;\n  if (a === null || typeof a !== \"object\") {\n    a = {};\n  }\n  if (b === null || typeof b !== \"object\") {\n    b = {};\n  }\n  for (k in b) {\n    if (k in a) {\n      i[k] = interpolateTypes(keyData(a[k]), keyData(b[k]));\n    } else {\n      c[k] = b[k];\n    }\n  }\n  return function (t) {\n    for (k in i) {\n      c[k] = i[k](t);\n    }\n    return c;\n  };\n};\nexports.interpolateObject = interpolateObject;\nconst interpolateString = function (a, b) {\n  const format = val => {\n    return typeof val === \"string\" ? val.replace(/,/g, \"\") : val;\n  };\n  return (0, _d3Interpolate.interpolate)(format(a), format(b));\n};\n\n/**\n * By default, the list of interpolators used by `d3.interpolate` has a few\n * downsides:\n *\n * - `null` values get turned into 0.\n * - `undefined`, `function`, and some other value types get turned into NaN.\n * - Boolean types get turned into numbers, which probably will be meaningless\n *   to whatever is consuming them.\n * - It tries to interpolate between identical start and end values, doing\n *   unnecessary calculations that sometimes result in floating point rounding\n *   errors.\n *\n * If only the default interpolators are used, `VictoryAnimation` will happily\n * pass down NaN (and other bad) values as props to the wrapped component.\n * The component will then either use the incorrect values or complain that it\n * was passed props of the incorrect type. This custom interpolator is added\n * using the `d3.interpolators` API, and prevents such cases from happening\n * for most values.\n *\n * @param {any} a - Start value.\n * @param {any} b - End value.\n * @returns {Function|undefined} An interpolation function, if necessary.\n */\nexports.interpolateString = interpolateString;\nconst victoryInterpolator = function (a, b) {\n  // If the values are strictly equal, or either value is not interpolatable,\n  // just use either the start value `a` or end value `b` at every step, as\n  // there is no reasonable in-between value.\n  if (a === b || !isInterpolatable(a) || !isInterpolatable(b)) {\n    return interpolateImmediate(a, b);\n  }\n  if (typeof a === \"function\" || typeof b === \"function\") {\n    return interpolateFunction(a, b);\n  }\n  if ((0, _isPlainObject2.default)(a) || (0, _isPlainObject2.default)(b)) {\n    // @ts-expect-error These generics are tough, but they work :)\n    return interpolateObject(a, b);\n  }\n  if (typeof a === \"string\" || typeof b === \"string\") {\n    return interpolateString(a, b);\n  }\n  // @ts-expect-error These generics are tough, but they work :)\n  return (0, _d3Interpolate.interpolate)(a, b);\n};\nexports.victoryInterpolator = victoryInterpolator;\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","victoryInterpolator","isInterpolatable","interpolateString","interpolateObject","interpolateImmediate","interpolateFunction","_orderBy2","_isPlainObject2","_d3Interpolate","isNaN","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","Date","Array","isArray","a","b","when","t","aval","apply","arguments","bval","interpolate","startValue","endValue","interpolateTypes","x","y","keyData","val","i","c","k","format","replace"]
}
