shadow$provide.module$node_modules$victory_core$lib$victory_label$victory_label = function(global, require, module, exports) {
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) {
      return null;
    }
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
      return e ? t : r;
    })(e);
  }
  function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) {
      return e;
    }
    if (null === e || "object" != typeof e && "function" != typeof e) {
      return {default:e};
    }
    if ((r = _getRequireWildcardCache(r)) && r.has(e)) {
      return r.get(e);
    }
    var n = {__proto__:null}, a = Object.defineProperty && Object.getOwnPropertyDescriptor, u;
    for (u in e) {
      if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
    }
    return n.default = e, r && r.set(e, n), n;
  }
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.VictoryLabel = void 0;
  var _isEmpty2 = _interopRequireDefault(require("module$node_modules$lodash$isEmpty")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults")), _react = _interopRequireDefault(require("module$node_modules$react$index")), _victoryPortal = require("module$node_modules$victory_core$lib$victory_portal$victory_portal");
  global = require("module$node_modules$victory_core$lib$victory_primitives$rect");
  module = require("module$node_modules$victory_core$lib$victory_primitives$text");
  var _tspan = require("module$node_modules$victory_core$lib$victory_primitives$tspan"), Helpers = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$helpers")), LabelHelpers = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$label_helpers")), Log = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$log")), Style = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$style")), 
  TextSize = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$textsize")), UserProps = _interopRequireWildcard(require("module$node_modules$victory_core$lib$victory_util$user_props"));
  const defaultStyles = {fill:"#252525", fontSize:14, fontFamily:"'Gill Sans', 'Gill Sans MT', 'SerÂ­avek', 'Trebuchet MS', sans-serif", stroke:"transparent"}, getFontSize = style => {
    style = style && style.fontSize;
    if ("number" === typeof style) {
      return style;
    }
    if (void 0 !== style && null !== style && "string" === typeof style) {
      style = Number(style.replace("px", ""));
      if (!isNaN(style)) {
        return style;
      }
      Log.warn("fontSize should be expressed as a number of pixels");
    }
    return defaultStyles.fontSize;
  }, getSingleValue = function(prop, index) {
    void 0 === index && (index = 0);
    return Array.isArray(prop) ? prop[index] || prop[0] : prop;
  }, shouldUseMultilineBackgrounds = props => {
    const {backgroundStyle, backgroundPadding} = props;
    return Array.isArray(backgroundStyle) && !(0,_isEmpty2.default)(backgroundStyle) || Array.isArray(backgroundPadding) && !(0,_isEmpty2.default)(backgroundPadding);
  }, getStyles = (style, props) => {
    if (props.disableInlineStyles) {
      return style = Helpers.evaluateStyle(style, props), {fontSize:getFontSize(style)};
    }
    const getSingleStyle = s => {
      s = Helpers.evaluateStyle(s ? (0,_defaults2.default)({}, s, defaultStyles) : defaultStyles, props);
      return Object.assign({}, s, {fontSize:getFontSize(s)});
    };
    return Array.isArray(style) && !(0,_isEmpty2.default)(style) ? style.map(s => getSingleStyle(s)) : getSingleStyle(style);
  }, getBackgroundStyles = (style, props) => {
    if (style) {
      return Array.isArray(style) && !(0,_isEmpty2.default)(style) ? style.map(s => Helpers.evaluateStyle(s, props)) : Helpers.evaluateStyle(style, props);
    }
  }, getBackgroundPadding = props => {
    if (props.backgroundPadding && Array.isArray(props.backgroundPadding)) {
      return props.backgroundPadding.map(backgroundPadding => {
        backgroundPadding = Helpers.evaluateProp(backgroundPadding, props);
        return Helpers.getPadding({padding:backgroundPadding});
      });
    }
    const padding = Helpers.evaluateProp(props.backgroundPadding, props);
    return Helpers.getPadding({padding});
  }, getContent = (text, props) => {
    if (void 0 !== text && null !== text) {
      if (Array.isArray(text)) {
        return text.map(line => Helpers.evaluateProp(line, props));
      }
      text = Helpers.evaluateProp(text, props);
      if (void 0 !== text && null !== text) {
        return Array.isArray(text) ? text : `${text}`.split("\n");
      }
    }
  }, getDy = (props, verticalAnchor, lineHeight) => {
    const dy = props.dy ? Helpers.evaluateProp(props.dy, props) : 0, length = props.inline ? 1 : props.text.length, capHeight = Helpers.evaluateProp(props.capHeight, props);
    verticalAnchor = verticalAnchor ? Helpers.evaluateProp(verticalAnchor, props) : "middle";
    const fontSizes = [...Array(length).keys()].map(i => getSingleValue(props.style, i).fontSize), lineHeights = [...Array(length).keys()].map(i => getSingleValue(lineHeight, i));
    if ("start" === verticalAnchor) {
      return dy + (capHeight / 2 + lineHeights[0] / 2) * fontSizes[0];
    }
    if (props.inline) {
      return "end" === verticalAnchor ? dy + (capHeight / 2 - lineHeights[0] / 2) * fontSizes[0] : dy + capHeight / 2 * fontSizes[0];
    }
    if (1 === length) {
      return "end" === verticalAnchor ? dy + (capHeight / 2 + (0.5 - length) * lineHeights[0]) * fontSizes[0] : dy + (capHeight / 2 + (0.5 - length / 2) * lineHeights[0]) * fontSizes[0];
    }
    const allHeights = [...Array(length).keys()].reduce((memo, i) => memo + (capHeight / 2 + (0.5 - length) * lineHeights[i]) * fontSizes[i] / length, 0);
    return "end" === verticalAnchor ? dy + allHeights : dy + allHeights / 2 + capHeight / 2 * lineHeights[length - 1] * fontSizes[length - 1];
  }, getXCoordinate = (calculatedProps, labelSizeWidth) => {
    const {direction, textAnchor, x, dx} = calculatedProps;
    if ("rtl" === direction) {
      return x - labelSizeWidth;
    }
    switch(textAnchor) {
      case "middle":
        return Math.round(x - labelSizeWidth / 2);
      case "end":
        return Math.round(x - labelSizeWidth);
      default:
        return x + (dx || 0);
    }
  }, getYCoordinate = (calculatedProps, textHeight) => {
    const {verticalAnchor, y, originalDy = 0} = calculatedProps;
    calculatedProps = y + originalDy;
    switch(verticalAnchor) {
      case "start":
        return Math.floor(calculatedProps);
      case "end":
        return Math.ceil(calculatedProps - textHeight);
      default:
        return Math.floor(calculatedProps - textHeight / 2);
    }
  }, getFullBackground = (calculatedProps, tspanValues) => {
    const {dx = 0, transform, backgroundComponent, backgroundStyle, inline, backgroundPadding, capHeight} = calculatedProps;
    var textSizes = tspanValues.map(tspan => tspan.textSize);
    const height = inline ? Math.max(...textSizes.map(size => size.height)) : textSizes.reduce((memo, size, i) => memo + size.height * (tspanValues[i].lineHeight - (i ? 0 : capHeight / 2)), 0);
    textSizes = inline ? textSizes.reduce((memo, size, index) => memo + size.width + (index ? dx : 0), 0) : Math.max(...textSizes.map(size => size.width));
    const xCoordinate = getXCoordinate(calculatedProps, textSizes);
    calculatedProps = getYCoordinate(calculatedProps, height);
    return _react.default.cloneElement(backgroundComponent, (0,_defaults2.default)({}, backgroundComponent.props, {key:"background", height:height + backgroundPadding.top + backgroundPadding.bottom, style:backgroundStyle, transform, width:textSizes + backgroundPadding.left + backgroundPadding.right, x:inline ? xCoordinate - backgroundPadding.left : xCoordinate + dx - backgroundPadding.left, y:calculatedProps}));
  }, getInlineXOffset = (calculatedProps, textElements, index) => {
    ({textAnchor:calculatedProps} = calculatedProps);
    textElements = textElements.map(t => t.widthWithPadding);
    const centerOffset = -textElements.reduce((memo, width) => memo + width, 0) / 2;
    switch(calculatedProps) {
      case "start":
        return textElements.reduce((memo, width, i) => i < index ? memo + width : memo, 0);
      case "end":
        return textElements.reduce((memo, width, i) => i > index ? memo - width : memo, 0);
      default:
        return textElements.reduce((memo, width, i) => {
          const offsetWidth = i < index ? width : 0;
          return i === index ? memo + width / 2 : memo + offsetWidth;
        }, centerOffset);
    }
  }, getChildBackgrounds = (calculatedProps, tspanValues) => {
    const {dy, dx, transform, backgroundStyle, backgroundPadding, backgroundComponent, inline, y} = calculatedProps, textElements = tspanValues.map((current, i) => {
      const previous = getSingleValue(tspanValues, i - 1), labelSize = current.textSize, totalLineHeight = current.fontSize * current.lineHeight, textHeight = Math.ceil(totalLineHeight), padding = getSingleValue(backgroundPadding, i), prevPadding = getSingleValue(backgroundPadding, i - 1);
      return {textHeight, labelSize, heightWithPadding:textHeight + padding.top + padding.bottom, widthWithPadding:labelSize.width + padding.left + padding.right + (inline ? dx || 0 : 0), y, fontSize:current.fontSize, dy:i && !inline ? previous.fontSize * previous.lineHeight + prevPadding.top + prevPadding.bottom : dy - 0.5 * totalLineHeight - (current.fontSize - current.capHeight)};
    });
    return textElements.map((textElement, i) => {
      var xCoordinate = getXCoordinate(calculatedProps, textElement.labelSize.width), yCoordinate = textElements.slice(0, i + 1).reduce((prev, curr) => prev + curr.dy, y);
      const padding = getSingleValue(backgroundPadding, i), height = textElement.heightWithPadding;
      xCoordinate = inline ? getInlineXOffset(calculatedProps, textElements, i) + xCoordinate - padding.left : xCoordinate;
      yCoordinate = inline ? getYCoordinate(calculatedProps, height) - padding.top : yCoordinate;
      textElement = {key:`tspan-background-${i}`, height, style:getSingleValue(backgroundStyle, i), width:textElement.widthWithPadding, transform, x:xCoordinate - padding.left, y:yCoordinate};
      return _react.default.cloneElement(backgroundComponent, (0,_defaults2.default)({}, backgroundComponent.props, textElement));
    });
  }, evaluateProps = props => {
    const text = getContent(props.text, props), style = getStyles(props.style, Object.assign({}, props, {text})), backgroundStyle = getBackgroundStyles(props.backgroundStyle, Object.assign({}, props, {text, style})), backgroundPadding = getBackgroundPadding(Object.assign({}, props, {text, style, backgroundStyle})), id = Helpers.evaluateProp(props.id, props);
    return Object.assign({}, props, {backgroundStyle, backgroundPadding, style, text, id});
  }, getCalculatedProps = props => {
    const ariaLabel = Helpers.evaluateProp(props.ariaLabel, props);
    var style = getSingleValue(props.style);
    var JSCompiler_inline_result = Helpers.evaluateProp(props.lineHeight, props);
    JSCompiler_inline_result = Array.isArray(JSCompiler_inline_result) ? (0,_isEmpty2.default)(JSCompiler_inline_result) ? [1] : JSCompiler_inline_result : JSCompiler_inline_result;
    const direction = props.direction ? Helpers.evaluateProp(props.direction, props) : "inherit", textAnchor = props.textAnchor ? Helpers.evaluateProp(props.textAnchor, props) : style.textAnchor || "start";
    style = props.verticalAnchor ? Helpers.evaluateProp(props.verticalAnchor, props) : style.verticalAnchor || "middle";
    const dx = props.dx ? Helpers.evaluateProp(props.dx, props) : 0, dy = getDy(props, style, JSCompiler_inline_result), x = void 0 !== props.x ? props.x : props.datum ? Helpers.scalePoint(props, props.datum).x : 0, y = void 0 !== props.y ? props.y : props.datum ? Helpers.scalePoint(props, props.datum).y : 0;
    var {polar} = props;
    var JSCompiler_inline_result$jscomp$0 = getSingleValue(props.style);
    polar = polar ? LabelHelpers.getPolarAngle(props) : 0;
    var baseAngle = void 0 === JSCompiler_inline_result$jscomp$0.angle ? Helpers.evaluateProp(props.angle, props) : JSCompiler_inline_result$jscomp$0.angle;
    polar = void 0 === baseAngle ? polar : baseAngle;
    JSCompiler_inline_result$jscomp$0 = (JSCompiler_inline_result$jscomp$0 = props.transform || JSCompiler_inline_result$jscomp$0.transform) && Helpers.evaluateProp(JSCompiler_inline_result$jscomp$0, props);
    baseAngle = polar && {rotate:[polar, x, y]};
    JSCompiler_inline_result$jscomp$0 = JSCompiler_inline_result$jscomp$0 || polar ? Style.toTransformString(JSCompiler_inline_result$jscomp$0, baseAngle) : void 0;
    return Object.assign({}, props, {ariaLabel, lineHeight:JSCompiler_inline_result, direction, textAnchor, verticalAnchor:style, dx, dy, originalDy:Helpers.evaluateProp(props.dy, props), transform:JSCompiler_inline_result$jscomp$0, x, y});
  }, renderLabel = (calculatedProps, tspanValues) => {
    const {ariaLabel, inline:inline$jscomp$0, className, title, events, direction, text, textAnchor, dx, dy, transform, x, y, desc, id, tabIndex, tspanComponent, textComponent} = calculatedProps;
    var userProps = UserProps.getSafeUserProps(calculatedProps);
    userProps = {"aria-label":ariaLabel, key:"text", ...events, direction, dx, x, y:y + dy, transform, className, title, desc:Helpers.evaluateProp(desc, calculatedProps), tabIndex:Helpers.evaluateProp(tabIndex, calculatedProps), id, ...userProps};
    const tspans = text.map((line, i) => {
      const currentStyle = tspanValues[i].style;
      var JSCompiler_temp_const = inline$jscomp$0 ? dx + tspanValues[i].backgroundPadding.left : dx;
      var {inline} = calculatedProps, current = getSingleValue(tspanValues, i);
      if (i && !inline) {
        inline = getSingleValue(tspanValues, i);
        current = getSingleValue(tspanValues, i - 1);
        var previousHeight = current.fontSize * current.lineHeight;
        previousHeight = previousHeight - current.fontSize / 2 + inline.fontSize / 2 - previousHeight / 2 + inline.fontSize * inline.lineHeight / 2 - (inline.fontSize - inline.capHeight) / 2 + (current.fontSize - current.capHeight) / 2;
        inline = shouldUseMultilineBackgrounds(calculatedProps) ? previousHeight + inline.backgroundPadding.top + current.backgroundPadding.bottom : previousHeight;
      } else {
        inline = inline ? 0 === i ? current.backgroundPadding.top : void 0 : current.backgroundPadding.top;
      }
      return _react.default.cloneElement(tspanComponent, {key:`${id}-key-${i}`, x:inline$jscomp$0 ? void 0 : x, dx:JSCompiler_temp_const, dy:inline, textAnchor:currentStyle.textAnchor || textAnchor, style:currentStyle, children:line});
    });
    return _react.default.cloneElement(textComponent, userProps, tspans);
  }, defaultProps = {backgroundComponent:_react.default.createElement(global.Rect, null), groupComponent:_react.default.createElement("g", null), direction:"inherit", textComponent:_react.default.createElement(module.Text, null), tspanComponent:_react.default.createElement(_tspan.TSpan, null), capHeight:0.71, lineHeight:1};
  require = initialProps => {
    initialProps = evaluateProps({...defaultProps, ...initialProps});
    if (null === initialProps.text || void 0 === initialProps.text) {
      return null;
    }
    var calculatedProps = getCalculatedProps(initialProps);
    const {text, style, capHeight, backgroundPadding, lineHeight} = calculatedProps, tspanValues = text.map((line, i) => {
      const currentStyle = getSingleValue(style, i), capHeightPx = TextSize.convertLengthToPixels(`${capHeight}em`, currentStyle.fontSize), currentLineHeight = getSingleValue(lineHeight, i);
      return {style:currentStyle, fontSize:currentStyle.fontSize || defaultStyles.fontSize, capHeight:capHeightPx, text:line, textSize:TextSize.approximateTextSize(line, currentStyle), lineHeight:currentLineHeight, backgroundPadding:getSingleValue(backgroundPadding, i)};
    }), label = renderLabel(calculatedProps, tspanValues);
    return initialProps.backgroundStyle ? (calculatedProps = [shouldUseMultilineBackgrounds(calculatedProps) ? getChildBackgrounds(calculatedProps, tspanValues) : getFullBackground(calculatedProps, tspanValues), label], calculatedProps = _react.default.cloneElement(initialProps.groupComponent, {}, calculatedProps), initialProps.renderInPortal ? _react.default.createElement(_victoryPortal.VictoryPortal, null, calculatedProps) : calculatedProps) : initialProps.renderInPortal ? _react.default.createElement(_victoryPortal.VictoryPortal, 
    null, label) : label;
  };
  exports.VictoryLabel = require;
  require.displayName = "VictoryLabel";
  require.role = "label";
  require.defaultStyles = defaultStyles;
};

//# sourceMappingURL=module$node_modules$victory_core$lib$victory_label$victory_label.js.map
