shadow$provide.module$node_modules$victory_cursor_container$lib$cursor_helpers = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.CursorHelpers = void 0;
  var _throttle2 = function(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }(require("module$node_modules$lodash$throttle")), _victoryCore = require("module$node_modules$victory_core$lib$index");
  class CursorHelpersClass {
    constructor() {
      this.handleMouseMove = (evt, targetProps) => {
        const {onCursorChange, domain} = targetProps, cursorDimension = this.getDimension(targetProps), parentSVG = targetProps.parentSVG || _victoryCore.Selection.getParentSVG(evt);
        evt = _victoryCore.Selection.getSVGEventCoordinates(evt, parentSVG);
        let cursorValue = _victoryCore.Selection.getDataCoordinates(targetProps, targetProps.scale, evt.x, evt.y);
        this.withinBounds(cursorValue, {x1:domain.x[0], x2:domain.x[1], y1:domain.y[0], y2:domain.y[1]}) || (cursorValue = null);
        _victoryCore.Helpers.isFunction(onCursorChange) && (cursorValue ? onCursorChange(cursorDimension ? cursorValue[cursorDimension] : cursorValue, targetProps) : cursorValue !== targetProps.cursorValue && onCursorChange(targetProps.defaultCursorValue || null, targetProps));
        return [{target:"parent", eventKey:"parent", mutation:() => ({cursorValue, parentSVG})}];
      };
      this.onMouseMove = (0,_throttle2.default)(this.handleMouseMove, 16, {leading:!0, trailing:!1});
      this.onMouseLeave = this.handleMouseMove;
      this.onTouchEnd = (evt, targetProps) => {
        ({onCursorChange:evt} = targetProps);
        _victoryCore.Helpers.isFunction(targetProps.onCursorChange) && evt(null, targetProps);
        return [{target:"parent", eventKey:"parent", mutation:() => ({cursorValue:null})}];
      };
    }
    getDimension(props) {
      const {horizontal, cursorDimension} = props;
      return horizontal && cursorDimension ? "x" === cursorDimension ? "y" : "x" : cursorDimension;
    }
    withinBounds(point, bounds) {
      const {x1, x2, y1, y2} = _victoryCore.Helpers.mapValues(bounds, Number), {x, y} = _victoryCore.Helpers.mapValues(point, Number);
      return x >= Math.min(x1, x2) && x <= Math.max(x1, x2) && y >= Math.min(y1, y2) && y <= Math.max(y1, y2);
    }
  }
  exports.CursorHelpers = new CursorHelpersClass();
};

//# sourceMappingURL=module$node_modules$victory_cursor_container$lib$cursor_helpers.js.map
