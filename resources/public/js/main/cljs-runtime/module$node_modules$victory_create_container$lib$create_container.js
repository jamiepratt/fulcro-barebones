shadow$provide.module$node_modules$victory_create_container$lib$create_container = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  function ensureArray(thing) {
    return thing ? Array.isArray(thing) ? thing : [thing] : [];
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.makeCreateContainerFunction = exports.createContainer = exports.combineContainerMixins = void 0;
  var _isEmpty2 = _interopRequireDefault(require("module$node_modules$lodash$isEmpty")), _flow2 = _interopRequireDefault(require("module$node_modules$lodash$flow")), _forOwn2 = _interopRequireDefault(require("module$node_modules$lodash$forOwn")), _groupBy2 = _interopRequireDefault(require("module$node_modules$lodash$groupBy")), _toPairs2 = _interopRequireDefault(require("module$node_modules$lodash$toPairs")), _victoryCore = require("module$node_modules$victory_core$lib$index");
  global = require("module$node_modules$victory_voronoi_container$lib$index");
  module = require("module$node_modules$victory_zoom_container$lib$index");
  var _victorySelectionContainer = require("module$node_modules$victory_selection_container$lib$index"), _victoryBrushContainer = require("module$node_modules$victory_brush_container$lib$index");
  require = require("module$node_modules$victory_cursor_container$lib$index");
  const combineEventHandlers = eventHandlersArray => eventHandlersArray.reduce((localHandlers, finalHandlers) => {
    (0,_forOwn2.default)(localHandlers, (localHandler, eventName) => {
      const existingHandler = finalHandlers[eventName];
      finalHandlers[eventName] = existingHandler ? function() {
        const existingMutations = ensureArray(existingHandler(...arguments)), localMutations = ensureArray(localHandler(...arguments));
        return existingMutations.concat(localMutations);
      } : localHandler;
    });
    return finalHandlers;
  }), combineDefaultEvents = defaultEvents => {
    defaultEvents = (0,_groupBy2.default)(defaultEvents, "target");
    return (0,_toPairs2.default)(defaultEvents).map(_ref => {
      let [target, eventsArray] = _ref;
      _ref = eventsArray.filter(Boolean);
      return (0,_isEmpty2.default)(_ref) ? null : {target, eventHandlers:combineEventHandlers(eventsArray.map(event => event.eventHandlers))};
    }).filter(Boolean);
  }, combineContainerMixins = (mixins, Container) => {
    const Classes = mixins.map(mixin => mixin(Container)), instances = Classes.map(Class => new Class());
    mixins = (0,_flow2.default)(mixins)(Container);
    const displayType = Classes.map(Class => Class.displayName.match(/Victory(.*)Container/)[1] || "").join("");
    mixins = class extends mixins {
      static $jscomp$static$init$1201363678$0$displayName() {
        return `Victory${displayType}Container`;
      }
      static $jscomp$static$init$1201363678$1$propTypes() {
        return Classes.reduce((propTypes, Class) => ({...propTypes, ...Class.propTypes}), {});
      }
      static $jscomp$static$init$1201363678$2$defaultProps() {
        return Classes.reduce((defaultProps, Class) => ({...defaultProps, ...Class.defaultProps}), {});
      }
      static defaultEvents(props) {
        return combineDefaultEvents(Classes.reduce((defaultEvents, Class) => {
          Class = _victoryCore.Helpers.isFunction(Class.defaultEvents) ? Class.defaultEvents(props) : Class.defaultEvents;
          return [...defaultEvents, ...Class];
        }, []));
      }
      getChildren(props) {
        return instances.reduce((children, instance) => instance.getChildren({...props, children}), props.children);
      }
    };
    mixins.displayName = mixins.$jscomp$static$init$1201363678$0$displayName();
    mixins.propTypes = mixins.$jscomp$static$init$1201363678$1$propTypes();
    mixins.defaultProps = mixins.$jscomp$static$init$1201363678$2$defaultProps();
    return mixins;
  };
  exports.combineContainerMixins = combineContainerMixins;
  const checkBehaviorName = (behavior, behaviors) => {
    behavior && !behaviors.includes(behavior) && _victoryCore.Log.warn(`"${behavior}" is not a valid behavior. Choose from [${behaviors.join(", ")}].`);
  }, makeCreateContainerFunction = (mixinMap, Container) => function(behaviorA, behaviorB) {
    var behaviors = Object.keys(mixinMap);
    checkBehaviorName(behaviorA, behaviors);
    checkBehaviorName(behaviorB, behaviors);
    (2 >= arguments.length ? 0 : arguments.length - 2) && _victoryCore.Log.warn("too many arguments given to createContainer (maximum accepted: 2).");
    behaviors = mixinMap[behaviorA];
    const secondMixins = mixinMap[behaviorB] || [];
    return behaviors ? combineContainerMixins([...behaviors, ...secondMixins], Container) : Container;
  };
  exports.makeCreateContainerFunction = makeCreateContainerFunction;
  exports.createContainer = makeCreateContainerFunction({zoom:[module.zoomContainerMixin], voronoi:[global.voronoiContainerMixin], selection:[_victorySelectionContainer.selectionContainerMixin], cursor:[require.cursorContainerMixin], brush:[_victoryBrushContainer.brushContainerMixin]}, _victoryCore.VictoryContainer);
};

//# sourceMappingURL=module$node_modules$victory_create_container$lib$create_container.js.map
