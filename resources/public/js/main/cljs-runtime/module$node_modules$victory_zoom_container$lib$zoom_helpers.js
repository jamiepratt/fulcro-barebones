shadow$provide.module$node_modules$victory_zoom_container$lib$zoom_helpers = function(global, require, module, exports) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default:obj};
  }
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.ZoomHelpers = exports.RawZoomHelpers = void 0;
  var _delay2 = _interopRequireDefault(require("module$node_modules$lodash$delay")), _defaults2 = _interopRequireDefault(require("module$node_modules$lodash$defaults"));
  global = _interopRequireDefault(require("module$node_modules$lodash$throttle"));
  var _react = require("module$node_modules$react$index"), _victoryCore = require("module$node_modules$victory_core$lib$index");
  require = exports.RawZoomHelpers = {checkDomainEquality(a, b) {
    const checkDimension = dim => {
      const val1 = a && a[dim];
      dim = b && b[dim];
      return val1 || dim ? val1 && dim ? Number(val1[0]) === Number(dim[0]) && Number(val1[1]) === Number(dim[1]) : !1 : !0;
    };
    return checkDimension("x") && checkDimension("y");
  }, scale(currentDomain, evt, props, axis) {
    const [from, to] = currentDomain, range = Math.abs(to - from), minimumZoom = props.minimumZoom && props.minimumZoom[axis], factor = this.getScaleFactor(evt);
    if (minimumZoom && range <= minimumZoom && 1 > factor) {
      return currentDomain;
    }
    const [fromBound, toBound] = this.getDomain(props)[axis];
    evt = this.getScalePercent(evt, props, axis);
    props = this.getMinimumDomain(factor * from + evt * factor * range, props, axis);
    const [newMin, newMax] = this.getScaledDomain(currentDomain, factor, evt);
    currentDomain = [newMin > fromBound && newMin < toBound ? newMin : fromBound, newMax < toBound && newMax > fromBound ? newMax : toBound];
    currentDomain = Math.abs(props[1] - props[0]) > Math.abs(currentDomain[1] - currentDomain[0]) ? props : currentDomain;
    return _victoryCore.Collection.containsDates([fromBound, toBound]) ? [new Date(currentDomain[0]), new Date(currentDomain[1])] : currentDomain;
  }, getScaledDomain(currentDomain, factor, percent) {
    const [from, to] = currentDomain;
    currentDomain = Math.abs(to - from);
    currentDomain -= currentDomain * factor;
    factor = Number(from) + currentDomain * percent;
    percent = Number(to) - currentDomain * (1 - percent);
    return [Math.min(factor, percent), Math.max(factor, percent)];
  }, getMinimumDomain(point, props, axis) {
    var {minimumZoom} = props;
    props = this.getDomain(props)[axis];
    const [from, to] = props;
    props = Math.abs(from - to) / 1000;
    axis = minimumZoom ? minimumZoom[axis] || props : props;
    minimumZoom = point - axis / 2;
    point += axis / 2;
    return [minimumZoom > from && minimumZoom < to ? minimumZoom : from, point < to && point > from ? point : Number(from) + axis / 2];
  }, zoommingOut(evt) {
    return 0 < evt.deltaY;
  }, getScaleFactor(evt) {
    const sign = this.zoommingOut(evt) ? 1 : -1;
    return Math.abs(1 + sign * Math.min(Math.abs(evt.deltaY / 300), 0.5));
  }, getScalePercent(evt, props, axis) {
    const originalDomain = this.getDomain(props), [from, to] = originalDomain[axis];
    return (this.getPosition(evt, props, originalDomain)[axis] - from) / Math.abs(to - from);
  }, getPosition(evt, props, originalDomain) {
    const {x, y} = _victoryCore.Selection.getSVGEventCoordinates(evt);
    evt = {x:props.scale.x.domain(originalDomain.x), y:props.scale.y.domain(originalDomain.y)};
    return _victoryCore.Selection.getDataCoordinates(props, evt, x, y);
  }, pan(currentDomain, originalDomain, delta) {
    const [fromCurrent, toCurrent] = currentDomain.map(val => Number(val)), [fromOriginal, toOriginal] = originalDomain.map(val => Number(val));
    var lowerBound = fromCurrent + delta;
    delta = toCurrent + delta;
    lowerBound = lowerBound > fromOriginal && delta < toOriginal ? [lowerBound, delta] : lowerBound < fromOriginal ? [fromOriginal, fromOriginal + (toCurrent - fromCurrent)] : delta > toOriginal ? [toOriginal - (toCurrent - fromCurrent), toOriginal] : currentDomain;
    return _victoryCore.Collection.containsDates(currentDomain) || _victoryCore.Collection.containsDates(originalDomain) ? lowerBound.map(val => new Date(val)) : lowerBound;
  }, getDomainScale(domain, scale, axis) {
    domain = Array.isArray(domain) ? domain : domain[axis];
    const [from, to] = domain;
    scale = scale[axis].range();
    return Math.abs(scale[0] - scale[1]) / (to - from);
  }, handleAnimation(ctx) {
    const animationTimer = ctx.context.animationTimer, transitionTimer = ctx.context.transitionTimer;
    transitionTimer.bypassAnimation();
    animationTimer.bypassAnimation();
    return (0,_delay2.default)(() => {
      animationTimer.resumeAnimation();
      transitionTimer.resumeAnimation();
    }, 16);
  }, getLastDomain(targetProps, originalDomain) {
    const {zoomDomain, cachedZoomDomain, currentDomain, domain} = targetProps;
    return zoomDomain && !this.checkDomainEquality(zoomDomain, cachedZoomDomain) ? (0,_defaults2.default)({}, zoomDomain, domain) : (0,_defaults2.default)({}, currentDomain || zoomDomain || originalDomain, domain);
  }, getDomain(props) {
    const {originalDomain, domain, children, zoomDimension} = props, childComponents = _react.Children.toArray(children);
    let childrenDomain = {};
    childComponents.length && (childrenDomain = zoomDimension ? {[zoomDimension]:_victoryCore.Wrapper.getDomainFromChildren(props, zoomDimension, childComponents)} : {x:_victoryCore.Wrapper.getDomainFromChildren(props, "x", childComponents), y:_victoryCore.Wrapper.getDomainFromChildren(props, "y", childComponents)});
    return (0,_defaults2.default)({}, childrenDomain, originalDomain, domain);
  }, onMouseDown(evt, targetProps) {
    evt.preventDefault();
    if (targetProps.allowPan) {
      var parentSVG = targetProps.parentSVG || _victoryCore.Selection.getParentSVG(evt), {x, y} = _victoryCore.Selection.getSVGEventCoordinates(evt, parentSVG);
      return [{target:"parent", mutation:() => ({startX:x, startY:y, panning:!0, parentSVG, parentControlledProps:["domain"]})}];
    }
  }, onMouseUp(evt, targetProps) {
    if (targetProps.allowPan) {
      return [{target:"parent", mutation:() => ({panning:!1})}];
    }
  }, onMouseLeave(evt, targetProps) {
    if (targetProps.allowPan) {
      return [{target:"parent", mutation:() => ({panning:!1})}];
    }
  }, onMouseMove(evt, targetProps, eventKey, ctx) {
    if (targetProps.panning && targetProps.allowPan) {
      const {scale, startX, startY, onZoomDomainChange, zoomDomain, zoomDimension, horizontal} = targetProps;
      eventKey = targetProps.parentSVG || _victoryCore.Selection.getParentSVG(evt);
      const {x, y} = _victoryCore.Selection.getSVGEventCoordinates(evt, eventKey);
      evt = this.getDomain(targetProps);
      var lastDomain = this.getLastDomain(targetProps, evt), deltaY = horizontal ? startX - x : y - startY, dx = (horizontal ? y - startY : startX - x) / this.getDomainScale(lastDomain, scale, "x");
      deltaY /= this.getDomainScale(lastDomain, scale, "y");
      dx = {x:"y" === zoomDimension ? evt.x : this.pan(lastDomain.x, evt.x, dx), y:"x" === zoomDimension ? evt.y : this.pan(lastDomain.y, evt.y, deltaY)};
      ctx = this.handleAnimation(ctx);
      lastDomain = !this.checkDomainEquality(evt, lastDomain);
      const mutatedProps = {parentControlledProps:["domain"], startX:x, startY:y, parentSVG:eventKey, currentDomain:dx, originalDomain:evt, cachedZoomDomain:zoomDomain, zoomActive:lastDomain};
      _victoryCore.Helpers.isFunction(onZoomDomainChange) && onZoomDomainChange(dx, (0,_defaults2.default)({}, mutatedProps, targetProps));
      return [{target:"parent", callback:ctx, mutation:() => mutatedProps}];
    }
  }, onWheel(evt, targetProps, eventKey, ctx) {
    if (targetProps.allowZoom) {
      var {onZoomDomainChange, zoomDimension, zoomDomain} = targetProps;
      eventKey = this.getDomain(targetProps);
      var lastDomain = this.getLastDomain(targetProps, eventKey), {x, y} = lastDomain, currentDomain = {x:"y" === zoomDimension ? lastDomain.x : this.scale(x, evt, targetProps, "x"), y:"x" === zoomDimension ? lastDomain.y : this.scale(y, evt, targetProps, "y")};
      ctx = this.handleAnimation(ctx);
      evt = !this.zoommingOut(evt) || targetProps.zoomActive && !this.checkDomainEquality(eventKey, lastDomain);
      var mutatedProps = {currentDomain, originalDomain:eventKey, cachedZoomDomain:zoomDomain, parentControlledProps:["domain"], panning:!1, zoomActive:evt};
      _victoryCore.Helpers.isFunction(onZoomDomainChange) && onZoomDomainChange(currentDomain, (0,_defaults2.default)({}, mutatedProps, targetProps));
      return [{target:"parent", callback:ctx, mutation:() => mutatedProps}];
    }
  }};
  exports.ZoomHelpers = {checkDomainEquality:require.checkDomainEquality.bind(require), onMouseDown:require.onMouseDown.bind(require), onMouseUp:require.onMouseUp.bind(require), onMouseLeave:require.onMouseLeave.bind(require), onMouseMove:(0,global.default)(require.onMouseMove.bind(require), 16, {leading:!0, trailing:!1}), onWheel:(0,global.default)(require.onWheel.bind(require), 16, {leading:!0, trailing:!1})};
};

//# sourceMappingURL=module$node_modules$victory_zoom_container$lib$zoom_helpers.js.map
